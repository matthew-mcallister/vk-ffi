impl_enums! {
    bitmask QueryPoolCreateFlags {
    };
    bitmask PipelineDynamicStateCreateFlags {
    };
    bitmask PipelineMultisampleStateCreateFlags {
    };
    bitmask PipelineRasterizationStateCreateFlags {
    };
    bitmask PipelineViewportStateCreateFlags {
    };
    bitmask PipelineTessellationStateCreateFlags {
    };
    bitmask PipelineInputAssemblyStateCreateFlags {
    };
    bitmask PipelineVertexInputStateCreateFlags {
    };
    bitmask BufferViewCreateFlags {
    };
    bitmask DeviceCreateFlags {
    };
    bitmask SemaphoreCreateFlags {
    };
    bitmask ShaderModuleCreateFlags {
    };
    bitmask MemoryMapFlags {
    };
    bitmask DescriptorPoolResetFlags {
    };
    bitmask PrivateDataSlotCreateFlags {
    };
    bitmask DescriptorUpdateTemplateCreateFlags {
    };
    bitmask64 AccessFlags2 {
    };
    bitmask64 PipelineStageFlags2 {
    };
    bitmask AccelerationStructureMotionInfoFlagsNV {
    };
    bitmask AccelerationStructureMotionInstanceFlagsNV {
    };
    bitmask64 FormatFeatureFlags2 {
    };
    bitmask DisplayModeCreateFlagsKHR {
    };
    bitmask DisplaySurfaceCreateFlagsKHR {
    };
    bitmask AndroidSurfaceCreateFlagsKHR {
    };
    bitmask ViSurfaceCreateFlagsNN {
    };
    bitmask WaylandSurfaceCreateFlagsKHR {
    };
    bitmask Win32SurfaceCreateFlagsKHR {
    };
    bitmask XlibSurfaceCreateFlagsKHR {
    };
    bitmask XcbSurfaceCreateFlagsKHR {
    };
    bitmask DirectFBSurfaceCreateFlagsEXT {
    };
    bitmask IOSSurfaceCreateFlagsMVK {
    };
    bitmask MacOSSurfaceCreateFlagsMVK {
    };
    bitmask MetalSurfaceCreateFlagsEXT {
    };
    bitmask ImagePipeSurfaceCreateFlagsFUCHSIA {
    };
    bitmask StreamDescriptorSurfaceCreateFlagsGGP {
    };
    bitmask HeadlessSurfaceCreateFlagsEXT {
    };
    bitmask ScreenSurfaceCreateFlagsQNX {
    };
    bitmask CommandPoolTrimFlags {
    };
    bitmask PipelineViewportSwizzleStateCreateFlagsNV {
    };
    bitmask PipelineDiscardRectangleStateCreateFlagsEXT {
    };
    bitmask PipelineCoverageToColorStateCreateFlagsNV {
    };
    bitmask PipelineCoverageModulationStateCreateFlagsNV {
    };
    bitmask PipelineCoverageReductionStateCreateFlagsNV {
    };
    bitmask ValidationCacheCreateFlagsEXT {
    };
    bitmask DebugUtilsMessengerCreateFlagsEXT {
    };
    bitmask DebugUtilsMessengerCallbackDataFlagsEXT {
    };
    bitmask DeviceMemoryReportFlagsEXT {
    };
    bitmask PipelineRasterizationConservativeStateCreateFlagsEXT {
    };
    bitmask PipelineRasterizationStateStreamCreateFlagsEXT {
    };
    bitmask PipelineRasterizationDepthClipStateCreateFlagsEXT {
    };
    bitmask ImageFormatConstraintsFlagsFUCHSIA {
    };
    bitmask VideoSessionParametersCreateFlagsKHR {
    };
    bitmask VideoBeginCodingFlagsKHR {
    };
    bitmask VideoEndCodingFlagsKHR {
    };
    bitmask VideoDecodeFlagsKHR {
    };
    bitmask VideoEncodeFlagsKHR {
    };
    bitmask VideoEncodeRateControlFlagsKHR {
    };
    enum AttachmentLoadOp {
        LOAD = 0,
        CLEAR = 1,
        DONT_CARE = 2,
        NONE_EXT = 1000400000,
    };
    enum AttachmentStoreOp {
        STORE = 0,
        DONT_CARE = 1,
        NONE = 1000301000,
        NONE_KHR = 1000301000,
        NONE_QCOM = 1000301000,
        NONE_EXT = 1000301000,
    };
    enum BlendFactor {
        ZERO = 0,
        ONE = 1,
        SRC_COLOR = 2,
        ONE_MINUS_SRC_COLOR = 3,
        DST_COLOR = 4,
        ONE_MINUS_DST_COLOR = 5,
        SRC_ALPHA = 6,
        ONE_MINUS_SRC_ALPHA = 7,
        DST_ALPHA = 8,
        ONE_MINUS_DST_ALPHA = 9,
        CONSTANT_COLOR = 10,
        ONE_MINUS_CONSTANT_COLOR = 11,
        CONSTANT_ALPHA = 12,
        ONE_MINUS_CONSTANT_ALPHA = 13,
        SRC_ALPHA_SATURATE = 14,
        SRC1_COLOR = 15,
        ONE_MINUS_SRC1_COLOR = 16,
        SRC1_ALPHA = 17,
        ONE_MINUS_SRC1_ALPHA = 18,
    };
    enum BlendOp {
        ADD = 0,
        SUBTRACT = 1,
        REVERSE_SUBTRACT = 2,
        MIN = 3,
        MAX = 4,
        ZERO_EXT = 1000148000,
        SRC_EXT = 1000148001,
        DST_EXT = 1000148002,
        SRC_OVER_EXT = 1000148003,
        DST_OVER_EXT = 1000148004,
        SRC_IN_EXT = 1000148005,
        DST_IN_EXT = 1000148006,
        SRC_OUT_EXT = 1000148007,
        DST_OUT_EXT = 1000148008,
        SRC_ATOP_EXT = 1000148009,
        DST_ATOP_EXT = 1000148010,
        XOR_EXT = 1000148011,
        MULTIPLY_EXT = 1000148012,
        SCREEN_EXT = 1000148013,
        OVERLAY_EXT = 1000148014,
        DARKEN_EXT = 1000148015,
        LIGHTEN_EXT = 1000148016,
        COLORDODGE_EXT = 1000148017,
        COLORBURN_EXT = 1000148018,
        HARDLIGHT_EXT = 1000148019,
        SOFTLIGHT_EXT = 1000148020,
        DIFFERENCE_EXT = 1000148021,
        EXCLUSION_EXT = 1000148022,
        INVERT_EXT = 1000148023,
        INVERT_RGB_EXT = 1000148024,
        LINEARDODGE_EXT = 1000148025,
        LINEARBURN_EXT = 1000148026,
        VIVIDLIGHT_EXT = 1000148027,
        LINEARLIGHT_EXT = 1000148028,
        PINLIGHT_EXT = 1000148029,
        HARDMIX_EXT = 1000148030,
        HSL_HUE_EXT = 1000148031,
        HSL_SATURATION_EXT = 1000148032,
        HSL_COLOR_EXT = 1000148033,
        HSL_LUMINOSITY_EXT = 1000148034,
        PLUS_EXT = 1000148035,
        PLUS_CLAMPED_EXT = 1000148036,
        PLUS_CLAMPED_ALPHA_EXT = 1000148037,
        PLUS_DARKER_EXT = 1000148038,
        MINUS_EXT = 1000148039,
        MINUS_CLAMPED_EXT = 1000148040,
        CONTRAST_EXT = 1000148041,
        INVERT_OVG_EXT = 1000148042,
        RED_EXT = 1000148043,
        GREEN_EXT = 1000148044,
        BLUE_EXT = 1000148045,
    };
    enum BorderColor {
        FLOAT_TRANSPARENT_BLACK = 0,
        INT_TRANSPARENT_BLACK = 1,
        FLOAT_OPAQUE_BLACK = 2,
        INT_OPAQUE_BLACK = 3,
        FLOAT_OPAQUE_WHITE = 4,
        INT_OPAQUE_WHITE = 5,
        FLOAT_CUSTOM_EXT = 1000287003,
        INT_CUSTOM_EXT = 1000287004,
    };
    bitmask FramebufferCreateFlagBits {
        IMAGELESS_BIT = 1,
        IMAGELESS_BIT_KHR = 1,
    };
    enum QueryPoolCreateFlagBits {
    };
    bitmask RenderPassCreateFlagBits {
        RESERVED_0_BIT_KHR = 1,
        TRANSFORM_BIT_QCOM = 2,
    };
    bitmask SamplerCreateFlagBits {
        SUBSAMPLED_BIT_EXT = 1,
        SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 2,
        RESERVED_3_BIT_AMD = 8,
        NON_SEAMLESS_CUBE_MAP_BIT_EXT = 4,
        IMAGE_PROCESSING_BIT_QCOM = 16,
    };
    enum PipelineCacheHeaderVersion {
        ONE = 1,
    };
    bitmask PipelineCacheCreateFlagBits {
        EXTERNALLY_SYNCHRONIZED_BIT = 1,
        RESERVED_1_BIT_EXT = 2,
        RESERVED_2_BIT_KHR = 4,
        EXTERNALLY_SYNCHRONIZED_BIT_EXT = 1,
        RESERVED_1_BIT_KHR = 2,
    };
    bitmask PipelineShaderStageCreateFlagBits {
        ALLOW_VARYING_SUBGROUP_SIZE_BIT = 1,
        REQUIRE_FULL_SUBGROUPS_BIT = 2,
        RESERVED_3_BIT_KHR = 8,
        ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 1,
        REQUIRE_FULL_SUBGROUPS_BIT_EXT = 2,
    };
    bitmask DescriptorSetLayoutCreateFlagBits {
        UPDATE_AFTER_BIND_POOL_BIT = 2,
        PUSH_DESCRIPTOR_BIT_KHR = 1,
        RESERVED_4_BIT_AMD = 16,
        RESERVED_5_BIT_AMD = 32,
        RESERVED_3_BIT_AMD = 8,
        HOST_ONLY_POOL_BIT_EXT = 4,
        UPDATE_AFTER_BIND_POOL_BIT_EXT = 2,
        HOST_ONLY_POOL_BIT_VALVE = 4,
    };
    bitmask InstanceCreateFlagBits {
        ENUMERATE_PORTABILITY_BIT_KHR = 1,
    };
    bitmask DeviceQueueCreateFlagBits {
        PROTECTED_BIT = 1,
        RESERVED_1_BIT_QCOM = 2,
    };
    bitmask BufferCreateFlagBits {
        SPARSE_BINDING_BIT = 1,
        SPARSE_RESIDENCY_BIT = 2,
        SPARSE_ALIASED_BIT = 4,
        PROTECTED_BIT = 8,
        DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 16,
        RESERVED_5_BIT_AMD = 32,
        DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 16,
        DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 16,
    };
    bitmask BufferUsageFlagBits {
        TRANSFER_SRC_BIT = 1,
        TRANSFER_DST_BIT = 2,
        UNIFORM_TEXEL_BUFFER_BIT = 4,
        STORAGE_TEXEL_BUFFER_BIT = 8,
        UNIFORM_BUFFER_BIT = 16,
        STORAGE_BUFFER_BIT = 32,
        INDEX_BUFFER_BIT = 64,
        VERTEX_BUFFER_BIT = 128,
        INDIRECT_BUFFER_BIT = 256,
        SHADER_DEVICE_ADDRESS_BIT = 131072,
        VIDEO_DECODE_SRC_BIT_KHR = 8192,
        VIDEO_DECODE_DST_BIT_KHR = 16384,
        TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 2048,
        TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 4096,
        CONDITIONAL_RENDERING_BIT_EXT = 512,
        RESERVED_25_BIT_AMD = 33554432,
        ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 524288,
        ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 1048576,
        SHADER_BINDING_TABLE_BIT_KHR = 1024,
        RESERVED_18_BIT_QCOM = 262144,
        VIDEO_ENCODE_DST_BIT_KHR = 32768,
        VIDEO_ENCODE_SRC_BIT_KHR = 65536,
        RESERVED_21_BIT_AMD = 2097152,
        RESERVED_22_BIT_AMD = 4194304,
        MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 8388608,
        MICROMAP_STORAGE_BIT_EXT = 16777216,
        RAY_TRACING_BIT_NV = 1024,
        SHADER_DEVICE_ADDRESS_BIT_EXT = 131072,
        SHADER_DEVICE_ADDRESS_BIT_KHR = 131072,
    };
    bitmask ColorComponentFlagBits {
        R_BIT = 1,
        G_BIT = 2,
        B_BIT = 4,
        A_BIT = 8,
    };
    enum ComponentSwizzle {
        IDENTITY = 0,
        ZERO = 1,
        ONE = 2,
        R = 3,
        G = 4,
        B = 5,
        A = 6,
    };
    bitmask CommandPoolCreateFlagBits {
        TRANSIENT_BIT = 1,
        RESET_COMMAND_BUFFER_BIT = 2,
        PROTECTED_BIT = 4,
    };
    bitmask CommandPoolResetFlagBits {
        RELEASE_RESOURCES_BIT = 1,
        RESERVED_1_BIT_COREAVI = 2,
    };
    bitmask CommandBufferResetFlagBits {
        RELEASE_RESOURCES_BIT = 1,
    };
    enum CommandBufferLevel {
        PRIMARY = 0,
        SECONDARY = 1,
    };
    bitmask CommandBufferUsageFlagBits {
        ONE_TIME_SUBMIT_BIT = 1,
        RENDER_PASS_CONTINUE_BIT = 2,
        SIMULTANEOUS_USE_BIT = 4,
    };
    enum CompareOp {
        NEVER = 0,
        LESS = 1,
        EQUAL = 2,
        LESS_OR_EQUAL = 3,
        GREATER = 4,
        NOT_EQUAL = 5,
        GREATER_OR_EQUAL = 6,
        ALWAYS = 7,
    };
    bitmask CullModeFlagBits {
        NONE = 0,
        FRONT_BIT = 1,
        BACK_BIT = 2,
        FRONT_AND_BACK = 3,
    };
    enum DescriptorType {
        SAMPLER = 0,
        COMBINED_IMAGE_SAMPLER = 1,
        SAMPLED_IMAGE = 2,
        STORAGE_IMAGE = 3,
        UNIFORM_TEXEL_BUFFER = 4,
        STORAGE_TEXEL_BUFFER = 5,
        UNIFORM_BUFFER = 6,
        STORAGE_BUFFER = 7,
        UNIFORM_BUFFER_DYNAMIC = 8,
        STORAGE_BUFFER_DYNAMIC = 9,
        INPUT_ATTACHMENT = 10,
        INLINE_UNIFORM_BLOCK = 1000138000,
        ACCELERATION_STRUCTURE_KHR = 1000150000,
        ACCELERATION_STRUCTURE_NV = 1000165000,
        SAMPLE_WEIGHT_IMAGE_QCOM = 1000440000,
        BLOCK_MATCH_IMAGE_QCOM = 1000440001,
        MUTABLE_EXT = 1000351000,
        INLINE_UNIFORM_BLOCK_EXT = 1000138000,
        MUTABLE_VALVE = 1000351000,
    };
    enum DeviceCreateFlagBits {
    };
    enum DynamicState {
        VIEWPORT = 0,
        SCISSOR = 1,
        LINE_WIDTH = 2,
        DEPTH_BIAS = 3,
        BLEND_CONSTANTS = 4,
        DEPTH_BOUNDS = 5,
        STENCIL_COMPARE_MASK = 6,
        STENCIL_WRITE_MASK = 7,
        STENCIL_REFERENCE = 8,
        CULL_MODE = 1000267000,
        FRONT_FACE = 1000267001,
        PRIMITIVE_TOPOLOGY = 1000267002,
        VIEWPORT_WITH_COUNT = 1000267003,
        SCISSOR_WITH_COUNT = 1000267004,
        VERTEX_INPUT_BINDING_STRIDE = 1000267005,
        DEPTH_TEST_ENABLE = 1000267006,
        DEPTH_WRITE_ENABLE = 1000267007,
        DEPTH_COMPARE_OP = 1000267008,
        DEPTH_BOUNDS_TEST_ENABLE = 1000267009,
        STENCIL_TEST_ENABLE = 1000267010,
        STENCIL_OP = 1000267011,
        RASTERIZER_DISCARD_ENABLE = 1000377001,
        DEPTH_BIAS_ENABLE = 1000377002,
        PRIMITIVE_RESTART_ENABLE = 1000377004,
        VIEWPORT_W_SCALING_NV = 1000087000,
        DISCARD_RECTANGLE_EXT = 1000099000,
        SAMPLE_LOCATIONS_EXT = 1000143000,
        RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
        VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
        VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
        EXCLUSIVE_SCISSOR_NV = 1000205001,
        FRAGMENT_SHADING_RATE_KHR = 1000226000,
        LINE_STIPPLE_EXT = 1000259000,
        VERTEX_INPUT_EXT = 1000352000,
        PATCH_CONTROL_POINTS_EXT = 1000377000,
        LOGIC_OP_EXT = 1000377003,
        COLOR_WRITE_ENABLE_EXT = 1000381000,
        TESSELLATION_DOMAIN_ORIGIN_EXT = 1000455002,
        DEPTH_CLAMP_ENABLE_EXT = 1000455003,
        POLYGON_MODE_EXT = 1000455004,
        RASTERIZATION_SAMPLES_EXT = 1000455005,
        SAMPLE_MASK_EXT = 1000455006,
        ALPHA_TO_COVERAGE_ENABLE_EXT = 1000455007,
        ALPHA_TO_ONE_ENABLE_EXT = 1000455008,
        LOGIC_OP_ENABLE_EXT = 1000455009,
        COLOR_BLEND_ENABLE_EXT = 1000455010,
        COLOR_BLEND_EQUATION_EXT = 1000455011,
        COLOR_WRITE_MASK_EXT = 1000455012,
        RASTERIZATION_STREAM_EXT = 1000455013,
        CONSERVATIVE_RASTERIZATION_MODE_EXT = 1000455014,
        EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 1000455015,
        DEPTH_CLIP_ENABLE_EXT = 1000455016,
        SAMPLE_LOCATIONS_ENABLE_EXT = 1000455017,
        COLOR_BLEND_ADVANCED_EXT = 1000455018,
        PROVOKING_VERTEX_MODE_EXT = 1000455019,
        LINE_RASTERIZATION_MODE_EXT = 1000455020,
        LINE_STIPPLE_ENABLE_EXT = 1000455021,
        DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 1000455022,
        VIEWPORT_W_SCALING_ENABLE_NV = 1000455023,
        VIEWPORT_SWIZZLE_NV = 1000455024,
        COVERAGE_TO_COLOR_ENABLE_NV = 1000455025,
        COVERAGE_TO_COLOR_LOCATION_NV = 1000455026,
        COVERAGE_MODULATION_MODE_NV = 1000455027,
        COVERAGE_MODULATION_TABLE_ENABLE_NV = 1000455028,
        COVERAGE_MODULATION_TABLE_NV = 1000455029,
        SHADING_RATE_IMAGE_ENABLE_NV = 1000455030,
        REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031,
        COVERAGE_REDUCTION_MODE_NV = 1000455032,
        CULL_MODE_EXT = 1000267000,
        FRONT_FACE_EXT = 1000267001,
        PRIMITIVE_TOPOLOGY_EXT = 1000267002,
        VIEWPORT_WITH_COUNT_EXT = 1000267003,
        SCISSOR_WITH_COUNT_EXT = 1000267004,
        VERTEX_INPUT_BINDING_STRIDE_EXT = 1000267005,
        DEPTH_TEST_ENABLE_EXT = 1000267006,
        DEPTH_WRITE_ENABLE_EXT = 1000267007,
        DEPTH_COMPARE_OP_EXT = 1000267008,
        DEPTH_BOUNDS_TEST_ENABLE_EXT = 1000267009,
        STENCIL_TEST_ENABLE_EXT = 1000267010,
        STENCIL_OP_EXT = 1000267011,
        RASTERIZER_DISCARD_ENABLE_EXT = 1000377001,
        DEPTH_BIAS_ENABLE_EXT = 1000377002,
        PRIMITIVE_RESTART_ENABLE_EXT = 1000377004,
    };
    bitmask FenceCreateFlagBits {
        SIGNALED_BIT = 1,
    };
    enum PolygonMode {
        FILL = 0,
        LINE = 1,
        POINT = 2,
        FILL_RECTANGLE_NV = 1000153000,
    };
    enum Format {
        UNDEFINED = 0,
        R4G4_UNORM_PACK8 = 1,
        R4G4B4A4_UNORM_PACK16 = 2,
        B4G4R4A4_UNORM_PACK16 = 3,
        R5G6B5_UNORM_PACK16 = 4,
        B5G6R5_UNORM_PACK16 = 5,
        R5G5B5A1_UNORM_PACK16 = 6,
        B5G5R5A1_UNORM_PACK16 = 7,
        A1R5G5B5_UNORM_PACK16 = 8,
        R8_UNORM = 9,
        R8_SNORM = 10,
        R8_USCALED = 11,
        R8_SSCALED = 12,
        R8_UINT = 13,
        R8_SINT = 14,
        R8_SRGB = 15,
        R8G8_UNORM = 16,
        R8G8_SNORM = 17,
        R8G8_USCALED = 18,
        R8G8_SSCALED = 19,
        R8G8_UINT = 20,
        R8G8_SINT = 21,
        R8G8_SRGB = 22,
        R8G8B8_UNORM = 23,
        R8G8B8_SNORM = 24,
        R8G8B8_USCALED = 25,
        R8G8B8_SSCALED = 26,
        R8G8B8_UINT = 27,
        R8G8B8_SINT = 28,
        R8G8B8_SRGB = 29,
        B8G8R8_UNORM = 30,
        B8G8R8_SNORM = 31,
        B8G8R8_USCALED = 32,
        B8G8R8_SSCALED = 33,
        B8G8R8_UINT = 34,
        B8G8R8_SINT = 35,
        B8G8R8_SRGB = 36,
        R8G8B8A8_UNORM = 37,
        R8G8B8A8_SNORM = 38,
        R8G8B8A8_USCALED = 39,
        R8G8B8A8_SSCALED = 40,
        R8G8B8A8_UINT = 41,
        R8G8B8A8_SINT = 42,
        R8G8B8A8_SRGB = 43,
        B8G8R8A8_UNORM = 44,
        B8G8R8A8_SNORM = 45,
        B8G8R8A8_USCALED = 46,
        B8G8R8A8_SSCALED = 47,
        B8G8R8A8_UINT = 48,
        B8G8R8A8_SINT = 49,
        B8G8R8A8_SRGB = 50,
        A8B8G8R8_UNORM_PACK32 = 51,
        A8B8G8R8_SNORM_PACK32 = 52,
        A8B8G8R8_USCALED_PACK32 = 53,
        A8B8G8R8_SSCALED_PACK32 = 54,
        A8B8G8R8_UINT_PACK32 = 55,
        A8B8G8R8_SINT_PACK32 = 56,
        A8B8G8R8_SRGB_PACK32 = 57,
        A2R10G10B10_UNORM_PACK32 = 58,
        A2R10G10B10_SNORM_PACK32 = 59,
        A2R10G10B10_USCALED_PACK32 = 60,
        A2R10G10B10_SSCALED_PACK32 = 61,
        A2R10G10B10_UINT_PACK32 = 62,
        A2R10G10B10_SINT_PACK32 = 63,
        A2B10G10R10_UNORM_PACK32 = 64,
        A2B10G10R10_SNORM_PACK32 = 65,
        A2B10G10R10_USCALED_PACK32 = 66,
        A2B10G10R10_SSCALED_PACK32 = 67,
        A2B10G10R10_UINT_PACK32 = 68,
        A2B10G10R10_SINT_PACK32 = 69,
        R16_UNORM = 70,
        R16_SNORM = 71,
        R16_USCALED = 72,
        R16_SSCALED = 73,
        R16_UINT = 74,
        R16_SINT = 75,
        R16_SFLOAT = 76,
        R16G16_UNORM = 77,
        R16G16_SNORM = 78,
        R16G16_USCALED = 79,
        R16G16_SSCALED = 80,
        R16G16_UINT = 81,
        R16G16_SINT = 82,
        R16G16_SFLOAT = 83,
        R16G16B16_UNORM = 84,
        R16G16B16_SNORM = 85,
        R16G16B16_USCALED = 86,
        R16G16B16_SSCALED = 87,
        R16G16B16_UINT = 88,
        R16G16B16_SINT = 89,
        R16G16B16_SFLOAT = 90,
        R16G16B16A16_UNORM = 91,
        R16G16B16A16_SNORM = 92,
        R16G16B16A16_USCALED = 93,
        R16G16B16A16_SSCALED = 94,
        R16G16B16A16_UINT = 95,
        R16G16B16A16_SINT = 96,
        R16G16B16A16_SFLOAT = 97,
        R32_UINT = 98,
        R32_SINT = 99,
        R32_SFLOAT = 100,
        R32G32_UINT = 101,
        R32G32_SINT = 102,
        R32G32_SFLOAT = 103,
        R32G32B32_UINT = 104,
        R32G32B32_SINT = 105,
        R32G32B32_SFLOAT = 106,
        R32G32B32A32_UINT = 107,
        R32G32B32A32_SINT = 108,
        R32G32B32A32_SFLOAT = 109,
        R64_UINT = 110,
        R64_SINT = 111,
        R64_SFLOAT = 112,
        R64G64_UINT = 113,
        R64G64_SINT = 114,
        R64G64_SFLOAT = 115,
        R64G64B64_UINT = 116,
        R64G64B64_SINT = 117,
        R64G64B64_SFLOAT = 118,
        R64G64B64A64_UINT = 119,
        R64G64B64A64_SINT = 120,
        R64G64B64A64_SFLOAT = 121,
        B10G11R11_UFLOAT_PACK32 = 122,
        E5B9G9R9_UFLOAT_PACK32 = 123,
        D16_UNORM = 124,
        X8_D24_UNORM_PACK32 = 125,
        D32_SFLOAT = 126,
        S8_UINT = 127,
        D16_UNORM_S8_UINT = 128,
        D24_UNORM_S8_UINT = 129,
        D32_SFLOAT_S8_UINT = 130,
        BC1_RGB_UNORM_BLOCK = 131,
        BC1_RGB_SRGB_BLOCK = 132,
        BC1_RGBA_UNORM_BLOCK = 133,
        BC1_RGBA_SRGB_BLOCK = 134,
        BC2_UNORM_BLOCK = 135,
        BC2_SRGB_BLOCK = 136,
        BC3_UNORM_BLOCK = 137,
        BC3_SRGB_BLOCK = 138,
        BC4_UNORM_BLOCK = 139,
        BC4_SNORM_BLOCK = 140,
        BC5_UNORM_BLOCK = 141,
        BC5_SNORM_BLOCK = 142,
        BC6H_UFLOAT_BLOCK = 143,
        BC6H_SFLOAT_BLOCK = 144,
        BC7_UNORM_BLOCK = 145,
        BC7_SRGB_BLOCK = 146,
        ETC2_R8G8B8_UNORM_BLOCK = 147,
        ETC2_R8G8B8_SRGB_BLOCK = 148,
        ETC2_R8G8B8A1_UNORM_BLOCK = 149,
        ETC2_R8G8B8A1_SRGB_BLOCK = 150,
        ETC2_R8G8B8A8_UNORM_BLOCK = 151,
        ETC2_R8G8B8A8_SRGB_BLOCK = 152,
        EAC_R11_UNORM_BLOCK = 153,
        EAC_R11_SNORM_BLOCK = 154,
        EAC_R11G11_UNORM_BLOCK = 155,
        EAC_R11G11_SNORM_BLOCK = 156,
        ASTC_4x4_UNORM_BLOCK = 157,
        ASTC_4x4_SRGB_BLOCK = 158,
        ASTC_5x4_UNORM_BLOCK = 159,
        ASTC_5x4_SRGB_BLOCK = 160,
        ASTC_5x5_UNORM_BLOCK = 161,
        ASTC_5x5_SRGB_BLOCK = 162,
        ASTC_6x5_UNORM_BLOCK = 163,
        ASTC_6x5_SRGB_BLOCK = 164,
        ASTC_6x6_UNORM_BLOCK = 165,
        ASTC_6x6_SRGB_BLOCK = 166,
        ASTC_8x5_UNORM_BLOCK = 167,
        ASTC_8x5_SRGB_BLOCK = 168,
        ASTC_8x6_UNORM_BLOCK = 169,
        ASTC_8x6_SRGB_BLOCK = 170,
        ASTC_8x8_UNORM_BLOCK = 171,
        ASTC_8x8_SRGB_BLOCK = 172,
        ASTC_10x5_UNORM_BLOCK = 173,
        ASTC_10x5_SRGB_BLOCK = 174,
        ASTC_10x6_UNORM_BLOCK = 175,
        ASTC_10x6_SRGB_BLOCK = 176,
        ASTC_10x8_UNORM_BLOCK = 177,
        ASTC_10x8_SRGB_BLOCK = 178,
        ASTC_10x10_UNORM_BLOCK = 179,
        ASTC_10x10_SRGB_BLOCK = 180,
        ASTC_12x10_UNORM_BLOCK = 181,
        ASTC_12x10_SRGB_BLOCK = 182,
        ASTC_12x12_UNORM_BLOCK = 183,
        ASTC_12x12_SRGB_BLOCK = 184,
        G8B8G8R8_422_UNORM = 1000156000,
        B8G8R8G8_422_UNORM = 1000156001,
        G8_B8_R8_3PLANE_420_UNORM = 1000156002,
        G8_B8R8_2PLANE_420_UNORM = 1000156003,
        G8_B8_R8_3PLANE_422_UNORM = 1000156004,
        G8_B8R8_2PLANE_422_UNORM = 1000156005,
        G8_B8_R8_3PLANE_444_UNORM = 1000156006,
        R10X6_UNORM_PACK16 = 1000156007,
        R10X6G10X6_UNORM_2PACK16 = 1000156008,
        R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
        G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
        B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
        G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
        G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
        G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
        G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
        G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
        R12X4_UNORM_PACK16 = 1000156017,
        R12X4G12X4_UNORM_2PACK16 = 1000156018,
        R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
        G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
        B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
        G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
        G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
        G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
        G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
        G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
        G16B16G16R16_422_UNORM = 1000156027,
        B16G16R16G16_422_UNORM = 1000156028,
        G16_B16_R16_3PLANE_420_UNORM = 1000156029,
        G16_B16R16_2PLANE_420_UNORM = 1000156030,
        G16_B16_R16_3PLANE_422_UNORM = 1000156031,
        G16_B16R16_2PLANE_422_UNORM = 1000156032,
        G16_B16_R16_3PLANE_444_UNORM = 1000156033,
        G8_B8R8_2PLANE_444_UNORM = 1000330000,
        G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
        G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
        G16_B16R16_2PLANE_444_UNORM = 1000330003,
        A4R4G4B4_UNORM_PACK16 = 1000340000,
        A4B4G4R4_UNORM_PACK16 = 1000340001,
        ASTC_4x4_SFLOAT_BLOCK = 1000066000,
        ASTC_5x4_SFLOAT_BLOCK = 1000066001,
        ASTC_5x5_SFLOAT_BLOCK = 1000066002,
        ASTC_6x5_SFLOAT_BLOCK = 1000066003,
        ASTC_6x6_SFLOAT_BLOCK = 1000066004,
        ASTC_8x5_SFLOAT_BLOCK = 1000066005,
        ASTC_8x6_SFLOAT_BLOCK = 1000066006,
        ASTC_8x8_SFLOAT_BLOCK = 1000066007,
        ASTC_10x5_SFLOAT_BLOCK = 1000066008,
        ASTC_10x6_SFLOAT_BLOCK = 1000066009,
        ASTC_10x8_SFLOAT_BLOCK = 1000066010,
        ASTC_10x10_SFLOAT_BLOCK = 1000066011,
        ASTC_12x10_SFLOAT_BLOCK = 1000066012,
        ASTC_12x12_SFLOAT_BLOCK = 1000066013,
        PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
        PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
        PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
        PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
        PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
        PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
        PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
        PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
        ASTC_3x3x3_UNORM_BLOCK_EXT = 1000288000,
        ASTC_3x3x3_SRGB_BLOCK_EXT = 1000288001,
        ASTC_3x3x3_SFLOAT_BLOCK_EXT = 1000288002,
        ASTC_4x3x3_UNORM_BLOCK_EXT = 1000288003,
        ASTC_4x3x3_SRGB_BLOCK_EXT = 1000288004,
        ASTC_4x3x3_SFLOAT_BLOCK_EXT = 1000288005,
        ASTC_4x4x3_UNORM_BLOCK_EXT = 1000288006,
        ASTC_4x4x3_SRGB_BLOCK_EXT = 1000288007,
        ASTC_4x4x3_SFLOAT_BLOCK_EXT = 1000288008,
        ASTC_4x4x4_UNORM_BLOCK_EXT = 1000288009,
        ASTC_4x4x4_SRGB_BLOCK_EXT = 1000288010,
        ASTC_4x4x4_SFLOAT_BLOCK_EXT = 1000288011,
        ASTC_5x4x4_UNORM_BLOCK_EXT = 1000288012,
        ASTC_5x4x4_SRGB_BLOCK_EXT = 1000288013,
        ASTC_5x4x4_SFLOAT_BLOCK_EXT = 1000288014,
        ASTC_5x5x4_UNORM_BLOCK_EXT = 1000288015,
        ASTC_5x5x4_SRGB_BLOCK_EXT = 1000288016,
        ASTC_5x5x4_SFLOAT_BLOCK_EXT = 1000288017,
        ASTC_5x5x5_UNORM_BLOCK_EXT = 1000288018,
        ASTC_5x5x5_SRGB_BLOCK_EXT = 1000288019,
        ASTC_5x5x5_SFLOAT_BLOCK_EXT = 1000288020,
        ASTC_6x5x5_UNORM_BLOCK_EXT = 1000288021,
        ASTC_6x5x5_SRGB_BLOCK_EXT = 1000288022,
        ASTC_6x5x5_SFLOAT_BLOCK_EXT = 1000288023,
        ASTC_6x6x5_UNORM_BLOCK_EXT = 1000288024,
        ASTC_6x6x5_SRGB_BLOCK_EXT = 1000288025,
        ASTC_6x6x5_SFLOAT_BLOCK_EXT = 1000288026,
        ASTC_6x6x6_UNORM_BLOCK_EXT = 1000288027,
        ASTC_6x6x6_SRGB_BLOCK_EXT = 1000288028,
        ASTC_6x6x6_SFLOAT_BLOCK_EXT = 1000288029,
        R16G16_S10_5_NV = 1000464000,
        ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000,
        ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001,
        ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002,
        ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003,
        ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004,
        ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005,
        ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006,
        ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007,
        ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008,
        ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009,
        ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010,
        ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011,
        ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012,
        ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013,
        G8B8G8R8_422_UNORM_KHR = 1000156000,
        B8G8R8G8_422_UNORM_KHR = 1000156001,
        G8_B8_R8_3PLANE_420_UNORM_KHR = 1000156002,
        G8_B8R8_2PLANE_420_UNORM_KHR = 1000156003,
        G8_B8_R8_3PLANE_422_UNORM_KHR = 1000156004,
        G8_B8R8_2PLANE_422_UNORM_KHR = 1000156005,
        G8_B8_R8_3PLANE_444_UNORM_KHR = 1000156006,
        R10X6_UNORM_PACK16_KHR = 1000156007,
        R10X6G10X6_UNORM_2PACK16_KHR = 1000156008,
        R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = 1000156009,
        G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = 1000156010,
        B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = 1000156011,
        G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = 1000156012,
        G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = 1000156013,
        G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = 1000156014,
        G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = 1000156015,
        G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = 1000156016,
        R12X4_UNORM_PACK16_KHR = 1000156017,
        R12X4G12X4_UNORM_2PACK16_KHR = 1000156018,
        R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = 1000156019,
        G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = 1000156020,
        B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = 1000156021,
        G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = 1000156022,
        G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = 1000156023,
        G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = 1000156024,
        G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = 1000156025,
        G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = 1000156026,
        G16B16G16R16_422_UNORM_KHR = 1000156027,
        B16G16R16G16_422_UNORM_KHR = 1000156028,
        G16_B16_R16_3PLANE_420_UNORM_KHR = 1000156029,
        G16_B16R16_2PLANE_420_UNORM_KHR = 1000156030,
        G16_B16_R16_3PLANE_422_UNORM_KHR = 1000156031,
        G16_B16R16_2PLANE_422_UNORM_KHR = 1000156032,
        G16_B16_R16_3PLANE_444_UNORM_KHR = 1000156033,
        G8_B8R8_2PLANE_444_UNORM_EXT = 1000330000,
        G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = 1000330001,
        G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = 1000330002,
        G16_B16R16_2PLANE_444_UNORM_EXT = 1000330003,
        A4R4G4B4_UNORM_PACK16_EXT = 1000340000,
        A4B4G4R4_UNORM_PACK16_EXT = 1000340001,
    };
    bitmask FormatFeatureFlagBits {
        SAMPLED_IMAGE_BIT = 1,
        STORAGE_IMAGE_BIT = 2,
        STORAGE_IMAGE_ATOMIC_BIT = 4,
        UNIFORM_TEXEL_BUFFER_BIT = 8,
        STORAGE_TEXEL_BUFFER_BIT = 16,
        STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 32,
        VERTEX_BUFFER_BIT = 64,
        COLOR_ATTACHMENT_BIT = 128,
        COLOR_ATTACHMENT_BLEND_BIT = 256,
        DEPTH_STENCIL_ATTACHMENT_BIT = 512,
        BLIT_SRC_BIT = 1024,
        BLIT_DST_BIT = 2048,
        SAMPLED_IMAGE_FILTER_LINEAR_BIT = 4096,
        TRANSFER_SRC_BIT = 16384,
        TRANSFER_DST_BIT = 32768,
        MIDPOINT_CHROMA_SAMPLES_BIT = 131072,
        SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 262144,
        SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 524288,
        SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 1048576,
        SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 2097152,
        DISJOINT_BIT = 4194304,
        COSITED_CHROMA_SAMPLES_BIT = 8388608,
        SAMPLED_IMAGE_FILTER_MINMAX_BIT = 65536,
        VIDEO_DECODE_OUTPUT_BIT_KHR = 33554432,
        VIDEO_DECODE_DPB_BIT_KHR = 67108864,
        ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 536870912,
        SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 8192,
        FRAGMENT_DENSITY_MAP_BIT_EXT = 16777216,
        FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1073741824,
        VIDEO_ENCODE_INPUT_BIT_KHR = 134217728,
        VIDEO_ENCODE_DPB_BIT_KHR = 268435456,
        SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 8192,
        TRANSFER_SRC_BIT_KHR = 16384,
        TRANSFER_DST_BIT_KHR = 32768,
        SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = 65536,
        MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 131072,
        SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 262144,
        SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 524288,
        SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 1048576,
        SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 2097152,
        DISJOINT_BIT_KHR = 4194304,
        COSITED_CHROMA_SAMPLES_BIT_KHR = 8388608,
    };
    enum FrontFace {
        COUNTER_CLOCKWISE = 0,
        CLOCKWISE = 1,
    };
    bitmask ImageAspectFlagBits {
        COLOR_BIT = 1,
        DEPTH_BIT = 2,
        STENCIL_BIT = 4,
        METADATA_BIT = 8,
        PLANE_0_BIT = 16,
        PLANE_1_BIT = 32,
        PLANE_2_BIT = 64,
        NONE = 0,
        MEMORY_PLANE_0_BIT_EXT = 128,
        MEMORY_PLANE_1_BIT_EXT = 256,
        MEMORY_PLANE_2_BIT_EXT = 512,
        MEMORY_PLANE_3_BIT_EXT = 1024,
        PLANE_0_BIT_KHR = 16,
        PLANE_1_BIT_KHR = 32,
        PLANE_2_BIT_KHR = 64,
        NONE_KHR = 0,
    };
    bitmask ImageCreateFlagBits {
        SPARSE_BINDING_BIT = 1,
        SPARSE_RESIDENCY_BIT = 2,
        SPARSE_ALIASED_BIT = 4,
        MUTABLE_FORMAT_BIT = 8,
        CUBE_COMPATIBLE_BIT = 16,
        ALIAS_BIT = 1024,
        SPLIT_INSTANCE_BIND_REGIONS_BIT = 64,
        _2D_ARRAY_COMPATIBLE_BIT = 32,
        BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 128,
        EXTENDED_USAGE_BIT = 256,
        PROTECTED_BIT = 2048,
        DISJOINT_BIT = 512,
        CORNER_SAMPLED_BIT_NV = 8192,
        SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 4096,
        SUBSAMPLED_BIT_EXT = 16384,
        RESERVED_19_BIT_EXT = 524288,
        RESERVED_16_BIT_AMD = 65536,
        MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = 262144,
        _2D_VIEW_COMPATIBLE_BIT_EXT = 131072,
        FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = 32768,
        SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 64,
        _2D_ARRAY_COMPATIBLE_BIT_KHR = 32,
        BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = 128,
        EXTENDED_USAGE_BIT_KHR = 256,
        DISJOINT_BIT_KHR = 512,
        ALIAS_BIT_KHR = 1024,
    };
    enum ImageLayout {
        UNDEFINED = 0,
        GENERAL = 1,
        COLOR_ATTACHMENT_OPTIMAL = 2,
        DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
        DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
        SHADER_READ_ONLY_OPTIMAL = 5,
        TRANSFER_SRC_OPTIMAL = 6,
        TRANSFER_DST_OPTIMAL = 7,
        PREINITIALIZED = 8,
        DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
        DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
        DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
        DEPTH_READ_ONLY_OPTIMAL = 1000241001,
        STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
        STENCIL_READ_ONLY_OPTIMAL = 1000241003,
        READ_ONLY_OPTIMAL = 1000314000,
        ATTACHMENT_OPTIMAL = 1000314001,
        PRESENT_SRC_KHR = 1000001002,
        VIDEO_DECODE_DST_KHR = 1000024000,
        VIDEO_DECODE_SRC_KHR = 1000024001,
        VIDEO_DECODE_DPB_KHR = 1000024002,
        SHARED_PRESENT_KHR = 1000111000,
        FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
        FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
        VIDEO_ENCODE_DST_KHR = 1000299000,
        VIDEO_ENCODE_SRC_KHR = 1000299001,
        VIDEO_ENCODE_DPB_KHR = 1000299002,
        ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000,
        DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000117000,
        DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000117001,
        SHADING_RATE_OPTIMAL_NV = 1000164003,
        DEPTH_ATTACHMENT_OPTIMAL_KHR = 1000241000,
        DEPTH_READ_ONLY_OPTIMAL_KHR = 1000241001,
        STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000241002,
        STENCIL_READ_ONLY_OPTIMAL_KHR = 1000241003,
        READ_ONLY_OPTIMAL_KHR = 1000314000,
        ATTACHMENT_OPTIMAL_KHR = 1000314001,
    };
    enum ImageTiling {
        OPTIMAL = 0,
        LINEAR = 1,
        DRM_FORMAT_MODIFIER_EXT = 1000158000,
    };
    enum ImageType {
        _1D = 0,
        _2D = 1,
        _3D = 2,
    };
    bitmask ImageUsageFlagBits {
        TRANSFER_SRC_BIT = 1,
        TRANSFER_DST_BIT = 2,
        SAMPLED_BIT = 4,
        STORAGE_BIT = 8,
        COLOR_ATTACHMENT_BIT = 16,
        DEPTH_STENCIL_ATTACHMENT_BIT = 32,
        TRANSIENT_ATTACHMENT_BIT = 64,
        INPUT_ATTACHMENT_BIT = 128,
        VIDEO_DECODE_DST_BIT_KHR = 1024,
        VIDEO_DECODE_SRC_BIT_KHR = 2048,
        VIDEO_DECODE_DPB_BIT_KHR = 4096,
        RESERVED_16_BIT_QCOM = 65536,
        RESERVED_17_BIT_QCOM = 131072,
        FRAGMENT_DENSITY_MAP_BIT_EXT = 512,
        FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 256,
        RESERVED_22_BIT_EXT = 4194304,
        VIDEO_ENCODE_DST_BIT_KHR = 8192,
        VIDEO_ENCODE_SRC_BIT_KHR = 16384,
        VIDEO_ENCODE_DPB_BIT_KHR = 32768,
        ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 524288,
        INVOCATION_MASK_BIT_HUAWEI = 262144,
        SAMPLE_WEIGHT_BIT_QCOM = 1048576,
        SAMPLE_BLOCK_MATCH_BIT_QCOM = 2097152,
        SHADING_RATE_IMAGE_BIT_NV = 256,
    };
    bitmask ImageViewCreateFlagBits {
        FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 1,
        RESERVED_2_BIT_AMD = 4,
        FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 2,
        RESERVED_3_BIT_EXT = 8,
    };
    enum ImageViewType {
        _1D = 0,
        _2D = 1,
        _3D = 2,
        CUBE = 3,
        _1D_ARRAY = 4,
        _2D_ARRAY = 5,
        CUBE_ARRAY = 6,
    };
    enum SharingMode {
        EXCLUSIVE = 0,
        CONCURRENT = 1,
    };
    enum IndexType {
        UINT16 = 0,
        UINT32 = 1,
        NONE_KHR = 1000165000,
        UINT8_EXT = 1000265000,
        NONE_NV = 1000165000,
    };
    enum LogicOp {
        CLEAR = 0,
        AND = 1,
        AND_REVERSE = 2,
        COPY = 3,
        AND_INVERTED = 4,
        NO_OP = 5,
        XOR = 6,
        OR = 7,
        NOR = 8,
        EQUIVALENT = 9,
        INVERT = 10,
        OR_REVERSE = 11,
        COPY_INVERTED = 12,
        OR_INVERTED = 13,
        NAND = 14,
        SET = 15,
    };
    bitmask MemoryHeapFlagBits {
        DEVICE_LOCAL_BIT = 1,
        MULTI_INSTANCE_BIT = 2,
        RESERVED_2_BIT_KHR = 4,
        MULTI_INSTANCE_BIT_KHR = 2,
    };
    bitmask AccessFlagBits {
        INDIRECT_COMMAND_READ_BIT = 1,
        INDEX_READ_BIT = 2,
        VERTEX_ATTRIBUTE_READ_BIT = 4,
        UNIFORM_READ_BIT = 8,
        INPUT_ATTACHMENT_READ_BIT = 16,
        SHADER_READ_BIT = 32,
        SHADER_WRITE_BIT = 64,
        COLOR_ATTACHMENT_READ_BIT = 128,
        COLOR_ATTACHMENT_WRITE_BIT = 256,
        DEPTH_STENCIL_ATTACHMENT_READ_BIT = 512,
        DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1024,
        TRANSFER_READ_BIT = 2048,
        TRANSFER_WRITE_BIT = 4096,
        HOST_READ_BIT = 8192,
        HOST_WRITE_BIT = 16384,
        MEMORY_READ_BIT = 32768,
        MEMORY_WRITE_BIT = 65536,
        NONE = 0,
        TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 33554432,
        TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 67108864,
        TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 134217728,
        CONDITIONAL_RENDERING_READ_BIT_EXT = 1048576,
        COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 524288,
        ACCELERATION_STRUCTURE_READ_BIT_KHR = 2097152,
        ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 4194304,
        FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 16777216,
        FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 8388608,
        COMMAND_PREPROCESS_READ_BIT_NV = 131072,
        COMMAND_PREPROCESS_WRITE_BIT_NV = 262144,
        SHADING_RATE_IMAGE_READ_BIT_NV = 8388608,
        ACCELERATION_STRUCTURE_READ_BIT_NV = 2097152,
        ACCELERATION_STRUCTURE_WRITE_BIT_NV = 4194304,
        NONE_KHR = 0,
    };
    bitmask MemoryPropertyFlagBits {
        DEVICE_LOCAL_BIT = 1,
        HOST_VISIBLE_BIT = 2,
        HOST_COHERENT_BIT = 4,
        HOST_CACHED_BIT = 8,
        LAZILY_ALLOCATED_BIT = 16,
        PROTECTED_BIT = 32,
        DEVICE_COHERENT_BIT_AMD = 64,
        DEVICE_UNCACHED_BIT_AMD = 128,
        RDMA_CAPABLE_BIT_NV = 256,
    };
    enum PhysicalDeviceType {
        OTHER = 0,
        INTEGRATED_GPU = 1,
        DISCRETE_GPU = 2,
        VIRTUAL_GPU = 3,
        CPU = 4,
    };
    enum PipelineBindPoint {
        GRAPHICS = 0,
        COMPUTE = 1,
        RAY_TRACING_KHR = 1000165000,
        SUBPASS_SHADING_HUAWEI = 1000369003,
        RAY_TRACING_NV = 1000165000,
    };
    bitmask PipelineCreateFlagBits {
        DISABLE_OPTIMIZATION_BIT = 1,
        ALLOW_DERIVATIVES_BIT = 2,
        DERIVATIVE_BIT = 4,
        VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 8,
        DISPATCH_BASE_BIT = 16,
        FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 256,
        EARLY_RETURN_ON_FAILURE_BIT = 512,
        RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 2097152,
        RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 4194304,
        RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 16384,
        RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 32768,
        RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 65536,
        RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 131072,
        RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 4096,
        RAY_TRACING_SKIP_AABBS_BIT_KHR = 8192,
        RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 524288,
        DEFER_COMPILE_BIT_NV = 32,
        CAPTURE_STATISTICS_BIT_KHR = 64,
        CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 128,
        INDIRECT_BINDABLE_BIT_NV = 262144,
        LIBRARY_BIT_KHR = 2048,
        RESERVED_29_AMD = 536870912,
        RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 8388608,
        LINK_TIME_OPTIMIZATION_BIT_EXT = 1024,
        RAY_TRACING_ALLOW_MOTION_BIT_NV = 1048576,
        COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 33554432,
        DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 67108864,
        RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 16777216,
        RESERVED_BIT_28_NV = 268435456,
        NO_PROTECTED_ACCESS_BIT_EXT = 134217728,
        PROTECTED_ACCESS_ONLY_BIT_EXT = 1073741824,
        DISPATCH_BASE = 16,
        PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 2097152,
        PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 4194304,
        VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 8,
        DISPATCH_BASE_KHR = 16,
        FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT = 256,
        EARLY_RETURN_ON_FAILURE_BIT_EXT = 512,
    };
    enum PrimitiveTopology {
        POINT_LIST = 0,
        LINE_LIST = 1,
        LINE_STRIP = 2,
        TRIANGLE_LIST = 3,
        TRIANGLE_STRIP = 4,
        TRIANGLE_FAN = 5,
        LINE_LIST_WITH_ADJACENCY = 6,
        LINE_STRIP_WITH_ADJACENCY = 7,
        TRIANGLE_LIST_WITH_ADJACENCY = 8,
        TRIANGLE_STRIP_WITH_ADJACENCY = 9,
        PATCH_LIST = 10,
    };
    bitmask QueryControlFlagBits {
        PRECISE_BIT = 1,
    };
    bitmask QueryPipelineStatisticFlagBits {
        INPUT_ASSEMBLY_VERTICES_BIT = 1,
        INPUT_ASSEMBLY_PRIMITIVES_BIT = 2,
        VERTEX_SHADER_INVOCATIONS_BIT = 4,
        GEOMETRY_SHADER_INVOCATIONS_BIT = 8,
        GEOMETRY_SHADER_PRIMITIVES_BIT = 16,
        CLIPPING_INVOCATIONS_BIT = 32,
        CLIPPING_PRIMITIVES_BIT = 64,
        FRAGMENT_SHADER_INVOCATIONS_BIT = 128,
        TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 256,
        TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 512,
        COMPUTE_SHADER_INVOCATIONS_BIT = 1024,
        TASK_SHADER_INVOCATIONS_BIT_EXT = 2048,
        MESH_SHADER_INVOCATIONS_BIT_EXT = 4096,
    };
    bitmask QueryResultFlagBits {
        _64_BIT = 1,
        WAIT_BIT = 2,
        WITH_AVAILABILITY_BIT = 4,
        PARTIAL_BIT = 8,
        WITH_STATUS_BIT_KHR = 16,
    };
    enum QueryType {
        OCCLUSION = 0,
        PIPELINE_STATISTICS = 1,
        TIMESTAMP = 2,
        RESULT_STATUS_ONLY_KHR = 1000023000,
        TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
        PERFORMANCE_QUERY_KHR = 1000116000,
        ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000,
        ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001,
        ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
        PERFORMANCE_QUERY_INTEL = 1000210000,
        VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR = 1000299000,
        MESH_PRIMITIVES_GENERATED_EXT = 1000328000,
        PRIMITIVES_GENERATED_EXT = 1000382000,
        ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 1000386000,
        ACCELERATION_STRUCTURE_SIZE_KHR = 1000386001,
        MICROMAP_SERIALIZATION_SIZE_EXT = 1000396000,
        MICROMAP_COMPACTED_SIZE_EXT = 1000396001,
    };
    bitmask QueueFlagBits {
        GRAPHICS_BIT = 1,
        COMPUTE_BIT = 2,
        TRANSFER_BIT = 4,
        SPARSE_BINDING_BIT = 8,
        PROTECTED_BIT = 16,
        VIDEO_DECODE_BIT_KHR = 32,
        RESERVED_9_BIT_EXT = 512,
        VIDEO_ENCODE_BIT_KHR = 64,
        RESERVED_7_BIT_QCOM = 128,
        OPTICAL_FLOW_BIT_NV = 256,
    };
    enum SubpassContents {
        INLINE = 0,
        SECONDARY_COMMAND_BUFFERS = 1,
    };
    enum Result {
        SUCCESS = 0,
        NOT_READY = 1,
        TIMEOUT = 2,
        EVENT_SET = 3,
        EVENT_RESET = 4,
        INCOMPLETE = 5,
        ERROR_OUT_OF_HOST_MEMORY = -1,
        ERROR_OUT_OF_DEVICE_MEMORY = -2,
        ERROR_INITIALIZATION_FAILED = -3,
        ERROR_DEVICE_LOST = -4,
        ERROR_MEMORY_MAP_FAILED = -5,
        ERROR_LAYER_NOT_PRESENT = -6,
        ERROR_EXTENSION_NOT_PRESENT = -7,
        ERROR_FEATURE_NOT_PRESENT = -8,
        ERROR_INCOMPATIBLE_DRIVER = -9,
        ERROR_TOO_MANY_OBJECTS = -10,
        ERROR_FORMAT_NOT_SUPPORTED = -11,
        ERROR_FRAGMENTED_POOL = -12,
        ERROR_UNKNOWN = -13,
        ERROR_OUT_OF_POOL_MEMORY = -1000069000,
        ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
        ERROR_FRAGMENTATION = -1000161000,
        ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
        PIPELINE_COMPILE_REQUIRED = 1000297000,
        ERROR_SURFACE_LOST_KHR = -1000000000,
        ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
        SUBOPTIMAL_KHR = 1000001003,
        ERROR_OUT_OF_DATE_KHR = -1000001004,
        ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
        ERROR_VALIDATION_FAILED_EXT = -1000011001,
        ERROR_INVALID_SHADER_NV = -1000012000,
        ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = -1000023000,
        ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = -1000023001,
        ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = -1000023002,
        ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = -1000023003,
        ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004,
        ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
        ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
        ERROR_NOT_PERMITTED_KHR = -1000174001,
        ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
        THREAD_IDLE_KHR = 1000268000,
        THREAD_DONE_KHR = 1000268001,
        OPERATION_DEFERRED_KHR = 1000268002,
        OPERATION_NOT_DEFERRED_KHR = 1000268003,
        ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
        ERROR_OUT_OF_POOL_MEMORY_KHR = -1000069000,
        ERROR_INVALID_EXTERNAL_HANDLE_KHR = -1000072003,
        ERROR_FRAGMENTATION_EXT = -1000161000,
        ERROR_NOT_PERMITTED_EXT = -1000174001,
        ERROR_INVALID_DEVICE_ADDRESS_EXT = -1000257000,
        ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = -1000257000,
        PIPELINE_COMPILE_REQUIRED_EXT = 1000297000,
        ERROR_PIPELINE_COMPILE_REQUIRED_EXT = 1000297000,
    };
    bitmask ShaderStageFlagBits {
        VERTEX_BIT = 1,
        TESSELLATION_CONTROL_BIT = 2,
        TESSELLATION_EVALUATION_BIT = 4,
        GEOMETRY_BIT = 8,
        FRAGMENT_BIT = 16,
        COMPUTE_BIT = 32,
        ALL_GRAPHICS = 31,
        ALL = 2147483647,
        RAYGEN_BIT_KHR = 256,
        ANY_HIT_BIT_KHR = 512,
        CLOSEST_HIT_BIT_KHR = 1024,
        MISS_BIT_KHR = 2048,
        INTERSECTION_BIT_KHR = 4096,
        CALLABLE_BIT_KHR = 8192,
        TASK_BIT_EXT = 64,
        MESH_BIT_EXT = 128,
        SUBPASS_SHADING_BIT_HUAWEI = 16384,
        EXT_483_RESERVE_15 = 32768,
        EXT_483_RESERVE_16 = 65536,
        EXT_483_RESERVE_17 = 131072,
        RAYGEN_BIT_NV = 256,
        ANY_HIT_BIT_NV = 512,
        CLOSEST_HIT_BIT_NV = 1024,
        MISS_BIT_NV = 2048,
        INTERSECTION_BIT_NV = 4096,
        CALLABLE_BIT_NV = 8192,
        TASK_BIT_NV = 64,
        MESH_BIT_NV = 128,
    };
    bitmask SparseMemoryBindFlagBits {
        METADATA_BIT = 1,
    };
    bitmask StencilFaceFlagBits {
        FRONT_BIT = 1,
        BACK_BIT = 2,
        FRONT_AND_BACK = 3,
        STENCIL_FRONT_AND_BACK = 3,
    };
    enum StencilOp {
        KEEP = 0,
        ZERO = 1,
        REPLACE = 2,
        INCREMENT_AND_CLAMP = 3,
        DECREMENT_AND_CLAMP = 4,
        INVERT = 5,
        INCREMENT_AND_WRAP = 6,
        DECREMENT_AND_WRAP = 7,
    };
    enum StructureType {
        APPLICATION_INFO = 0,
        INSTANCE_CREATE_INFO = 1,
        DEVICE_QUEUE_CREATE_INFO = 2,
        DEVICE_CREATE_INFO = 3,
        SUBMIT_INFO = 4,
        MEMORY_ALLOCATE_INFO = 5,
        MAPPED_MEMORY_RANGE = 6,
        BIND_SPARSE_INFO = 7,
        FENCE_CREATE_INFO = 8,
        SEMAPHORE_CREATE_INFO = 9,
        EVENT_CREATE_INFO = 10,
        QUERY_POOL_CREATE_INFO = 11,
        BUFFER_CREATE_INFO = 12,
        BUFFER_VIEW_CREATE_INFO = 13,
        IMAGE_CREATE_INFO = 14,
        IMAGE_VIEW_CREATE_INFO = 15,
        SHADER_MODULE_CREATE_INFO = 16,
        PIPELINE_CACHE_CREATE_INFO = 17,
        PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
        PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
        PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
        PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
        PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
        PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
        PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
        PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
        PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
        PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
        GRAPHICS_PIPELINE_CREATE_INFO = 28,
        COMPUTE_PIPELINE_CREATE_INFO = 29,
        PIPELINE_LAYOUT_CREATE_INFO = 30,
        SAMPLER_CREATE_INFO = 31,
        DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
        DESCRIPTOR_POOL_CREATE_INFO = 33,
        DESCRIPTOR_SET_ALLOCATE_INFO = 34,
        WRITE_DESCRIPTOR_SET = 35,
        COPY_DESCRIPTOR_SET = 36,
        FRAMEBUFFER_CREATE_INFO = 37,
        RENDER_PASS_CREATE_INFO = 38,
        COMMAND_POOL_CREATE_INFO = 39,
        COMMAND_BUFFER_ALLOCATE_INFO = 40,
        COMMAND_BUFFER_INHERITANCE_INFO = 41,
        COMMAND_BUFFER_BEGIN_INFO = 42,
        RENDER_PASS_BEGIN_INFO = 43,
        BUFFER_MEMORY_BARRIER = 44,
        IMAGE_MEMORY_BARRIER = 45,
        MEMORY_BARRIER = 46,
        LOADER_INSTANCE_CREATE_INFO = 47,
        LOADER_DEVICE_CREATE_INFO = 48,
        PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
        BIND_BUFFER_MEMORY_INFO = 1000157000,
        BIND_IMAGE_MEMORY_INFO = 1000157001,
        PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
        MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
        MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
        MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
        DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
        DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
        DEVICE_GROUP_SUBMIT_INFO = 1000060005,
        DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
        BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
        BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
        PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
        DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
        BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
        IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
        IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
        MEMORY_REQUIREMENTS_2 = 1000146003,
        SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
        PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
        PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
        FORMAT_PROPERTIES_2 = 1000059002,
        IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
        PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
        QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
        PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
        SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
        PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
        PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
        RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
        IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
        PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
        RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
        PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
        PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
        PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
        PROTECTED_SUBMIT_INFO = 1000145000,
        PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
        PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
        DEVICE_QUEUE_INFO_2 = 1000145003,
        SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
        SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
        BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
        IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
        PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
        SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
        DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
        PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
        EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
        PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
        EXTERNAL_BUFFER_PROPERTIES = 1000071003,
        PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
        EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
        EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
        EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
        PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
        EXTERNAL_FENCE_PROPERTIES = 1000112001,
        EXPORT_FENCE_CREATE_INFO = 1000113000,
        EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
        PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
        EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
        PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
        DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
        PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
        PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
        PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
        PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
        PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
        IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
        ATTACHMENT_DESCRIPTION_2 = 1000109000,
        ATTACHMENT_REFERENCE_2 = 1000109001,
        SUBPASS_DESCRIPTION_2 = 1000109002,
        SUBPASS_DEPENDENCY_2 = 1000109003,
        RENDER_PASS_CREATE_INFO_2 = 1000109004,
        SUBPASS_BEGIN_INFO = 1000109005,
        SUBPASS_END_INFO = 1000109006,
        PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
        PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
        PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
        PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
        PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
        DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
        PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
        PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
        DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
        DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
        PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
        SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
        PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
        IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
        PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
        SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
        PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
        PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
        FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
        FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
        RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
        PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
        PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
        PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
        ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
        ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
        PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
        PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
        PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
        SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
        TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
        SEMAPHORE_WAIT_INFO = 1000207004,
        SEMAPHORE_SIGNAL_INFO = 1000207005,
        PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
        BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
        BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
        MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
        DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
        PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 53,
        PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 54,
        PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000,
        PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000,
        PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000,
        PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000,
        PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000,
        DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001,
        PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002,
        PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000,
        MEMORY_BARRIER_2 = 1000314000,
        BUFFER_MEMORY_BARRIER_2 = 1000314001,
        IMAGE_MEMORY_BARRIER_2 = 1000314002,
        DEPENDENCY_INFO = 1000314003,
        SUBMIT_INFO_2 = 1000314004,
        SEMAPHORE_SUBMIT_INFO = 1000314005,
        COMMAND_BUFFER_SUBMIT_INFO = 1000314006,
        PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007,
        PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000,
        PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000,
        COPY_BUFFER_INFO_2 = 1000337000,
        COPY_IMAGE_INFO_2 = 1000337001,
        COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002,
        COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003,
        BLIT_IMAGE_INFO_2 = 1000337004,
        RESOLVE_IMAGE_INFO_2 = 1000337005,
        BUFFER_COPY_2 = 1000337006,
        IMAGE_COPY_2 = 1000337007,
        IMAGE_BLIT_2 = 1000337008,
        BUFFER_IMAGE_COPY_2 = 1000337009,
        IMAGE_RESOLVE_2 = 1000337010,
        PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000,
        PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001,
        PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002,
        PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
        PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
        WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
        DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003,
        PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000,
        RENDERING_INFO = 1000044000,
        RENDERING_ATTACHMENT_INFO = 1000044001,
        PIPELINE_RENDERING_CREATE_INFO = 1000044002,
        PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003,
        COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004,
        PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000,
        PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001,
        PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001,
        FORMAT_PROPERTIES_3 = 1000360000,
        PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000,
        PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
        DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
        DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
        SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
        PRESENT_INFO_KHR = 1000001001,
        DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
        IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
        BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
        ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
        DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
        DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
        DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
        DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
        DISPLAY_PRESENT_INFO_KHR = 1000003000,
        XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
        XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
        WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
        ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
        WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
        NATIVE_BUFFER_ANDROID = 1000010000,
        SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID = 1000010001,
        PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID = 1000010002,
        DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
        PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
        DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
        DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
        DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
        VIDEO_PROFILE_INFO_KHR = 1000023000,
        VIDEO_CAPABILITIES_KHR = 1000023001,
        VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002,
        VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003,
        BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004,
        VIDEO_SESSION_CREATE_INFO_KHR = 1000023005,
        VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006,
        VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007,
        VIDEO_BEGIN_CODING_INFO_KHR = 1000023008,
        VIDEO_END_CODING_INFO_KHR = 1000023009,
        VIDEO_CODING_CONTROL_INFO_KHR = 1000023010,
        VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011,
        QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012,
        VIDEO_PROFILE_LIST_INFO_KHR = 1000023013,
        PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014,
        VIDEO_FORMAT_PROPERTIES_KHR = 1000023015,
        QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016,
        VIDEO_DECODE_INFO_KHR = 1000024000,
        VIDEO_DECODE_CAPABILITIES_KHR = 1000024001,
        VIDEO_DECODE_USAGE_INFO_KHR = 1000024002,
        DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
        DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
        DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
        PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
        PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
        PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
        CU_MODULE_CREATE_INFO_NVX = 1000029000,
        CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
        CU_LAUNCH_INFO_NVX = 1000029002,
        IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
        IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
        VIDEO_ENCODE_H264_CAPABILITIES_EXT = 1000038000,
        VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000038001,
        VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT = 1000038002,
        VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT = 1000038003,
        VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT = 1000038004,
        VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT = 1000038005,
        VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_INFO_EXT = 1000038006,
        VIDEO_ENCODE_H264_PROFILE_INFO_EXT = 1000038007,
        VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT = 1000038008,
        VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT = 1000038009,
        VIDEO_ENCODE_H264_REFERENCE_LISTS_INFO_EXT = 1000038010,
        VIDEO_ENCODE_H265_CAPABILITIES_EXT = 1000039000,
        VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000039001,
        VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT = 1000039002,
        VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT = 1000039003,
        VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT = 1000039004,
        VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT = 1000039005,
        VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_INFO_EXT = 1000039006,
        VIDEO_ENCODE_H265_PROFILE_INFO_EXT = 1000039007,
        VIDEO_ENCODE_H265_REFERENCE_LISTS_INFO_EXT = 1000039008,
        VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT = 1000039009,
        VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT = 1000039010,
        VIDEO_DECODE_H264_CAPABILITIES_EXT = 1000040000,
        VIDEO_DECODE_H264_PICTURE_INFO_EXT = 1000040001,
        VIDEO_DECODE_H264_PROFILE_INFO_EXT = 1000040003,
        VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000040004,
        VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT = 1000040005,
        VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT = 1000040006,
        TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
        RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
        RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
        ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
        MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
        STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
        PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
        EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
        EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
        IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
        EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
        WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
        VALIDATION_FLAGS_EXT = 1000061000,
        VI_SURFACE_CREATE_INFO_NN = 1000062000,
        IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
        PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
        PIPELINE_ROBUSTNESS_CREATE_INFO_EXT = 1000068000,
        PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT = 1000068001,
        PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT = 1000068002,
        IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
        EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
        MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
        MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
        IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
        MEMORY_FD_PROPERTIES_KHR = 1000074001,
        MEMORY_GET_FD_INFO_KHR = 1000074002,
        WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
        IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
        EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
        D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
        SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
        IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
        SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
        PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
        COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
        PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
        CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
        PRESENT_REGIONS_KHR = 1000084000,
        PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
        SURFACE_CAPABILITIES_2_EXT = 1000090000,
        DISPLAY_POWER_INFO_EXT = 1000091000,
        DEVICE_EVENT_INFO_EXT = 1000091001,
        DISPLAY_EVENT_INFO_EXT = 1000091002,
        SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
        PRESENT_TIMES_INFO_GOOGLE = 1000092000,
        PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
        PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
        PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
        PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
        PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
        PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
        PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
        PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
        HDR_METADATA_EXT = 1000105000,
        SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
        IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
        EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
        FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
        IMPORT_FENCE_FD_INFO_KHR = 1000115000,
        FENCE_GET_FD_INFO_KHR = 1000115001,
        PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
        PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
        QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
        PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
        ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
        PERFORMANCE_COUNTER_KHR = 1000116005,
        PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
        PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
        SURFACE_CAPABILITIES_2_KHR = 1000119001,
        SURFACE_FORMAT_2_KHR = 1000119002,
        DISPLAY_PROPERTIES_2_KHR = 1000121000,
        DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
        DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
        DISPLAY_PLANE_INFO_2_KHR = 1000121003,
        DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
        IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
        MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
        DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
        DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
        DEBUG_UTILS_LABEL_EXT = 1000128002,
        DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
        DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
        ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
        ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
        ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
        IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
        MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
        EXTERNAL_FORMAT_ANDROID = 1000129005,
        ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006,
        SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
        RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
        PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
        PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
        MULTISAMPLE_PROPERTIES_EXT = 1000143004,
        PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
        PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
        PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
        PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
        WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007,
        ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
        ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
        ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
        ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
        ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
        ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
        ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009,
        COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
        COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
        COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
        PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013,
        PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014,
        ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
        ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020,
        PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000,
        PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001,
        RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
        RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
        RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
        PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013,
        PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
        PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
        PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
        DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
        PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
        IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
        IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
        IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
        DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
        VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
        SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
        PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR = 1000163000,
        PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR = 1000163001,
        PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
        PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
        PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
        PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
        RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
        ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
        GEOMETRY_NV = 1000165003,
        GEOMETRY_TRIANGLES_NV = 1000165004,
        GEOMETRY_AABB_NV = 1000165005,
        BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
        WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
        ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
        PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
        RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
        ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
        PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
        PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
        PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
        FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
        IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
        MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
        PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
        PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
        PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
        CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000,
        PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
        VIDEO_DECODE_H265_CAPABILITIES_EXT = 1000187000,
        VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000187001,
        VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT = 1000187002,
        VIDEO_DECODE_H265_PROFILE_INFO_EXT = 1000187003,
        VIDEO_DECODE_H265_PICTURE_INFO_EXT = 1000187004,
        VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT = 1000187005,
        DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = 1000174000,
        PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = 1000388000,
        QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = 1000388001,
        DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
        PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
        PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
        PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002,
        PRESENT_FRAME_TOKEN_GGP = 1000191000,
        PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000,
        PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
        PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
        PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
        PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
        PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
        CHECKPOINT_DATA_NV = 1000206000,
        QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
        PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
        QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
        INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
        PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
        PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
        PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
        PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
        PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
        DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
        SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
        IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
        METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
        PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
        PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
        RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
        FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
        PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
        PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
        PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
        PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
        PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
        PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
        PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
        PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
        PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
        MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
        SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
        PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
        PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
        BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
        VALIDATION_FEATURES_EXT = 1000247000,
        PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000,
        PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
        COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
        PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
        PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
        PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
        FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
        PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
        PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
        PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000,
        PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001,
        PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002,
        SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
        SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
        SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
        HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
        PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000,
        PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001,
        PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002,
        PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
        PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000,
        PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
        PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
        PIPELINE_INFO_KHR = 1000269001,
        PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
        PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
        PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
        PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
        PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
        PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000,
        GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001,
        GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002,
        INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003,
        INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004,
        GENERATED_COMMANDS_INFO_NV = 1000277005,
        GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006,
        PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007,
        PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000,
        COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001,
        PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
        COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000,
        RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001,
        PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000,
        DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001,
        DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002,
        PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = 1000286000,
        PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = 1000286001,
        SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
        PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
        PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
        PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
        PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000,
        SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001,
        SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002,
        PRESENT_ID_KHR = 1000294000,
        PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001,
        VIDEO_ENCODE_INFO_KHR = 1000299000,
        VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001,
        VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002,
        VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003,
        VIDEO_ENCODE_USAGE_INFO_KHR = 1000299004,
        PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000,
        DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001,
        RESERVED_QCOM = 1000309000,
        EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000,
        EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001,
        EXPORT_METAL_DEVICE_INFO_EXT = 1000311002,
        EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003,
        EXPORT_METAL_BUFFER_INFO_EXT = 1000311004,
        IMPORT_METAL_BUFFER_INFO_EXT = 1000311005,
        EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006,
        IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007,
        EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008,
        IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
        EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
        IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
        QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
        CHECKPOINT_DATA_2_NV = 1000314009,
        PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000,
        PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001,
        GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002,
        PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000,
        PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000,
        PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000,
        PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000,
        PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000,
        PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001,
        PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002,
        ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000,
        PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001,
        ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002,
        PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000,
        PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001,
        PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000,
        PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
        PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
        COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000,
        PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000,
        PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000,
        IMAGE_COMPRESSION_CONTROL_EXT = 1000338001,
        SUBRESOURCE_LAYOUT_2_EXT = 1000338002,
        IMAGE_SUBRESOURCE_2_EXT = 1000338003,
        IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004,
        PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000,
        PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
        PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000,
        DEVICE_FAULT_COUNTS_EXT = 1000341001,
        DEVICE_FAULT_INFO_EXT = 1000341002,
        PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000,
        DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000,
        PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000,
        VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001,
        VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002,
        PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000,
        PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000,
        DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001,
        PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
        PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
        PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
        IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
        MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
        MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
        IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000,
        SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001,
        BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000,
        IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001,
        BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002,
        BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003,
        BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004,
        BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005,
        IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006,
        IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007,
        SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008,
        BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009,
        SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000,
        PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001,
        PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002,
        PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000,
        MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000,
        PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001,
        PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000,
        PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001,
        PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000,
        SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001,
        MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002,
        PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000,
        SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000,
        PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000,
        PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001,
        PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000,
        PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000,
        PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000,
        IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001,
        PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000,
        PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001,
        PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000,
        MICROMAP_BUILD_INFO_EXT = 1000396000,
        MICROMAP_VERSION_INFO_EXT = 1000396001,
        COPY_MICROMAP_INFO_EXT = 1000396002,
        COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003,
        COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004,
        PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005,
        PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006,
        MICROMAP_CREATE_INFO_EXT = 1000396007,
        MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008,
        ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009,
        PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
        SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
        PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
        PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000,
        DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001,
        DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002,
        PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT = 1000421000,
        PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000,
        PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM = 1000425000,
        PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM = 1000425001,
        SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM = 1000425002,
        PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000,
        PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000,
        PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000,
        PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001,
        IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002,
        PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000,
        PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001,
        PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000,
        RENDER_PASS_CREATION_CONTROL_EXT = 1000458001,
        RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002,
        RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003,
        PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000,
        PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001,
        PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002,
        SHADER_MODULE_IDENTIFIER_EXT = 1000462003,
        PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000,
        PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000,
        PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001,
        OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002,
        OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003,
        OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004,
        OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005,
        OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010,
        PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000,
        PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT = 1000466000,
        PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000,
        TILE_PROPERTIES_QCOM = 1000484001,
        PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000,
        AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001,
        PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000,
        MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002,
        PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = 1000120000,
        PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = 1000063000,
        DEBUG_REPORT_CREATE_INFO_EXT = 1000011000,
        RENDERING_INFO_KHR = 1000044000,
        RENDERING_ATTACHMENT_INFO_KHR = 1000044001,
        PIPELINE_RENDERING_CREATE_INFO_KHR = 1000044002,
        PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR = 1000044003,
        COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR = 1000044004,
        ATTACHMENT_SAMPLE_COUNT_INFO_NV = 1000044008,
        RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = 1000053000,
        PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = 1000053001,
        PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = 1000053002,
        PHYSICAL_DEVICE_FEATURES_2_KHR = 1000059000,
        PHYSICAL_DEVICE_PROPERTIES_2_KHR = 1000059001,
        FORMAT_PROPERTIES_2_KHR = 1000059002,
        IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059003,
        PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = 1000059004,
        QUEUE_FAMILY_PROPERTIES_2_KHR = 1000059005,
        PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = 1000059006,
        SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059007,
        PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = 1000059008,
        MEMORY_ALLOCATE_FLAGS_INFO_KHR = 1000060000,
        DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = 1000060003,
        DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = 1000060004,
        DEVICE_GROUP_SUBMIT_INFO_KHR = 1000060005,
        DEVICE_GROUP_BIND_SPARSE_INFO_KHR = 1000060006,
        BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060013,
        BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060014,
        PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 1000066000,
        PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = 1000070000,
        DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = 1000070001,
        PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = 1000071000,
        EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = 1000071001,
        PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = 1000071002,
        EXTERNAL_BUFFER_PROPERTIES_KHR = 1000071003,
        PHYSICAL_DEVICE_ID_PROPERTIES_KHR = 1000071004,
        EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = 1000072000,
        EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = 1000072001,
        EXPORT_MEMORY_ALLOCATE_INFO_KHR = 1000072002,
        PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = 1000076000,
        EXTERNAL_SEMAPHORE_PROPERTIES_KHR = 1000076001,
        EXPORT_SEMAPHORE_CREATE_INFO_KHR = 1000077000,
        PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = 1000082000,
        PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = 1000082000,
        PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = 1000083000,
        DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = 1000085000,
        SURFACE_CAPABILITIES2_EXT = 1000090000,
        PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = 1000108000,
        FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = 1000108001,
        FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = 1000108002,
        RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = 1000108003,
        ATTACHMENT_DESCRIPTION_2_KHR = 1000109000,
        ATTACHMENT_REFERENCE_2_KHR = 1000109001,
        SUBPASS_DESCRIPTION_2_KHR = 1000109002,
        SUBPASS_DEPENDENCY_2_KHR = 1000109003,
        RENDER_PASS_CREATE_INFO_2_KHR = 1000109004,
        SUBPASS_BEGIN_INFO_KHR = 1000109005,
        SUBPASS_END_INFO_KHR = 1000109006,
        PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = 1000112000,
        EXTERNAL_FENCE_PROPERTIES_KHR = 1000112001,
        EXPORT_FENCE_CREATE_INFO_KHR = 1000113000,
        PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = 1000117000,
        RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = 1000117001,
        IMAGE_VIEW_USAGE_CREATE_INFO_KHR = 1000117002,
        PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = 1000117003,
        PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = 1000120000,
        PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = 1000120000,
        MEMORY_DEDICATED_REQUIREMENTS_KHR = 1000127000,
        MEMORY_DEDICATED_ALLOCATE_INFO_KHR = 1000127001,
        PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000,
        SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001,
        PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000,
        PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001,
        WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002,
        DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003,
        BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146000,
        IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146001,
        IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146002,
        MEMORY_REQUIREMENTS_2_KHR = 1000146003,
        SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = 1000146004,
        IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 1000147000,
        SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = 1000156000,
        SAMPLER_YCBCR_CONVERSION_INFO_KHR = 1000156001,
        BIND_IMAGE_PLANE_MEMORY_INFO_KHR = 1000156002,
        IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = 1000156003,
        PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = 1000156004,
        SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = 1000156005,
        BIND_BUFFER_MEMORY_INFO_KHR = 1000157000,
        BIND_IMAGE_MEMORY_INFO_KHR = 1000157001,
        DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = 1000161000,
        PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = 1000161001,
        PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = 1000161002,
        DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = 1000161003,
        DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 1000161004,
        PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = 1000168000,
        DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = 1000168001,
        DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000,
        PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = 1000175000,
        PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = 1000177000,
        PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = 1000180000,
        PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000,
        PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = 1000196000,
        PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = 1000197000,
        PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = 1000199000,
        SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = 1000199001,
        PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000,
        PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = 1000207000,
        PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = 1000207001,
        SEMAPHORE_TYPE_CREATE_INFO_KHR = 1000207002,
        TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR = 1000207003,
        SEMAPHORE_WAIT_INFO_KHR = 1000207004,
        SEMAPHORE_SIGNAL_INFO_KHR = 1000207005,
        QUERY_POOL_CREATE_INFO_INTEL = 1000210000,
        PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = 1000211000,
        PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR = 1000215000,
        PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = 1000221000,
        PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 1000225000,
        PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 1000225001,
        PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 1000225002,
        PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = 1000241000,
        ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = 1000241001,
        ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = 1000241002,
        PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = 1000244000,
        BUFFER_DEVICE_ADDRESS_INFO_EXT = 1000244001,
        PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = 1000245000,
        IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = 1000246000,
        PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = 1000253000,
        PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = 1000257000,
        BUFFER_DEVICE_ADDRESS_INFO_KHR = 1000244001,
        BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = 1000257002,
        MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = 1000257003,
        DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = 1000257004,
        PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = 1000261000,
        PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000,
        PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR = 1000280000,
        PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR = 1000280001,
        PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 1000281001,
        PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT = 1000295000,
        DEVICE_PRIVATE_DATA_CREATE_INFO_EXT = 1000295001,
        PRIVATE_DATA_SLOT_CREATE_INFO_EXT = 1000295002,
        PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT = 1000297000,
        MEMORY_BARRIER_2_KHR = 1000314000,
        BUFFER_MEMORY_BARRIER_2_KHR = 1000314001,
        IMAGE_MEMORY_BARRIER_2_KHR = 1000314002,
        DEPENDENCY_INFO_KHR = 1000314003,
        SUBMIT_INFO_2_KHR = 1000314004,
        SEMAPHORE_SUBMIT_INFO_KHR = 1000314005,
        COMMAND_BUFFER_SUBMIT_INFO_KHR = 1000314006,
        PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR = 1000314007,
        PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR = 1000325000,
        PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT = 1000335000,
        COPY_BUFFER_INFO_2_KHR = 1000337000,
        COPY_IMAGE_INFO_2_KHR = 1000337001,
        COPY_BUFFER_TO_IMAGE_INFO_2_KHR = 1000337002,
        COPY_IMAGE_TO_BUFFER_INFO_2_KHR = 1000337003,
        BLIT_IMAGE_INFO_2_KHR = 1000337004,
        RESOLVE_IMAGE_INFO_2_KHR = 1000337005,
        BUFFER_COPY_2_KHR = 1000337006,
        IMAGE_COPY_2_KHR = 1000337007,
        IMAGE_BLIT_2_KHR = 1000337008,
        BUFFER_IMAGE_COPY_2_KHR = 1000337009,
        IMAGE_RESOLVE_2_KHR = 1000337010,
        PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM = 1000342000,
        PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = 1000351000,
        MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = 1000351002,
        FORMAT_PROPERTIES_3_KHR = 1000360000,
        PIPELINE_INFO_EXT = 1000269001,
        PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT = 1000388000,
        QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT = 1000388001,
        PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR = 1000413000,
        PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR = 1000413001,
        DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR = 1000413002,
        DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR = 1000413003,
    };
    enum SystemAllocationScope {
        COMMAND = 0,
        OBJECT = 1,
        CACHE = 2,
        DEVICE = 3,
        INSTANCE = 4,
    };
    enum InternalAllocationType {
        EXECUTABLE = 0,
    };
    enum SamplerAddressMode {
        REPEAT = 0,
        MIRRORED_REPEAT = 1,
        CLAMP_TO_EDGE = 2,
        CLAMP_TO_BORDER = 3,
        MIRROR_CLAMP_TO_EDGE = 4,
        MIRROR_CLAMP_TO_EDGE_KHR = 4,
    };
    enum Filter {
        NEAREST = 0,
        LINEAR = 1,
        CUBIC_EXT = 1000015000,
        CUBIC_IMG = 1000015000,
    };
    enum SamplerMipmapMode {
        NEAREST = 0,
        LINEAR = 1,
    };
    enum VertexInputRate {
        VERTEX = 0,
        INSTANCE = 1,
    };
    bitmask PipelineStageFlagBits {
        TOP_OF_PIPE_BIT = 1,
        DRAW_INDIRECT_BIT = 2,
        VERTEX_INPUT_BIT = 4,
        VERTEX_SHADER_BIT = 8,
        TESSELLATION_CONTROL_SHADER_BIT = 16,
        TESSELLATION_EVALUATION_SHADER_BIT = 32,
        GEOMETRY_SHADER_BIT = 64,
        FRAGMENT_SHADER_BIT = 128,
        EARLY_FRAGMENT_TESTS_BIT = 256,
        LATE_FRAGMENT_TESTS_BIT = 512,
        COLOR_ATTACHMENT_OUTPUT_BIT = 1024,
        COMPUTE_SHADER_BIT = 2048,
        TRANSFER_BIT = 4096,
        BOTTOM_OF_PIPE_BIT = 8192,
        HOST_BIT = 16384,
        ALL_GRAPHICS_BIT = 32768,
        ALL_COMMANDS_BIT = 65536,
        NONE = 0,
        TRANSFORM_FEEDBACK_BIT_EXT = 16777216,
        CONDITIONAL_RENDERING_BIT_EXT = 262144,
        ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 33554432,
        RAY_TRACING_SHADER_BIT_KHR = 2097152,
        FRAGMENT_DENSITY_PROCESS_BIT_EXT = 8388608,
        FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 4194304,
        COMMAND_PREPROCESS_BIT_NV = 131072,
        TASK_SHADER_BIT_EXT = 524288,
        MESH_SHADER_BIT_EXT = 1048576,
        SHADING_RATE_IMAGE_BIT_NV = 4194304,
        RAY_TRACING_SHADER_BIT_NV = 2097152,
        ACCELERATION_STRUCTURE_BUILD_BIT_NV = 33554432,
        TASK_SHADER_BIT_NV = 524288,
        MESH_SHADER_BIT_NV = 1048576,
        NONE_KHR = 0,
    };
    bitmask SparseImageFormatFlagBits {
        SINGLE_MIPTAIL_BIT = 1,
        ALIGNED_MIP_SIZE_BIT = 2,
        NONSTANDARD_BLOCK_SIZE_BIT = 4,
    };
    bitmask SampleCountFlagBits {
        _1_BIT = 1,
        _2_BIT = 2,
        _4_BIT = 4,
        _8_BIT = 8,
        _16_BIT = 16,
        _32_BIT = 32,
        _64_BIT = 64,
    };
    bitmask AttachmentDescriptionFlagBits {
        MAY_ALIAS_BIT = 1,
    };
    bitmask DescriptorPoolCreateFlagBits {
        FREE_DESCRIPTOR_SET_BIT = 1,
        UPDATE_AFTER_BIND_BIT = 2,
        HOST_ONLY_BIT_EXT = 4,
        UPDATE_AFTER_BIND_BIT_EXT = 2,
        HOST_ONLY_BIT_VALVE = 4,
    };
    bitmask DependencyFlagBits {
        BY_REGION_BIT = 1,
        DEVICE_GROUP_BIT = 4,
        VIEW_LOCAL_BIT = 2,
        FEEDBACK_LOOP_BIT_EXT = 8,
        VIEW_LOCAL_BIT_KHR = 2,
        DEVICE_GROUP_BIT_KHR = 4,
    };
    enum ObjectType {
        UNKNOWN = 0,
        INSTANCE = 1,
        PHYSICAL_DEVICE = 2,
        DEVICE = 3,
        QUEUE = 4,
        SEMAPHORE = 5,
        COMMAND_BUFFER = 6,
        FENCE = 7,
        DEVICE_MEMORY = 8,
        BUFFER = 9,
        IMAGE = 10,
        EVENT = 11,
        QUERY_POOL = 12,
        BUFFER_VIEW = 13,
        IMAGE_VIEW = 14,
        SHADER_MODULE = 15,
        PIPELINE_CACHE = 16,
        PIPELINE_LAYOUT = 17,
        RENDER_PASS = 18,
        PIPELINE = 19,
        DESCRIPTOR_SET_LAYOUT = 20,
        SAMPLER = 21,
        DESCRIPTOR_POOL = 22,
        DESCRIPTOR_SET = 23,
        FRAMEBUFFER = 24,
        COMMAND_POOL = 25,
        SAMPLER_YCBCR_CONVERSION = 1000156000,
        DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
        PRIVATE_DATA_SLOT = 1000295000,
        SURFACE_KHR = 1000000000,
        SWAPCHAIN_KHR = 1000001000,
        DISPLAY_KHR = 1000002000,
        DISPLAY_MODE_KHR = 1000002001,
        DEBUG_REPORT_CALLBACK_EXT = 1000011000,
        VIDEO_SESSION_KHR = 1000023000,
        VIDEO_SESSION_PARAMETERS_KHR = 1000023001,
        CU_MODULE_NVX = 1000029000,
        CU_FUNCTION_NVX = 1000029001,
        DEBUG_UTILS_MESSENGER_EXT = 1000128000,
        ACCELERATION_STRUCTURE_KHR = 1000150000,
        VALIDATION_CACHE_EXT = 1000160000,
        ACCELERATION_STRUCTURE_NV = 1000165000,
        PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
        DEFERRED_OPERATION_KHR = 1000268000,
        INDIRECT_COMMANDS_LAYOUT_NV = 1000277000,
        BUFFER_COLLECTION_FUCHSIA = 1000366000,
        MICROMAP_EXT = 1000396000,
        OPTICAL_FLOW_SESSION_NV = 1000464000,
        DESCRIPTOR_UPDATE_TEMPLATE_KHR = 1000085000,
        SAMPLER_YCBCR_CONVERSION_KHR = 1000156000,
        PRIVATE_DATA_SLOT_EXT = 1000295000,
    };
    bitmask EventCreateFlagBits {
        DEVICE_ONLY_BIT = 1,
        DEVICE_ONLY_BIT_KHR = 1,
    };
    bitmask PipelineLayoutCreateFlagBits {
        RESERVED_0_BIT_AMD = 1,
        INDEPENDENT_SETS_BIT_EXT = 2,
    };
    bitmask SemaphoreCreateFlagBits {
    };
    bitmask IndirectCommandsLayoutUsageFlagBitsNV {
        EXPLICIT_PREPROCESS_BIT_NV = 1,
        INDEXED_SEQUENCES_BIT_NV = 2,
        UNORDERED_SEQUENCES_BIT_NV = 4,
    };
    enum IndirectCommandsTokenTypeNV {
        SHADER_GROUP_NV = 0,
        STATE_FLAGS_NV = 1,
        INDEX_BUFFER_NV = 2,
        VERTEX_BUFFER_NV = 3,
        PUSH_CONSTANT_NV = 4,
        DRAW_INDEXED_NV = 5,
        DRAW_NV = 6,
        DRAW_TASKS_NV = 7,
        DRAW_MESH_TASKS_NV = 1000328000,
    };
    bitmask IndirectStateFlagBitsNV {
        FLAG_FRONTFACE_BIT_NV = 1,
    };
    bitmask PrivateDataSlotCreateFlagBits {
    };
    enum DescriptorUpdateTemplateType {
        DESCRIPTOR_SET = 0,
        PUSH_DESCRIPTORS_KHR = 1,
        DESCRIPTOR_SET_KHR = 0,
    };
    enum ViewportCoordinateSwizzleNV {
        POSITIVE_X_NV = 0,
        NEGATIVE_X_NV = 1,
        POSITIVE_Y_NV = 2,
        NEGATIVE_Y_NV = 3,
        POSITIVE_Z_NV = 4,
        NEGATIVE_Z_NV = 5,
        POSITIVE_W_NV = 6,
        NEGATIVE_W_NV = 7,
    };
    enum DiscardRectangleModeEXT {
        INCLUSIVE_EXT = 0,
        EXCLUSIVE_EXT = 1,
    };
    bitmask SubpassDescriptionFlagBits {
        PER_VIEW_ATTRIBUTES_BIT_NVX = 1,
        PER_VIEW_POSITION_X_ONLY_BIT_NVX = 2,
        FRAGMENT_REGION_BIT_QCOM = 4,
        SHADER_RESOLVE_BIT_QCOM = 8,
        RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT = 16,
        RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 32,
        RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 64,
        ENABLE_LEGACY_DITHERING_BIT_EXT = 128,
        RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM = 16,
        RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = 32,
        RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = 64,
    };
    enum PointClippingBehavior {
        ALL_CLIP_PLANES = 0,
        USER_CLIP_PLANES_ONLY = 1,
        ALL_CLIP_PLANES_KHR = 0,
        USER_CLIP_PLANES_ONLY_KHR = 1,
    };
    enum CoverageModulationModeNV {
        NONE_NV = 0,
        RGB_NV = 1,
        ALPHA_NV = 2,
        RGBA_NV = 3,
    };
    enum CoverageReductionModeNV {
        MERGE_NV = 0,
        TRUNCATE_NV = 1,
    };
    enum ValidationCacheHeaderVersionEXT {
        ONE_EXT = 1,
    };
    enum ShaderInfoTypeAMD {
        STATISTICS_AMD = 0,
        BINARY_AMD = 1,
        DISASSEMBLY_AMD = 2,
    };
    enum QueueGlobalPriorityKHR {
        LOW_KHR = 128,
        MEDIUM_KHR = 256,
        HIGH_KHR = 512,
        REALTIME_KHR = 1024,
        LOW_EXT = 128,
        MEDIUM_EXT = 256,
        HIGH_EXT = 512,
        REALTIME_EXT = 1024,
    };
    enum TimeDomainEXT {
        DEVICE_EXT = 0,
        CLOCK_MONOTONIC_EXT = 1,
        CLOCK_MONOTONIC_RAW_EXT = 2,
        QUERY_PERFORMANCE_COUNTER_EXT = 3,
    };
    enum ConservativeRasterizationModeEXT {
        DISABLED_EXT = 0,
        OVERESTIMATE_EXT = 1,
        UNDERESTIMATE_EXT = 2,
    };
    bitmask ResolveModeFlagBits {
        NONE = 0,
        SAMPLE_ZERO_BIT = 1,
        AVERAGE_BIT = 2,
        MIN_BIT = 4,
        MAX_BIT = 8,
        NONE_KHR = 0,
        SAMPLE_ZERO_BIT_KHR = 1,
        AVERAGE_BIT_KHR = 2,
        MIN_BIT_KHR = 4,
        MAX_BIT_KHR = 8,
    };
    bitmask DescriptorBindingFlagBits {
        UPDATE_AFTER_BIND_BIT = 1,
        UPDATE_UNUSED_WHILE_PENDING_BIT = 2,
        PARTIALLY_BOUND_BIT = 4,
        VARIABLE_DESCRIPTOR_COUNT_BIT = 8,
        RESERVED_4_BIT_QCOM = 16,
        UPDATE_AFTER_BIND_BIT_EXT = 1,
        UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = 2,
        PARTIALLY_BOUND_BIT_EXT = 4,
        VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = 8,
    };
    bitmask ConditionalRenderingFlagBitsEXT {
        INVERTED_BIT_EXT = 1,
    };
    enum SemaphoreType {
        BINARY = 0,
        TIMELINE = 1,
        BINARY_KHR = 0,
        TIMELINE_KHR = 1,
    };
    bitmask GeometryFlagBitsKHR {
        OPAQUE_BIT_KHR = 1,
        NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 2,
        OPAQUE_BIT_NV = 1,
        NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = 2,
    };
    bitmask GeometryInstanceFlagBitsKHR {
        TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 1,
        TRIANGLE_FLIP_FACING_BIT_KHR = 2,
        FORCE_OPAQUE_BIT_KHR = 4,
        FORCE_NO_OPAQUE_BIT_KHR = 8,
        FORCE_OPACITY_MICROMAP_2_STATE_EXT = 16,
        DISABLE_OPACITY_MICROMAPS_EXT = 32,
        TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR = 2,
        TRIANGLE_CULL_DISABLE_BIT_NV = 1,
        TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = 2,
        FORCE_OPAQUE_BIT_NV = 4,
        FORCE_NO_OPAQUE_BIT_NV = 8,
    };
    bitmask BuildAccelerationStructureFlagBitsKHR {
        ALLOW_UPDATE_BIT_KHR = 1,
        ALLOW_COMPACTION_BIT_KHR = 2,
        PREFER_FAST_TRACE_BIT_KHR = 4,
        PREFER_FAST_BUILD_BIT_KHR = 8,
        LOW_MEMORY_BIT_KHR = 16,
        MOTION_BIT_NV = 32,
        ALLOW_OPACITY_MICROMAP_UPDATE_EXT = 64,
        ALLOW_DISABLE_OPACITY_MICROMAPS_EXT = 128,
        ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT = 256,
        RESERVED_BIT_9_NV = 512,
        RESERVED_BIT_10_NV = 1024,
        ALLOW_UPDATE_BIT_NV = 1,
        ALLOW_COMPACTION_BIT_NV = 2,
        PREFER_FAST_TRACE_BIT_NV = 4,
        PREFER_FAST_BUILD_BIT_NV = 8,
        LOW_MEMORY_BIT_NV = 16,
    };
    bitmask AccelerationStructureCreateFlagBitsKHR {
        DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 1,
        RESERVED_3_BIT_AMD = 8,
        MOTION_BIT_NV = 4,
    };
    enum BuildAccelerationStructureModeKHR {
        BUILD_KHR = 0,
        UPDATE_KHR = 1,
    };
    enum CopyAccelerationStructureModeKHR {
        CLONE_KHR = 0,
        COMPACT_KHR = 1,
        SERIALIZE_KHR = 2,
        DESERIALIZE_KHR = 3,
        CLONE_NV = 0,
        COMPACT_NV = 1,
    };
    enum AccelerationStructureTypeKHR {
        TOP_LEVEL_KHR = 0,
        BOTTOM_LEVEL_KHR = 1,
        GENERIC_KHR = 2,
        TOP_LEVEL_NV = 0,
        BOTTOM_LEVEL_NV = 1,
    };
    enum GeometryTypeKHR {
        TRIANGLES_KHR = 0,
        AABBS_KHR = 1,
        INSTANCES_KHR = 2,
        TRIANGLES_NV = 0,
        AABBS_NV = 1,
    };
    enum RayTracingShaderGroupTypeKHR {
        GENERAL_KHR = 0,
        TRIANGLES_HIT_GROUP_KHR = 1,
        PROCEDURAL_HIT_GROUP_KHR = 2,
        GENERAL_NV = 0,
        TRIANGLES_HIT_GROUP_NV = 1,
        PROCEDURAL_HIT_GROUP_NV = 2,
    };
    enum AccelerationStructureMemoryRequirementsTypeNV {
        OBJECT_NV = 0,
        BUILD_SCRATCH_NV = 1,
        UPDATE_SCRATCH_NV = 2,
    };
    enum AccelerationStructureBuildTypeKHR {
        HOST_KHR = 0,
        DEVICE_KHR = 1,
        HOST_OR_DEVICE_KHR = 2,
    };
    enum AccelerationStructureCompatibilityKHR {
        COMPATIBLE_KHR = 0,
        INCOMPATIBLE_KHR = 1,
    };
    enum ShaderGroupShaderKHR {
        GENERAL_KHR = 0,
        CLOSEST_HIT_KHR = 1,
        ANY_HIT_KHR = 2,
        INTERSECTION_KHR = 3,
    };
    enum MemoryOverallocationBehaviorAMD {
        DEFAULT_AMD = 0,
        ALLOWED_AMD = 1,
        DISALLOWED_AMD = 2,
    };
    enum ScopeNV {
        DEVICE_NV = 1,
        WORKGROUP_NV = 2,
        SUBGROUP_NV = 3,
        QUEUE_FAMILY_NV = 5,
    };
    enum ComponentTypeNV {
        FLOAT16_NV = 0,
        FLOAT32_NV = 1,
        FLOAT64_NV = 2,
        SINT8_NV = 3,
        SINT16_NV = 4,
        SINT32_NV = 5,
        SINT64_NV = 6,
        UINT8_NV = 7,
        UINT16_NV = 8,
        UINT32_NV = 9,
        UINT64_NV = 10,
    };
    bitmask DeviceDiagnosticsConfigFlagBitsNV {
        ENABLE_SHADER_DEBUG_INFO_BIT_NV = 1,
        ENABLE_RESOURCE_TRACKING_BIT_NV = 2,
        ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 4,
        ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 8,
    };
    bitmask PipelineCreationFeedbackFlagBits {
        VALID_BIT = 1,
        APPLICATION_PIPELINE_CACHE_HIT_BIT = 2,
        BASE_PIPELINE_ACCELERATION_BIT = 4,
        VALID_BIT_EXT = 1,
        APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = 2,
        BASE_PIPELINE_ACCELERATION_BIT_EXT = 4,
    };
    enum PerformanceCounterScopeKHR {
        COMMAND_BUFFER_KHR = 0,
        RENDER_PASS_KHR = 1,
        COMMAND_KHR = 2,
        QUERY_SCOPE_COMMAND_BUFFER_KHR = 0,
        QUERY_SCOPE_RENDER_PASS_KHR = 1,
        QUERY_SCOPE_COMMAND_KHR = 2,
    };
    enum PerformanceCounterUnitKHR {
        GENERIC_KHR = 0,
        PERCENTAGE_KHR = 1,
        NANOSECONDS_KHR = 2,
        BYTES_KHR = 3,
        BYTES_PER_SECOND_KHR = 4,
        KELVIN_KHR = 5,
        WATTS_KHR = 6,
        VOLTS_KHR = 7,
        AMPS_KHR = 8,
        HERTZ_KHR = 9,
        CYCLES_KHR = 10,
    };
    enum PerformanceCounterStorageKHR {
        INT32_KHR = 0,
        INT64_KHR = 1,
        UINT32_KHR = 2,
        UINT64_KHR = 3,
        FLOAT32_KHR = 4,
        FLOAT64_KHR = 5,
    };
    bitmask PerformanceCounterDescriptionFlagBitsKHR {
        PERFORMANCE_IMPACTING_BIT_KHR = 1,
        CONCURRENTLY_IMPACTED_BIT_KHR = 2,
        PERFORMANCE_IMPACTING_KHR = 1,
        CONCURRENTLY_IMPACTED_KHR = 2,
    };
    bitmask AcquireProfilingLockFlagBitsKHR {
    };
    bitmask SemaphoreWaitFlagBits {
        ANY_BIT = 1,
        ANY_BIT_KHR = 1,
    };
    enum PerformanceConfigurationTypeINTEL {
        COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
    };
    enum QueryPoolSamplingModeINTEL {
        MANUAL_INTEL = 0,
    };
    enum PerformanceOverrideTypeINTEL {
        NULL_HARDWARE_INTEL = 0,
        FLUSH_GPU_CACHES_INTEL = 1,
    };
    enum PerformanceParameterTypeINTEL {
        HW_COUNTERS_SUPPORTED_INTEL = 0,
        STREAM_MARKER_VALID_BITS_INTEL = 1,
    };
    enum PerformanceValueTypeINTEL {
        UINT32_INTEL = 0,
        UINT64_INTEL = 1,
        FLOAT_INTEL = 2,
        BOOL_INTEL = 3,
        STRING_INTEL = 4,
    };
    enum LineRasterizationModeEXT {
        DEFAULT_EXT = 0,
        RECTANGULAR_EXT = 1,
        BRESENHAM_EXT = 2,
        RECTANGULAR_SMOOTH_EXT = 3,
    };
    bitmask ShaderModuleCreateFlagBits {
    };
    bitmask PipelineCompilerControlFlagBitsAMD {
    };
    bitmask ShaderCorePropertiesFlagBitsAMD {
    };
    bitmask ToolPurposeFlagBits {
        VALIDATION_BIT = 1,
        PROFILING_BIT = 2,
        TRACING_BIT = 4,
        ADDITIONAL_FEATURES_BIT = 8,
        MODIFYING_FEATURES_BIT = 16,
        DEBUG_REPORTING_BIT_EXT = 32,
        DEBUG_MARKERS_BIT_EXT = 64,
        VALIDATION_BIT_EXT = 1,
        PROFILING_BIT_EXT = 2,
        TRACING_BIT_EXT = 4,
        ADDITIONAL_FEATURES_BIT_EXT = 8,
        MODIFYING_FEATURES_BIT_EXT = 16,
    };
    enum FragmentShadingRateNV {
        _1_INVOCATION_PER_PIXEL_NV = 0,
        _1_INVOCATION_PER_1X2_PIXELS_NV = 1,
        _1_INVOCATION_PER_2X1_PIXELS_NV = 4,
        _1_INVOCATION_PER_2X2_PIXELS_NV = 5,
        _1_INVOCATION_PER_2X4_PIXELS_NV = 6,
        _1_INVOCATION_PER_4X2_PIXELS_NV = 9,
        _1_INVOCATION_PER_4X4_PIXELS_NV = 10,
        _2_INVOCATIONS_PER_PIXEL_NV = 11,
        _4_INVOCATIONS_PER_PIXEL_NV = 12,
        _8_INVOCATIONS_PER_PIXEL_NV = 13,
        _16_INVOCATIONS_PER_PIXEL_NV = 14,
        NO_INVOCATIONS_NV = 15,
    };
    enum FragmentShadingRateTypeNV {
        FRAGMENT_SIZE_NV = 0,
        ENUMS_NV = 1,
    };
    enum SubpassMergeStatusEXT {
        MERGED_EXT = 0,
        DISALLOWED_EXT = 1,
        NOT_MERGED_SIDE_EFFECTS_EXT = 2,
        NOT_MERGED_SAMPLES_MISMATCH_EXT = 3,
        NOT_MERGED_VIEWS_MISMATCH_EXT = 4,
        NOT_MERGED_ALIASING_EXT = 5,
        NOT_MERGED_DEPENDENCIES_EXT = 6,
        NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7,
        NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8,
        NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9,
        NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10,
        NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11,
        NOT_MERGED_SINGLE_SUBPASS_EXT = 12,
        NOT_MERGED_UNSPECIFIED_EXT = 13,
    };
    bitmask64 AccessFlagBits2 {
        ACCESS_2_NONE = 0,
        ACCESS_2_INDIRECT_COMMAND_READ_BIT = 1,
        ACCESS_2_INDEX_READ_BIT = 2,
        ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = 4,
        ACCESS_2_UNIFORM_READ_BIT = 8,
        ACCESS_2_INPUT_ATTACHMENT_READ_BIT = 16,
        ACCESS_2_SHADER_READ_BIT = 32,
        ACCESS_2_SHADER_WRITE_BIT = 64,
        ACCESS_2_COLOR_ATTACHMENT_READ_BIT = 128,
        ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = 256,
        ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 512,
        ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1024,
        ACCESS_2_TRANSFER_READ_BIT = 2048,
        ACCESS_2_TRANSFER_WRITE_BIT = 4096,
        ACCESS_2_HOST_READ_BIT = 8192,
        ACCESS_2_HOST_WRITE_BIT = 16384,
        ACCESS_2_MEMORY_READ_BIT = 32768,
        ACCESS_2_MEMORY_WRITE_BIT = 65536,
        ACCESS_2_SHADER_SAMPLED_READ_BIT = 4294967296,
        ACCESS_2_SHADER_STORAGE_READ_BIT = 8589934592,
        ACCESS_2_SHADER_STORAGE_WRITE_BIT = 17179869184,
        ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = 34359738368,
        ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = 68719476736,
        ACCESS_2_RESERVED_46_BIT_EXT = 70368744177664,
        ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = 137438953472,
        ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = 274877906944,
        ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 33554432,
        ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 67108864,
        ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 134217728,
        ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = 1048576,
        ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = 131072,
        ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = 262144,
        ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 8388608,
        ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = 2097152,
        ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 4194304,
        ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 16777216,
        ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 524288,
        ACCESS_2_RESERVED_41_BIT_AMD = 2199023255552,
        ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = 549755813888,
        ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR = 1099511627776,
        ACCESS_2_MICROMAP_READ_BIT_EXT = 17592186044416,
        ACCESS_2_MICROMAP_WRITE_BIT_EXT = 35184372088832,
        ACCESS_2_OPTICAL_FLOW_READ_BIT_NV = 4398046511104,
        ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV = 8796093022208,
        ACCESS_2_NONE_KHR = 0,
        ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = 1,
        ACCESS_2_INDEX_READ_BIT_KHR = 2,
        ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = 4,
        ACCESS_2_UNIFORM_READ_BIT_KHR = 8,
        ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = 16,
        ACCESS_2_SHADER_READ_BIT_KHR = 32,
        ACCESS_2_SHADER_WRITE_BIT_KHR = 64,
        ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = 128,
        ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = 256,
        ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = 512,
        ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = 1024,
        ACCESS_2_TRANSFER_READ_BIT_KHR = 2048,
        ACCESS_2_TRANSFER_WRITE_BIT_KHR = 4096,
        ACCESS_2_HOST_READ_BIT_KHR = 8192,
        ACCESS_2_HOST_WRITE_BIT_KHR = 16384,
        ACCESS_2_MEMORY_READ_BIT_KHR = 32768,
        ACCESS_2_MEMORY_WRITE_BIT_KHR = 65536,
        ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = 4294967296,
        ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = 8589934592,
        ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = 17179869184,
        ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV = 8388608,
        ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV = 2097152,
        ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 4194304,
    };
    bitmask64 PipelineStageFlagBits2 {
        PIPELINE_STAGE_2_NONE = 0,
        PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = 1,
        PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = 2,
        PIPELINE_STAGE_2_VERTEX_INPUT_BIT = 4,
        PIPELINE_STAGE_2_VERTEX_SHADER_BIT = 8,
        PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT = 16,
        PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT = 32,
        PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = 64,
        PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = 128,
        PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT = 256,
        PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT = 512,
        PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT = 1024,
        PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = 2048,
        PIPELINE_STAGE_2_ALL_TRANSFER_BIT = 4096,
        PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = 8192,
        PIPELINE_STAGE_2_HOST_BIT = 16384,
        PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = 32768,
        PIPELINE_STAGE_2_ALL_COMMANDS_BIT = 65536,
        PIPELINE_STAGE_2_COPY_BIT = 4294967296,
        PIPELINE_STAGE_2_RESOLVE_BIT = 8589934592,
        PIPELINE_STAGE_2_BLIT_BIT = 17179869184,
        PIPELINE_STAGE_2_CLEAR_BIT = 34359738368,
        PIPELINE_STAGE_2_INDEX_INPUT_BIT = 68719476736,
        PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT = 137438953472,
        PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT = 274877906944,
        PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = 67108864,
        PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = 134217728,
        PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = 16777216,
        PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = 262144,
        PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV = 131072,
        PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 4194304,
        PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 33554432,
        PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR = 2097152,
        PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 8388608,
        PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT = 524288,
        PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT = 1048576,
        PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI = 549755813888,
        PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = 1099511627776,
        PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR = 268435456,
        PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT = 1073741824,
        PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV = 536870912,
        PIPELINE_STAGE_2_NONE_KHR = 0,
        PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = 1,
        PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = 2,
        PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = 4,
        PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = 8,
        PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = 16,
        PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = 32,
        PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = 64,
        PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = 128,
        PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = 256,
        PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = 512,
        PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = 1024,
        PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = 2048,
        PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = 4096,
        PIPELINE_STAGE_2_TRANSFER_BIT = 4096,
        PIPELINE_STAGE_2_TRANSFER_BIT_KHR = 4096,
        PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = 8192,
        PIPELINE_STAGE_2_HOST_BIT_KHR = 16384,
        PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = 32768,
        PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = 65536,
        PIPELINE_STAGE_2_COPY_BIT_KHR = 4294967296,
        PIPELINE_STAGE_2_RESOLVE_BIT_KHR = 8589934592,
        PIPELINE_STAGE_2_BLIT_BIT_KHR = 17179869184,
        PIPELINE_STAGE_2_CLEAR_BIT_KHR = 34359738368,
        PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = 68719476736,
        PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = 137438953472,
        PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = 274877906944,
        PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV = 4194304,
        PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV = 2097152,
        PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 33554432,
        PIPELINE_STAGE_2_TASK_SHADER_BIT_NV = 524288,
        PIPELINE_STAGE_2_MESH_SHADER_BIT_NV = 1048576,
    };
    enum ProvokingVertexModeEXT {
        FIRST_VERTEX_EXT = 0,
        LAST_VERTEX_EXT = 1,
    };
    bitmask ImageFormatConstraintsFlagBitsFUCHSIA {
    };
    bitmask ImageConstraintsInfoFlagBitsFUCHSIA {
        CPU_READ_RARELY_FUCHSIA = 1,
        CPU_READ_OFTEN_FUCHSIA = 2,
        CPU_WRITE_RARELY_FUCHSIA = 4,
        CPU_WRITE_OFTEN_FUCHSIA = 8,
        PROTECTED_OPTIONAL_FUCHSIA = 16,
    };
    bitmask64 FormatFeatureFlagBits2 {
        FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT = 1,
        FORMAT_FEATURE_2_STORAGE_IMAGE_BIT = 2,
        FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT = 4,
        FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT = 8,
        FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT = 16,
        FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 32,
        FORMAT_FEATURE_2_VERTEX_BUFFER_BIT = 64,
        FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT = 128,
        FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT = 256,
        FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT = 512,
        FORMAT_FEATURE_2_BLIT_SRC_BIT = 1024,
        FORMAT_FEATURE_2_BLIT_DST_BIT = 2048,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 4096,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT = 8192,
        FORMAT_FEATURE_2_TRANSFER_SRC_BIT = 16384,
        FORMAT_FEATURE_2_TRANSFER_DST_BIT = 32768,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 65536,
        FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT = 131072,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 262144,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 524288,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 1048576,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 2097152,
        FORMAT_FEATURE_2_DISJOINT_BIT = 4194304,
        FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT = 8388608,
        FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT = 2147483648,
        FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT = 4294967296,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT = 8589934592,
        FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR = 33554432,
        FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR = 67108864,
        FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 536870912,
        FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT = 16777216,
        FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 1073741824,
        FORMAT_FEATURE_2_RESERVED_44_BIT_EXT = 17592186044416,
        FORMAT_FEATURE_2_RESERVED_45_BIT_EXT = 35184372088832,
        FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR = 134217728,
        FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR = 268435456,
        FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV = 274877906944,
        FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM = 17179869184,
        FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM = 34359738368,
        FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM = 68719476736,
        FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM = 137438953472,
        FORMAT_FEATURE_2_RESERVED_39_BIT_EXT = 549755813888,
        FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV = 1099511627776,
        FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV = 2199023255552,
        FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV = 4398046511104,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR = 1,
        FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR = 2,
        FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR = 4,
        FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = 8,
        FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = 16,
        FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR = 32,
        FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR = 64,
        FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR = 128,
        FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR = 256,
        FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR = 512,
        FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR = 1024,
        FORMAT_FEATURE_2_BLIT_DST_BIT_KHR = 2048,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR = 4096,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 8192,
        FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR = 16384,
        FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR = 32768,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR = 65536,
        FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 131072,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 262144,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 524288,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 1048576,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 2097152,
        FORMAT_FEATURE_2_DISJOINT_BIT_KHR = 4194304,
        FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR = 8388608,
        FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR = 2147483648,
        FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR = 4294967296,
        FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR = 8589934592,
    };
    bitmask RenderingFlagBits {
        CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 1,
        SUSPENDING_BIT = 2,
        RESUMING_BIT = 4,
        ENABLE_LEGACY_DITHERING_BIT_EXT = 8,
        CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR = 1,
        SUSPENDING_BIT_KHR = 2,
        RESUMING_BIT_KHR = 4,
    };
    bitmask PipelineDepthStencilStateCreateFlagBits {
        RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 1,
        RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 2,
        RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM = 1,
        RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM = 2,
    };
    bitmask PipelineColorBlendStateCreateFlagBits {
        RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = 1,
        RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM = 1,
    };
    bitmask ImageCompressionFlagBitsEXT {
        DEFAULT_EXT = 0,
        FIXED_RATE_DEFAULT_EXT = 1,
        FIXED_RATE_EXPLICIT_EXT = 2,
        DISABLED_EXT = 4,
    };
    bitmask ImageCompressionFixedRateFlagBitsEXT {
        NONE_EXT = 0,
        _1BPC_BIT_EXT = 1,
        _2BPC_BIT_EXT = 2,
        _3BPC_BIT_EXT = 4,
        _4BPC_BIT_EXT = 8,
        _5BPC_BIT_EXT = 16,
        _6BPC_BIT_EXT = 32,
        _7BPC_BIT_EXT = 64,
        _8BPC_BIT_EXT = 128,
        _9BPC_BIT_EXT = 256,
        _10BPC_BIT_EXT = 512,
        _11BPC_BIT_EXT = 1024,
        _12BPC_BIT_EXT = 2048,
        _13BPC_BIT_EXT = 4096,
        _14BPC_BIT_EXT = 8192,
        _15BPC_BIT_EXT = 16384,
        _16BPC_BIT_EXT = 32768,
        _17BPC_BIT_EXT = 65536,
        _18BPC_BIT_EXT = 131072,
        _19BPC_BIT_EXT = 262144,
        _20BPC_BIT_EXT = 524288,
        _21BPC_BIT_EXT = 1048576,
        _22BPC_BIT_EXT = 2097152,
        _23BPC_BIT_EXT = 4194304,
        _24BPC_BIT_EXT = 8388608,
    };
    bitmask ExportMetalObjectTypeFlagBitsEXT {
        METAL_DEVICE_BIT_EXT = 1,
        METAL_COMMAND_QUEUE_BIT_EXT = 2,
        METAL_BUFFER_BIT_EXT = 4,
        METAL_TEXTURE_BIT_EXT = 8,
        METAL_IOSURFACE_BIT_EXT = 16,
        METAL_SHARED_EVENT_BIT_EXT = 32,
    };
    enum PipelineRobustnessBufferBehaviorEXT {
        DEVICE_DEFAULT_EXT = 0,
        DISABLED_EXT = 1,
        ROBUST_BUFFER_ACCESS_EXT = 2,
        ROBUST_BUFFER_ACCESS_2_EXT = 3,
    };
    enum PipelineRobustnessImageBehaviorEXT {
        DEVICE_DEFAULT_EXT = 0,
        DISABLED_EXT = 1,
        ROBUST_IMAGE_ACCESS_EXT = 2,
        ROBUST_IMAGE_ACCESS_2_EXT = 3,
    };
    bitmask DeviceAddressBindingFlagBitsEXT {
        INTERNAL_OBJECT_BIT_EXT = 1,
    };
    enum DeviceAddressBindingTypeEXT {
        BIND_EXT = 0,
        UNBIND_EXT = 1,
    };
    enum MicromapTypeEXT {
        OPACITY_MICROMAP_EXT = 0,
    };
    enum BuildMicromapModeEXT {
        BUILD_EXT = 0,
    };
    enum CopyMicromapModeEXT {
        CLONE_EXT = 0,
        SERIALIZE_EXT = 1,
        DESERIALIZE_EXT = 2,
        COMPACT_EXT = 3,
    };
    bitmask BuildMicromapFlagBitsEXT {
        PREFER_FAST_TRACE_BIT_EXT = 1,
        PREFER_FAST_BUILD_BIT_EXT = 2,
        ALLOW_COMPACTION_BIT_EXT = 4,
    };
    bitmask MicromapCreateFlagBitsEXT {
        DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 1,
    };
    enum OpacityMicromapFormatEXT {
        _2_STATE_EXT = 1,
        _4_STATE_EXT = 2,
    };
    enum OpacityMicromapSpecialIndexEXT {
        FULLY_TRANSPARENT_EXT = -1,
        FULLY_OPAQUE_EXT = -2,
        FULLY_UNKNOWN_TRANSPARENT_EXT = -3,
        FULLY_UNKNOWN_OPAQUE_EXT = -4,
    };
    enum DeviceFaultVendorBinaryHeaderVersionEXT {
        ONE_EXT = 1,
    };
    enum ColorSpaceKHR {
        SRGB_NONLINEAR_KHR = 0,
        DISPLAY_P3_NONLINEAR_EXT = 1000104001,
        EXTENDED_SRGB_LINEAR_EXT = 1000104002,
        DISPLAY_P3_LINEAR_EXT = 1000104003,
        DCI_P3_NONLINEAR_EXT = 1000104004,
        BT709_LINEAR_EXT = 1000104005,
        BT709_NONLINEAR_EXT = 1000104006,
        BT2020_LINEAR_EXT = 1000104007,
        HDR10_ST2084_EXT = 1000104008,
        DOLBYVISION_EXT = 1000104009,
        HDR10_HLG_EXT = 1000104010,
        ADOBERGB_LINEAR_EXT = 1000104011,
        ADOBERGB_NONLINEAR_EXT = 1000104012,
        PASS_THROUGH_EXT = 1000104013,
        EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
        DISPLAY_NATIVE_AMD = 1000213000,
        COLORSPACE_SRGB_NONLINEAR_KHR = 0,
        DCI_P3_LINEAR_EXT = 1000104003,
    };
    bitmask CompositeAlphaFlagBitsKHR {
        OPAQUE_BIT_KHR = 1,
        PRE_MULTIPLIED_BIT_KHR = 2,
        POST_MULTIPLIED_BIT_KHR = 4,
        INHERIT_BIT_KHR = 8,
    };
    bitmask DisplayPlaneAlphaFlagBitsKHR {
        OPAQUE_BIT_KHR = 1,
        GLOBAL_BIT_KHR = 2,
        PER_PIXEL_BIT_KHR = 4,
        PER_PIXEL_PREMULTIPLIED_BIT_KHR = 8,
    };
    enum PresentModeKHR {
        IMMEDIATE_KHR = 0,
        MAILBOX_KHR = 1,
        FIFO_KHR = 2,
        FIFO_RELAXED_KHR = 3,
        SHARED_DEMAND_REFRESH_KHR = 1000111000,
        SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
    };
    bitmask SurfaceTransformFlagBitsKHR {
        IDENTITY_BIT_KHR = 1,
        ROTATE_90_BIT_KHR = 2,
        ROTATE_180_BIT_KHR = 4,
        ROTATE_270_BIT_KHR = 8,
        HORIZONTAL_MIRROR_BIT_KHR = 16,
        HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 32,
        HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 64,
        HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 128,
        INHERIT_BIT_KHR = 256,
    };
    bitmask DebugReportFlagBitsEXT {
        INFORMATION_BIT_EXT = 1,
        WARNING_BIT_EXT = 2,
        PERFORMANCE_WARNING_BIT_EXT = 4,
        ERROR_BIT_EXT = 8,
        DEBUG_BIT_EXT = 16,
    };
    enum DebugReportObjectTypeEXT {
        UNKNOWN_EXT = 0,
        INSTANCE_EXT = 1,
        PHYSICAL_DEVICE_EXT = 2,
        DEVICE_EXT = 3,
        QUEUE_EXT = 4,
        SEMAPHORE_EXT = 5,
        COMMAND_BUFFER_EXT = 6,
        FENCE_EXT = 7,
        DEVICE_MEMORY_EXT = 8,
        BUFFER_EXT = 9,
        IMAGE_EXT = 10,
        EVENT_EXT = 11,
        QUERY_POOL_EXT = 12,
        BUFFER_VIEW_EXT = 13,
        IMAGE_VIEW_EXT = 14,
        SHADER_MODULE_EXT = 15,
        PIPELINE_CACHE_EXT = 16,
        PIPELINE_LAYOUT_EXT = 17,
        RENDER_PASS_EXT = 18,
        PIPELINE_EXT = 19,
        DESCRIPTOR_SET_LAYOUT_EXT = 20,
        SAMPLER_EXT = 21,
        DESCRIPTOR_POOL_EXT = 22,
        DESCRIPTOR_SET_EXT = 23,
        FRAMEBUFFER_EXT = 24,
        COMMAND_POOL_EXT = 25,
        SURFACE_KHR_EXT = 26,
        SWAPCHAIN_KHR_EXT = 27,
        DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
        DISPLAY_KHR_EXT = 29,
        DISPLAY_MODE_KHR_EXT = 30,
        VALIDATION_CACHE_EXT_EXT = 33,
        SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
        DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
        CU_MODULE_NVX_EXT = 1000029000,
        CU_FUNCTION_NVX_EXT = 1000029001,
        ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
        ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
        BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
        DEBUG_REPORT_EXT = 28,
        VALIDATION_CACHE_EXT = 33,
        DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = 1000085000,
        SAMPLER_YCBCR_CONVERSION_KHR_EXT = 1000156000,
    };
    enum DeviceMemoryReportEventTypeEXT {
        ALLOCATE_EXT = 0,
        FREE_EXT = 1,
        IMPORT_EXT = 2,
        UNIMPORT_EXT = 3,
        ALLOCATION_FAILED_EXT = 4,
    };
    enum RasterizationOrderAMD {
        STRICT_AMD = 0,
        RELAXED_AMD = 1,
    };
    bitmask ExternalMemoryHandleTypeFlagBitsNV {
        OPAQUE_WIN32_BIT_NV = 1,
        OPAQUE_WIN32_KMT_BIT_NV = 2,
        D3D11_IMAGE_BIT_NV = 4,
        D3D11_IMAGE_KMT_BIT_NV = 8,
    };
    bitmask ExternalMemoryFeatureFlagBitsNV {
        DEDICATED_ONLY_BIT_NV = 1,
        EXPORTABLE_BIT_NV = 2,
        IMPORTABLE_BIT_NV = 4,
    };
    enum ValidationCheckEXT {
        ALL_EXT = 0,
        SHADERS_EXT = 1,
    };
    enum ValidationFeatureEnableEXT {
        GPU_ASSISTED_EXT = 0,
        GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
        BEST_PRACTICES_EXT = 2,
        DEBUG_PRINTF_EXT = 3,
        SYNCHRONIZATION_VALIDATION_EXT = 4,
    };
    enum ValidationFeatureDisableEXT {
        ALL_EXT = 0,
        SHADERS_EXT = 1,
        THREAD_SAFETY_EXT = 2,
        API_PARAMETERS_EXT = 3,
        OBJECT_LIFETIMES_EXT = 4,
        CORE_CHECKS_EXT = 5,
        UNIQUE_HANDLES_EXT = 6,
        SHADER_VALIDATION_CACHE_EXT = 7,
    };
    bitmask ExternalMemoryHandleTypeFlagBits {
        OPAQUE_FD_BIT = 1,
        OPAQUE_WIN32_BIT = 2,
        OPAQUE_WIN32_KMT_BIT = 4,
        D3D11_TEXTURE_BIT = 8,
        D3D11_TEXTURE_KMT_BIT = 16,
        D3D12_HEAP_BIT = 32,
        D3D12_RESOURCE_BIT = 64,
        DMA_BUF_BIT_EXT = 512,
        ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 1024,
        HOST_ALLOCATION_BIT_EXT = 128,
        HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 256,
        ZIRCON_VMO_BIT_FUCHSIA = 2048,
        RDMA_ADDRESS_BIT_NV = 4096,
        RESERVED_13_BIT_NV = 8192,
        OPAQUE_FD_BIT_KHR = 1,
        OPAQUE_WIN32_BIT_KHR = 2,
        OPAQUE_WIN32_KMT_BIT_KHR = 4,
        D3D11_TEXTURE_BIT_KHR = 8,
        D3D11_TEXTURE_KMT_BIT_KHR = 16,
        D3D12_HEAP_BIT_KHR = 32,
        D3D12_RESOURCE_BIT_KHR = 64,
    };
    bitmask ExternalMemoryFeatureFlagBits {
        DEDICATED_ONLY_BIT = 1,
        EXPORTABLE_BIT = 2,
        IMPORTABLE_BIT = 4,
        DEDICATED_ONLY_BIT_KHR = 1,
        EXPORTABLE_BIT_KHR = 2,
        IMPORTABLE_BIT_KHR = 4,
    };
    bitmask ExternalSemaphoreHandleTypeFlagBits {
        OPAQUE_FD_BIT = 1,
        OPAQUE_WIN32_BIT = 2,
        OPAQUE_WIN32_KMT_BIT = 4,
        D3D12_FENCE_BIT = 8,
        SYNC_FD_BIT = 16,
        ZIRCON_EVENT_BIT_FUCHSIA = 128,
        RESERVED_5_BIT_NV = 32,
        D3D11_FENCE_BIT = 8,
        OPAQUE_FD_BIT_KHR = 1,
        OPAQUE_WIN32_BIT_KHR = 2,
        OPAQUE_WIN32_KMT_BIT_KHR = 4,
        D3D12_FENCE_BIT_KHR = 8,
        SYNC_FD_BIT_KHR = 16,
    };
    bitmask ExternalSemaphoreFeatureFlagBits {
        EXPORTABLE_BIT = 1,
        IMPORTABLE_BIT = 2,
        EXPORTABLE_BIT_KHR = 1,
        IMPORTABLE_BIT_KHR = 2,
    };
    bitmask SemaphoreImportFlagBits {
        TEMPORARY_BIT = 1,
        TEMPORARY_BIT_KHR = 1,
    };
    bitmask ExternalFenceHandleTypeFlagBits {
        OPAQUE_FD_BIT = 1,
        OPAQUE_WIN32_BIT = 2,
        OPAQUE_WIN32_KMT_BIT = 4,
        SYNC_FD_BIT = 8,
        RESERVED_4_BIT_NV = 16,
        RESERVED_5_BIT_NV = 32,
        OPAQUE_FD_BIT_KHR = 1,
        OPAQUE_WIN32_BIT_KHR = 2,
        OPAQUE_WIN32_KMT_BIT_KHR = 4,
        SYNC_FD_BIT_KHR = 8,
    };
    bitmask ExternalFenceFeatureFlagBits {
        EXPORTABLE_BIT = 1,
        IMPORTABLE_BIT = 2,
        EXPORTABLE_BIT_KHR = 1,
        IMPORTABLE_BIT_KHR = 2,
    };
    bitmask FenceImportFlagBits {
        TEMPORARY_BIT = 1,
        TEMPORARY_BIT_KHR = 1,
    };
    bitmask SurfaceCounterFlagBitsEXT {
        VBLANK_BIT_EXT = 1,
        VBLANK_EXT = 1,
    };
    enum DisplayPowerStateEXT {
        OFF_EXT = 0,
        SUSPEND_EXT = 1,
        ON_EXT = 2,
    };
    enum DeviceEventTypeEXT {
        DISPLAY_HOTPLUG_EXT = 0,
    };
    enum DisplayEventTypeEXT {
        FIRST_PIXEL_OUT_EXT = 0,
    };
    bitmask PeerMemoryFeatureFlagBits {
        COPY_SRC_BIT = 1,
        COPY_DST_BIT = 2,
        GENERIC_SRC_BIT = 4,
        GENERIC_DST_BIT = 8,
        COPY_SRC_BIT_KHR = 1,
        COPY_DST_BIT_KHR = 2,
        GENERIC_SRC_BIT_KHR = 4,
        GENERIC_DST_BIT_KHR = 8,
    };
    bitmask MemoryAllocateFlagBits {
        DEVICE_MASK_BIT = 1,
        DEVICE_ADDRESS_BIT = 2,
        DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 4,
        DEVICE_MASK_BIT_KHR = 1,
        DEVICE_ADDRESS_BIT_KHR = 2,
        DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 4,
    };
    bitmask DeviceGroupPresentModeFlagBitsKHR {
        LOCAL_BIT_KHR = 1,
        REMOTE_BIT_KHR = 2,
        SUM_BIT_KHR = 4,
        LOCAL_MULTI_DEVICE_BIT_KHR = 8,
    };
    bitmask SwapchainCreateFlagBitsKHR {
        SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 1,
        PROTECTED_BIT_KHR = 2,
        MUTABLE_FORMAT_BIT_KHR = 4,
        RESERVED_3_BIT_SEC = 8,
    };
    bitmask SubgroupFeatureFlagBits {
        BASIC_BIT = 1,
        VOTE_BIT = 2,
        ARITHMETIC_BIT = 4,
        BALLOT_BIT = 8,
        SHUFFLE_BIT = 16,
        SHUFFLE_RELATIVE_BIT = 32,
        CLUSTERED_BIT = 64,
        QUAD_BIT = 128,
        PARTITIONED_BIT_NV = 256,
    };
    enum TessellationDomainOrigin {
        UPPER_LEFT = 0,
        LOWER_LEFT = 1,
        UPPER_LEFT_KHR = 0,
        LOWER_LEFT_KHR = 1,
    };
    enum SamplerYcbcrModelConversion {
        RGB_IDENTITY = 0,
        YCBCR_IDENTITY = 1,
        YCBCR_709 = 2,
        YCBCR_601 = 3,
        YCBCR_2020 = 4,
        RGB_IDENTITY_KHR = 0,
        YCBCR_IDENTITY_KHR = 1,
        YCBCR_709_KHR = 2,
        YCBCR_601_KHR = 3,
        YCBCR_2020_KHR = 4,
    };
    enum SamplerYcbcrRange {
        ITU_FULL = 0,
        ITU_NARROW = 1,
        ITU_FULL_KHR = 0,
        ITU_NARROW_KHR = 1,
    };
    enum ChromaLocation {
        COSITED_EVEN = 0,
        MIDPOINT = 1,
        COSITED_EVEN_KHR = 0,
        MIDPOINT_KHR = 1,
    };
    enum SamplerReductionMode {
        WEIGHTED_AVERAGE = 0,
        MIN = 1,
        MAX = 2,
        WEIGHTED_AVERAGE_EXT = 0,
        MIN_EXT = 1,
        MAX_EXT = 2,
    };
    enum BlendOverlapEXT {
        UNCORRELATED_EXT = 0,
        DISJOINT_EXT = 1,
        CONJOINT_EXT = 2,
    };
    bitmask DebugUtilsMessageSeverityFlagBitsEXT {
        VERBOSE_BIT_EXT = 1,
        INFO_BIT_EXT = 16,
        WARNING_BIT_EXT = 256,
        ERROR_BIT_EXT = 4096,
    };
    bitmask DebugUtilsMessageTypeFlagBitsEXT {
        GENERAL_BIT_EXT = 1,
        VALIDATION_BIT_EXT = 2,
        PERFORMANCE_BIT_EXT = 4,
        DEVICE_ADDRESS_BINDING_BIT_EXT = 8,
    };
    enum FullScreenExclusiveEXT {
        DEFAULT_EXT = 0,
        ALLOWED_EXT = 1,
        DISALLOWED_EXT = 2,
        APPLICATION_CONTROLLED_EXT = 3,
    };
    enum ShaderFloatControlsIndependence {
        _32_BIT_ONLY = 0,
        ALL = 1,
        NONE = 2,
        _32_BIT_ONLY_KHR = 0,
        ALL_KHR = 1,
        NONE_KHR = 2,
    };
    bitmask SwapchainImageUsageFlagBitsANDROID {
        SHARED_BIT_ANDROID = 1,
    };
    enum FragmentShadingRateCombinerOpKHR {
        KEEP_KHR = 0,
        REPLACE_KHR = 1,
        MIN_KHR = 2,
        MAX_KHR = 3,
        MUL_KHR = 4,
    };
    bitmask SubmitFlagBits {
        PROTECTED_BIT = 1,
        PROTECTED_BIT_KHR = 1,
    };
    bitmask GraphicsPipelineLibraryFlagBitsEXT {
        VERTEX_INPUT_INTERFACE_BIT_EXT = 1,
        PRE_RASTERIZATION_SHADERS_BIT_EXT = 2,
        FRAGMENT_SHADER_BIT_EXT = 4,
        FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 8,
    };
    bitmask OpticalFlowGridSizeFlagBitsNV {
        UNKNOWN_NV = 0,
        _1X1_BIT_NV = 1,
        _2X2_BIT_NV = 2,
        _4X4_BIT_NV = 4,
        _8X8_BIT_NV = 8,
    };
    bitmask OpticalFlowUsageFlagBitsNV {
        UNKNOWN_NV = 0,
        INPUT_BIT_NV = 1,
        OUTPUT_BIT_NV = 2,
        HINT_BIT_NV = 4,
        COST_BIT_NV = 8,
        GLOBAL_FLOW_BIT_NV = 16,
    };
    enum OpticalFlowPerformanceLevelNV {
        UNKNOWN_NV = 0,
        SLOW_NV = 1,
        MEDIUM_NV = 2,
        FAST_NV = 3,
    };
    enum OpticalFlowSessionBindingPointNV {
        UNKNOWN_NV = 0,
        INPUT_NV = 1,
        REFERENCE_NV = 2,
        HINT_NV = 3,
        FLOW_VECTOR_NV = 4,
        BACKWARD_FLOW_VECTOR_NV = 5,
        COST_NV = 6,
        BACKWARD_COST_NV = 7,
        GLOBAL_FLOW_NV = 8,
    };
    bitmask OpticalFlowSessionCreateFlagBitsNV {
        ENABLE_HINT_BIT_NV = 1,
        ENABLE_COST_BIT_NV = 2,
        ENABLE_GLOBAL_FLOW_BIT_NV = 4,
        ALLOW_REGIONS_BIT_NV = 8,
        BOTH_DIRECTIONS_BIT_NV = 16,
    };
    bitmask OpticalFlowExecuteFlagBitsNV {
        DISABLE_TEMPORAL_HINTS_BIT_NV = 1,
    };
    enum DeviceFaultAddressTypeEXT {
        NONE_EXT = 0,
        READ_INVALID_EXT = 1,
        WRITE_INVALID_EXT = 2,
        EXECUTE_INVALID_EXT = 3,
        INSTRUCTION_POINTER_UNKNOWN_EXT = 4,
        INSTRUCTION_POINTER_INVALID_EXT = 5,
        INSTRUCTION_POINTER_FAULT_EXT = 6,
    };
    enum VendorId {
        VIV = 65537,
        VSI = 65538,
        KAZAN = 65539,
        CODEPLAY = 65540,
        MESA = 65541,
        POCL = 65542,
    };
    enum DriverId {
        AMD_PROPRIETARY = 1,
        AMD_OPEN_SOURCE = 2,
        MESA_RADV = 3,
        NVIDIA_PROPRIETARY = 4,
        INTEL_PROPRIETARY_WINDOWS = 5,
        INTEL_OPEN_SOURCE_MESA = 6,
        IMAGINATION_PROPRIETARY = 7,
        QUALCOMM_PROPRIETARY = 8,
        ARM_PROPRIETARY = 9,
        GOOGLE_SWIFTSHADER = 10,
        GGP_PROPRIETARY = 11,
        BROADCOM_PROPRIETARY = 12,
        MESA_LLVMPIPE = 13,
        MOLTENVK = 14,
        COREAVI_PROPRIETARY = 15,
        JUICE_PROPRIETARY = 16,
        VERISILICON_PROPRIETARY = 17,
        MESA_TURNIP = 18,
        MESA_V3DV = 19,
        MESA_PANVK = 20,
        SAMSUNG_PROPRIETARY = 21,
        MESA_VENUS = 22,
        MESA_DOZEN = 23,
        AMD_PROPRIETARY_KHR = 1,
        AMD_OPEN_SOURCE_KHR = 2,
        MESA_RADV_KHR = 3,
        NVIDIA_PROPRIETARY_KHR = 4,
        INTEL_PROPRIETARY_WINDOWS_KHR = 5,
        INTEL_OPEN_SOURCE_MESA_KHR = 6,
        IMAGINATION_PROPRIETARY_KHR = 7,
        QUALCOMM_PROPRIETARY_KHR = 8,
        ARM_PROPRIETARY_KHR = 9,
        GOOGLE_SWIFTSHADER_KHR = 10,
        GGP_PROPRIETARY_KHR = 11,
        BROADCOM_PROPRIETARY_KHR = 12,
    };
    enum ShadingRatePaletteEntryNV {
        NO_INVOCATIONS_NV = 0,
        _16_INVOCATIONS_PER_PIXEL_NV = 1,
        _8_INVOCATIONS_PER_PIXEL_NV = 2,
        _4_INVOCATIONS_PER_PIXEL_NV = 3,
        _2_INVOCATIONS_PER_PIXEL_NV = 4,
        _1_INVOCATION_PER_PIXEL_NV = 5,
        _1_INVOCATION_PER_2X1_PIXELS_NV = 6,
        _1_INVOCATION_PER_1X2_PIXELS_NV = 7,
        _1_INVOCATION_PER_2X2_PIXELS_NV = 8,
        _1_INVOCATION_PER_4X2_PIXELS_NV = 9,
        _1_INVOCATION_PER_2X4_PIXELS_NV = 10,
        _1_INVOCATION_PER_4X4_PIXELS_NV = 11,
    };
    enum CoarseSampleOrderTypeNV {
        DEFAULT_NV = 0,
        CUSTOM_NV = 1,
        PIXEL_MAJOR_NV = 2,
        SAMPLE_MAJOR_NV = 3,
    };
    enum PipelineExecutableStatisticFormatKHR {
        BOOL32_KHR = 0,
        INT64_KHR = 1,
        UINT64_KHR = 2,
        FLOAT64_KHR = 3,
    };
    bitmask VideoCodecOperationFlagBitsKHR {
        NONE_KHR = 0,
        ENCODE_H264_BIT_EXT = 65536,
        ENCODE_H265_BIT_EXT = 131072,
        DECODE_H264_BIT_EXT = 1,
        DECODE_H265_BIT_EXT = 2,
    };
    bitmask VideoChromaSubsamplingFlagBitsKHR {
        INVALID_KHR = 0,
        MONOCHROME_BIT_KHR = 1,
        _420_BIT_KHR = 2,
        _422_BIT_KHR = 4,
        _444_BIT_KHR = 8,
    };
    bitmask VideoComponentBitDepthFlagBitsKHR {
        INVALID_KHR = 0,
        _8_BIT_KHR = 1,
        _10_BIT_KHR = 4,
        _12_BIT_KHR = 16,
    };
    bitmask VideoCapabilityFlagBitsKHR {
        PROTECTED_CONTENT_BIT_KHR = 1,
        SEPARATE_REFERENCE_IMAGES_BIT_KHR = 2,
    };
    bitmask VideoSessionCreateFlagBitsKHR {
        PROTECTED_CONTENT_BIT_KHR = 1,
    };
    bitmask VideoCodingControlFlagBitsKHR {
        RESET_BIT_KHR = 1,
        ENCODE_RATE_CONTROL_BIT_KHR = 2,
        ENCODE_RATE_CONTROL_LAYER_BIT_KHR = 4,
    };
    enum QueryResultStatusKHR {
        ERROR_KHR = -1,
        NOT_READY_KHR = 0,
        COMPLETE_KHR = 1,
    };
    bitmask VideoDecodeUsageFlagBitsKHR {
        DEFAULT_KHR = 0,
        TRANSCODING_BIT_KHR = 1,
        OFFLINE_BIT_KHR = 2,
        STREAMING_BIT_KHR = 4,
    };
    bitmask VideoDecodeCapabilityFlagBitsKHR {
        DPB_AND_OUTPUT_COINCIDE_BIT_KHR = 1,
        DPB_AND_OUTPUT_DISTINCT_BIT_KHR = 2,
    };
    bitmask VideoDecodeH264PictureLayoutFlagBitsEXT {
        VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_EXT = 0,
        VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_EXT = 1,
        VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_EXT = 2,
    };
    bitmask VideoEncodeUsageFlagBitsKHR {
        DEFAULT_KHR = 0,
        TRANSCODING_BIT_KHR = 1,
        STREAMING_BIT_KHR = 2,
        RECORDING_BIT_KHR = 4,
        CONFERENCING_BIT_KHR = 8,
    };
    bitmask VideoEncodeContentFlagBitsKHR {
        DEFAULT_KHR = 0,
        CAMERA_BIT_KHR = 1,
        DESKTOP_BIT_KHR = 2,
        RENDERED_BIT_KHR = 4,
    };
    enum VideoEncodeTuningModeKHR {
        DEFAULT_KHR = 0,
        HIGH_QUALITY_KHR = 1,
        LOW_LATENCY_KHR = 2,
        ULTRA_LOW_LATENCY_KHR = 3,
        LOSSLESS_KHR = 4,
    };
    bitmask VideoEncodeCapabilityFlagBitsKHR {
        PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = 1,
    };
    bitmask VideoEncodeRateControlModeFlagBitsKHR {
        NONE_BIT_KHR = 0,
        CBR_BIT_KHR = 1,
        VBR_BIT_KHR = 2,
    };
    bitmask VideoEncodeH264CapabilityFlagBitsEXT {
        VIDEO_ENCODE_H264_CAPABILITY_DIRECT_8X8_INFERENCE_ENABLED_BIT_EXT = 1,
        VIDEO_ENCODE_H264_CAPABILITY_DIRECT_8X8_INFERENCE_DISABLED_BIT_EXT = 2,
        VIDEO_ENCODE_H264_CAPABILITY_SEPARATE_COLOUR_PLANE_BIT_EXT = 4,
        VIDEO_ENCODE_H264_CAPABILITY_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_BIT_EXT = 8,
        VIDEO_ENCODE_H264_CAPABILITY_SCALING_LISTS_BIT_EXT = 16,
        VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = 32,
        VIDEO_ENCODE_H264_CAPABILITY_CHROMA_QP_OFFSET_BIT_EXT = 64,
        VIDEO_ENCODE_H264_CAPABILITY_SECOND_CHROMA_QP_OFFSET_BIT_EXT = 128,
        VIDEO_ENCODE_H264_CAPABILITY_PIC_INIT_QP_MINUS26_BIT_EXT = 256,
        VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_PRED_BIT_EXT = 512,
        VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_BIPRED_EXPLICIT_BIT_EXT = 1024,
        VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_BIPRED_IMPLICIT_BIT_EXT = 2048,
        VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_PRED_NO_TABLE_BIT_EXT = 4096,
        VIDEO_ENCODE_H264_CAPABILITY_TRANSFORM_8X8_BIT_EXT = 8192,
        VIDEO_ENCODE_H264_CAPABILITY_CABAC_BIT_EXT = 16384,
        VIDEO_ENCODE_H264_CAPABILITY_CAVLC_BIT_EXT = 32768,
        VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_DISABLED_BIT_EXT = 65536,
        VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_ENABLED_BIT_EXT = 131072,
        VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_PARTIAL_BIT_EXT = 262144,
        VIDEO_ENCODE_H264_CAPABILITY_DISABLE_DIRECT_SPATIAL_MV_PRED_BIT_EXT = 524288,
        VIDEO_ENCODE_H264_CAPABILITY_MULTIPLE_SLICE_PER_FRAME_BIT_EXT = 1048576,
        VIDEO_ENCODE_H264_CAPABILITY_SLICE_MB_COUNT_BIT_EXT = 2097152,
        VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT = 4194304,
        VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT = 8388608,
        VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = 16777216,
    };
    bitmask VideoEncodeH264InputModeFlagBitsEXT {
        VIDEO_ENCODE_H264_INPUT_MODE_FRAME_BIT_EXT = 1,
        VIDEO_ENCODE_H264_INPUT_MODE_SLICE_BIT_EXT = 2,
        VIDEO_ENCODE_H264_INPUT_MODE_NON_VCL_BIT_EXT = 4,
    };
    bitmask VideoEncodeH264OutputModeFlagBitsEXT {
        VIDEO_ENCODE_H264_OUTPUT_MODE_FRAME_BIT_EXT = 1,
        VIDEO_ENCODE_H264_OUTPUT_MODE_SLICE_BIT_EXT = 2,
        VIDEO_ENCODE_H264_OUTPUT_MODE_NON_VCL_BIT_EXT = 4,
    };
    enum VideoEncodeH264RateControlStructureEXT {
        VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_UNKNOWN_EXT = 0,
        VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_FLAT_EXT = 1,
        VIDEO_ENCODE_H264_RATE_CONTROL_STRUCTURE_DYADIC_EXT = 2,
    };
    bitmask VideoEncodeH265CapabilityFlagBitsEXT {
        VIDEO_ENCODE_H265_CAPABILITY_SEPARATE_COLOUR_PLANE_BIT_EXT = 1,
        VIDEO_ENCODE_H265_CAPABILITY_SCALING_LISTS_BIT_EXT = 2,
        VIDEO_ENCODE_H265_CAPABILITY_SAMPLE_ADAPTIVE_OFFSET_ENABLED_BIT_EXT = 4,
        VIDEO_ENCODE_H265_CAPABILITY_PCM_ENABLE_BIT_EXT = 8,
        VIDEO_ENCODE_H265_CAPABILITY_SPS_TEMPORAL_MVP_ENABLED_BIT_EXT = 16,
        VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = 32,
        VIDEO_ENCODE_H265_CAPABILITY_INIT_QP_MINUS26_BIT_EXT = 64,
        VIDEO_ENCODE_H265_CAPABILITY_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT = 128,
        VIDEO_ENCODE_H265_CAPABILITY_SIGN_DATA_HIDING_ENABLED_BIT_EXT = 256,
        VIDEO_ENCODE_H265_CAPABILITY_TRANSFORM_SKIP_ENABLED_BIT_EXT = 512,
        VIDEO_ENCODE_H265_CAPABILITY_TRANSFORM_SKIP_DISABLED_BIT_EXT = 1024,
        VIDEO_ENCODE_H265_CAPABILITY_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_BIT_EXT = 2048,
        VIDEO_ENCODE_H265_CAPABILITY_WEIGHTED_PRED_BIT_EXT = 4096,
        VIDEO_ENCODE_H265_CAPABILITY_WEIGHTED_BIPRED_BIT_EXT = 8192,
        VIDEO_ENCODE_H265_CAPABILITY_WEIGHTED_PRED_NO_TABLE_BIT_EXT = 16384,
        VIDEO_ENCODE_H265_CAPABILITY_TRANSQUANT_BYPASS_ENABLED_BIT_EXT = 32768,
        VIDEO_ENCODE_H265_CAPABILITY_ENTROPY_CODING_SYNC_ENABLED_BIT_EXT = 65536,
        VIDEO_ENCODE_H265_CAPABILITY_DEBLOCKING_FILTER_OVERRIDE_ENABLED_BIT_EXT = 131072,
        VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILE_PER_FRAME_BIT_EXT = 262144,
        VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_PER_TILE_BIT_EXT = 524288,
        VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILE_PER_SLICE_BIT_EXT = 1048576,
        VIDEO_ENCODE_H265_CAPABILITY_SLICE_SEGMENT_CTB_COUNT_BIT_EXT = 2097152,
        VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT = 4194304,
        VIDEO_ENCODE_H265_CAPABILITY_DEPENDENT_SLICE_SEGMENT_BIT_EXT = 8388608,
        VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT = 16777216,
        VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = 33554432,
    };
    bitmask VideoEncodeH265InputModeFlagBitsEXT {
        VIDEO_ENCODE_H265_INPUT_MODE_FRAME_BIT_EXT = 1,
        VIDEO_ENCODE_H265_INPUT_MODE_SLICE_SEGMENT_BIT_EXT = 2,
        VIDEO_ENCODE_H265_INPUT_MODE_NON_VCL_BIT_EXT = 4,
    };
    bitmask VideoEncodeH265OutputModeFlagBitsEXT {
        VIDEO_ENCODE_H265_OUTPUT_MODE_FRAME_BIT_EXT = 1,
        VIDEO_ENCODE_H265_OUTPUT_MODE_SLICE_SEGMENT_BIT_EXT = 2,
        VIDEO_ENCODE_H265_OUTPUT_MODE_NON_VCL_BIT_EXT = 4,
    };
    enum VideoEncodeH265RateControlStructureEXT {
        VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_UNKNOWN_EXT = 0,
        VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_FLAT_EXT = 1,
        VIDEO_ENCODE_H265_RATE_CONTROL_STRUCTURE_DYADIC_EXT = 2,
    };
    bitmask VideoEncodeH265CtbSizeFlagBitsEXT {
        VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT = 1,
        VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT = 2,
        VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT = 4,
    };
    bitmask VideoEncodeH265TransformBlockSizeFlagBitsEXT {
        VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_EXT = 1,
        VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_EXT = 2,
        VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_EXT = 4,
        VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_EXT = 8,
    };
    enum AccelerationStructureMotionInstanceTypeNV {
        STATIC_NV = 0,
        MATRIX_MOTION_NV = 1,
        SRT_MOTION_NV = 2,
    };
}

impl_aliases! {
    MTLDevice_id = *mut c_void;
    MTLCommandQueue_id = *mut c_void;
    MTLBuffer_id = *mut c_void;
    MTLTexture_id = *mut c_void;
    MTLSharedEvent_id = *mut c_void;
    IOSurfaceRef = *mut IOSurface;
    Display = u32;
    VisualID = u32;
    Window = u32;
    RROutput = c_ulong;
    DWORD = c_int;
    HANDLE = c_int;
    HINSTANCE = c_int;
    HMONITOR = c_int;
    HWND = c_int;
    LPCWSTR = c_int;
    SECURITY_ATTRIBUTES = c_int;
    xcb_connection_t = c_int;
    xcb_window_t = c_int;
    xcb_visualid_t = c_int;
    zx_handle_t = c_int;
    GgpStreamDescriptor = c_int;
    GgpFrameToken = c_int;
    SampleMask = u32;
    Bool32 = u32;
    Flags = u32;
    Flags64 = u64;
    DeviceSize = u64;
    DeviceAddress = u64;
    FramebufferCreateFlags = crate::data::FramebufferCreateFlagBits;
    RenderPassCreateFlags = crate::data::RenderPassCreateFlagBits;
    SamplerCreateFlags = crate::data::SamplerCreateFlagBits;
    PipelineLayoutCreateFlags = crate::data::PipelineLayoutCreateFlagBits;
    PipelineCacheCreateFlags = crate::data::PipelineCacheCreateFlagBits;
    PipelineDepthStencilStateCreateFlags = crate::data::PipelineDepthStencilStateCreateFlagBits;
    PipelineColorBlendStateCreateFlags = crate::data::PipelineColorBlendStateCreateFlagBits;
    PipelineShaderStageCreateFlags = crate::data::PipelineShaderStageCreateFlagBits;
    DescriptorSetLayoutCreateFlags = crate::data::DescriptorSetLayoutCreateFlagBits;
    InstanceCreateFlags = crate::data::InstanceCreateFlagBits;
    DeviceQueueCreateFlags = crate::data::DeviceQueueCreateFlagBits;
    QueueFlags = crate::data::QueueFlagBits;
    MemoryPropertyFlags = crate::data::MemoryPropertyFlagBits;
    MemoryHeapFlags = crate::data::MemoryHeapFlagBits;
    AccessFlags = crate::data::AccessFlagBits;
    BufferUsageFlags = crate::data::BufferUsageFlagBits;
    BufferCreateFlags = crate::data::BufferCreateFlagBits;
    ShaderStageFlags = crate::data::ShaderStageFlagBits;
    ImageUsageFlags = crate::data::ImageUsageFlagBits;
    ImageCreateFlags = crate::data::ImageCreateFlagBits;
    ImageViewCreateFlags = crate::data::ImageViewCreateFlagBits;
    PipelineCreateFlags = crate::data::PipelineCreateFlagBits;
    ColorComponentFlags = crate::data::ColorComponentFlagBits;
    FenceCreateFlags = crate::data::FenceCreateFlagBits;
    FormatFeatureFlags = crate::data::FormatFeatureFlagBits;
    QueryControlFlags = crate::data::QueryControlFlagBits;
    QueryResultFlags = crate::data::QueryResultFlagBits;
    EventCreateFlags = crate::data::EventCreateFlagBits;
    CommandPoolCreateFlags = crate::data::CommandPoolCreateFlagBits;
    CommandPoolResetFlags = crate::data::CommandPoolResetFlagBits;
    CommandBufferResetFlags = crate::data::CommandBufferResetFlagBits;
    CommandBufferUsageFlags = crate::data::CommandBufferUsageFlagBits;
    QueryPipelineStatisticFlags = crate::data::QueryPipelineStatisticFlagBits;
    ImageAspectFlags = crate::data::ImageAspectFlagBits;
    SparseMemoryBindFlags = crate::data::SparseMemoryBindFlagBits;
    SparseImageFormatFlags = crate::data::SparseImageFormatFlagBits;
    SubpassDescriptionFlags = crate::data::SubpassDescriptionFlagBits;
    PipelineStageFlags = crate::data::PipelineStageFlagBits;
    SampleCountFlags = crate::data::SampleCountFlagBits;
    AttachmentDescriptionFlags = crate::data::AttachmentDescriptionFlagBits;
    StencilFaceFlags = crate::data::StencilFaceFlagBits;
    CullModeFlags = crate::data::CullModeFlagBits;
    DescriptorPoolCreateFlags = crate::data::DescriptorPoolCreateFlagBits;
    DependencyFlags = crate::data::DependencyFlagBits;
    SubgroupFeatureFlags = crate::data::SubgroupFeatureFlagBits;
    IndirectCommandsLayoutUsageFlagsNV = crate::data::IndirectCommandsLayoutUsageFlagBitsNV;
    IndirectStateFlagsNV = crate::data::IndirectStateFlagBitsNV;
    GeometryFlagsKHR = crate::data::GeometryFlagBitsKHR;
    GeometryFlagsNV = crate::data::GeometryFlagsKHR;
    GeometryInstanceFlagsKHR = crate::data::GeometryInstanceFlagBitsKHR;
    GeometryInstanceFlagsNV = crate::data::GeometryInstanceFlagsKHR;
    BuildAccelerationStructureFlagsKHR = crate::data::BuildAccelerationStructureFlagBitsKHR;
    BuildAccelerationStructureFlagsNV = crate::data::BuildAccelerationStructureFlagsKHR;
    PrivateDataSlotCreateFlagsEXT = crate::data::PrivateDataSlotCreateFlags;
    AccelerationStructureCreateFlagsKHR = crate::data::AccelerationStructureCreateFlagBitsKHR;
    DescriptorUpdateTemplateCreateFlagsKHR = crate::data::DescriptorUpdateTemplateCreateFlags;
    PipelineCreationFeedbackFlags = crate::data::PipelineCreationFeedbackFlagBits;
    PipelineCreationFeedbackFlagsEXT = crate::data::PipelineCreationFeedbackFlags;
    PerformanceCounterDescriptionFlagsKHR = crate::data::PerformanceCounterDescriptionFlagBitsKHR;
    AcquireProfilingLockFlagsKHR = crate::data::AcquireProfilingLockFlagBitsKHR;
    SemaphoreWaitFlags = crate::data::SemaphoreWaitFlagBits;
    SemaphoreWaitFlagsKHR = crate::data::SemaphoreWaitFlags;
    PipelineCompilerControlFlagsAMD = crate::data::PipelineCompilerControlFlagBitsAMD;
    ShaderCorePropertiesFlagsAMD = crate::data::ShaderCorePropertiesFlagBitsAMD;
    DeviceDiagnosticsConfigFlagsNV = crate::data::DeviceDiagnosticsConfigFlagBitsNV;
    AccessFlags2KHR = crate::data::AccessFlags2;
    PipelineStageFlags2KHR = crate::data::PipelineStageFlags2;
    FormatFeatureFlags2KHR = crate::data::FormatFeatureFlags2;
    RenderingFlags = crate::data::RenderingFlagBits;
    RenderingFlagsKHR = crate::data::RenderingFlags;
    BuildMicromapFlagsEXT = crate::data::BuildMicromapFlagBitsEXT;
    MicromapCreateFlagsEXT = crate::data::MicromapCreateFlagBitsEXT;
    CompositeAlphaFlagsKHR = crate::data::CompositeAlphaFlagBitsKHR;
    DisplayPlaneAlphaFlagsKHR = crate::data::DisplayPlaneAlphaFlagBitsKHR;
    SurfaceTransformFlagsKHR = crate::data::SurfaceTransformFlagBitsKHR;
    SwapchainCreateFlagsKHR = crate::data::SwapchainCreateFlagBitsKHR;
    PeerMemoryFeatureFlags = crate::data::PeerMemoryFeatureFlagBits;
    PeerMemoryFeatureFlagsKHR = crate::data::PeerMemoryFeatureFlags;
    MemoryAllocateFlags = crate::data::MemoryAllocateFlagBits;
    MemoryAllocateFlagsKHR = crate::data::MemoryAllocateFlags;
    DeviceGroupPresentModeFlagsKHR = crate::data::DeviceGroupPresentModeFlagBitsKHR;
    DebugReportFlagsEXT = crate::data::DebugReportFlagBitsEXT;
    CommandPoolTrimFlagsKHR = crate::data::CommandPoolTrimFlags;
    ExternalMemoryHandleTypeFlagsNV = crate::data::ExternalMemoryHandleTypeFlagBitsNV;
    ExternalMemoryFeatureFlagsNV = crate::data::ExternalMemoryFeatureFlagBitsNV;
    ExternalMemoryHandleTypeFlags = crate::data::ExternalMemoryHandleTypeFlagBits;
    ExternalMemoryHandleTypeFlagsKHR = crate::data::ExternalMemoryHandleTypeFlags;
    ExternalMemoryFeatureFlags = crate::data::ExternalMemoryFeatureFlagBits;
    ExternalMemoryFeatureFlagsKHR = crate::data::ExternalMemoryFeatureFlags;
    ExternalSemaphoreHandleTypeFlags = crate::data::ExternalSemaphoreHandleTypeFlagBits;
    ExternalSemaphoreHandleTypeFlagsKHR = crate::data::ExternalSemaphoreHandleTypeFlags;
    ExternalSemaphoreFeatureFlags = crate::data::ExternalSemaphoreFeatureFlagBits;
    ExternalSemaphoreFeatureFlagsKHR = crate::data::ExternalSemaphoreFeatureFlags;
    SemaphoreImportFlags = crate::data::SemaphoreImportFlagBits;
    SemaphoreImportFlagsKHR = crate::data::SemaphoreImportFlags;
    ExternalFenceHandleTypeFlags = crate::data::ExternalFenceHandleTypeFlagBits;
    ExternalFenceHandleTypeFlagsKHR = crate::data::ExternalFenceHandleTypeFlags;
    ExternalFenceFeatureFlags = crate::data::ExternalFenceFeatureFlagBits;
    ExternalFenceFeatureFlagsKHR = crate::data::ExternalFenceFeatureFlags;
    FenceImportFlags = crate::data::FenceImportFlagBits;
    FenceImportFlagsKHR = crate::data::FenceImportFlags;
    SurfaceCounterFlagsEXT = crate::data::SurfaceCounterFlagBitsEXT;
    DebugUtilsMessageSeverityFlagsEXT = crate::data::DebugUtilsMessageSeverityFlagBitsEXT;
    DebugUtilsMessageTypeFlagsEXT = crate::data::DebugUtilsMessageTypeFlagBitsEXT;
    DescriptorBindingFlags = crate::data::DescriptorBindingFlagBits;
    DescriptorBindingFlagsEXT = crate::data::DescriptorBindingFlags;
    ConditionalRenderingFlagsEXT = crate::data::ConditionalRenderingFlagBitsEXT;
    ResolveModeFlags = crate::data::ResolveModeFlagBits;
    ResolveModeFlagsKHR = crate::data::ResolveModeFlags;
    SwapchainImageUsageFlagsANDROID = crate::data::SwapchainImageUsageFlagBitsANDROID;
    ToolPurposeFlags = crate::data::ToolPurposeFlagBits;
    ToolPurposeFlagsEXT = crate::data::ToolPurposeFlags;
    SubmitFlags = crate::data::SubmitFlagBits;
    SubmitFlagsKHR = crate::data::SubmitFlags;
    ImageConstraintsInfoFlagsFUCHSIA = crate::data::ImageConstraintsInfoFlagBitsFUCHSIA;
    GraphicsPipelineLibraryFlagsEXT = crate::data::GraphicsPipelineLibraryFlagBitsEXT;
    ImageCompressionFlagsEXT = crate::data::ImageCompressionFlagBitsEXT;
    ImageCompressionFixedRateFlagsEXT = crate::data::ImageCompressionFixedRateFlagBitsEXT;
    ExportMetalObjectTypeFlagsEXT = crate::data::ExportMetalObjectTypeFlagBitsEXT;
    DeviceAddressBindingFlagsEXT = crate::data::DeviceAddressBindingFlagBitsEXT;
    OpticalFlowGridSizeFlagsNV = crate::data::OpticalFlowGridSizeFlagBitsNV;
    OpticalFlowUsageFlagsNV = crate::data::OpticalFlowUsageFlagBitsNV;
    OpticalFlowSessionCreateFlagsNV = crate::data::OpticalFlowSessionCreateFlagBitsNV;
    OpticalFlowExecuteFlagsNV = crate::data::OpticalFlowExecuteFlagBitsNV;
    VideoCodecOperationFlagsKHR = crate::data::VideoCodecOperationFlagBitsKHR;
    VideoCapabilityFlagsKHR = crate::data::VideoCapabilityFlagBitsKHR;
    VideoSessionCreateFlagsKHR = crate::data::VideoSessionCreateFlagBitsKHR;
    VideoCodingControlFlagsKHR = crate::data::VideoCodingControlFlagBitsKHR;
    VideoDecodeUsageFlagsKHR = crate::data::VideoDecodeUsageFlagBitsKHR;
    VideoDecodeCapabilityFlagsKHR = crate::data::VideoDecodeCapabilityFlagBitsKHR;
    VideoDecodeH264PictureLayoutFlagsEXT = crate::data::VideoDecodeH264PictureLayoutFlagBitsEXT;
    VideoEncodeUsageFlagsKHR = crate::data::VideoEncodeUsageFlagBitsKHR;
    VideoEncodeContentFlagsKHR = crate::data::VideoEncodeContentFlagBitsKHR;
    VideoEncodeCapabilityFlagsKHR = crate::data::VideoEncodeCapabilityFlagBitsKHR;
    VideoEncodeRateControlModeFlagsKHR = crate::data::VideoEncodeRateControlModeFlagBitsKHR;
    VideoChromaSubsamplingFlagsKHR = crate::data::VideoChromaSubsamplingFlagBitsKHR;
    VideoComponentBitDepthFlagsKHR = crate::data::VideoComponentBitDepthFlagBitsKHR;
    VideoEncodeH264CapabilityFlagsEXT = crate::data::VideoEncodeH264CapabilityFlagBitsEXT;
    VideoEncodeH264InputModeFlagsEXT = crate::data::VideoEncodeH264InputModeFlagBitsEXT;
    VideoEncodeH264OutputModeFlagsEXT = crate::data::VideoEncodeH264OutputModeFlagBitsEXT;
    VideoEncodeH265CapabilityFlagsEXT = crate::data::VideoEncodeH265CapabilityFlagBitsEXT;
    VideoEncodeH265InputModeFlagsEXT = crate::data::VideoEncodeH265InputModeFlagBitsEXT;
    VideoEncodeH265OutputModeFlagsEXT = crate::data::VideoEncodeH265OutputModeFlagBitsEXT;
    VideoEncodeH265CtbSizeFlagsEXT = crate::data::VideoEncodeH265CtbSizeFlagBitsEXT;
    VideoEncodeH265TransformBlockSizeFlagsEXT = crate::data::VideoEncodeH265TransformBlockSizeFlagBitsEXT;
    DescriptorUpdateTemplateKHR = crate::data::DescriptorUpdateTemplate;
    SamplerYcbcrConversionKHR = crate::data::SamplerYcbcrConversion;
    PrivateDataSlotEXT = crate::data::PrivateDataSlot;
    PrivateDataSlotCreateFlagBitsEXT = crate::data::PrivateDataSlotCreateFlagBits;
    DescriptorUpdateTemplateTypeKHR = crate::data::DescriptorUpdateTemplateType;
    PointClippingBehaviorKHR = crate::data::PointClippingBehavior;
    QueueGlobalPriorityEXT = crate::data::QueueGlobalPriorityKHR;
    ResolveModeFlagBitsKHR = crate::data::ResolveModeFlagBits;
    DescriptorBindingFlagBitsEXT = crate::data::DescriptorBindingFlagBits;
    SemaphoreTypeKHR = crate::data::SemaphoreType;
    GeometryFlagBitsNV = crate::data::GeometryFlagBitsKHR;
    GeometryInstanceFlagBitsNV = crate::data::GeometryInstanceFlagBitsKHR;
    BuildAccelerationStructureFlagBitsNV = crate::data::BuildAccelerationStructureFlagBitsKHR;
    CopyAccelerationStructureModeNV = crate::data::CopyAccelerationStructureModeKHR;
    AccelerationStructureTypeNV = crate::data::AccelerationStructureTypeKHR;
    GeometryTypeNV = crate::data::GeometryTypeKHR;
    RayTracingShaderGroupTypeNV = crate::data::RayTracingShaderGroupTypeKHR;
    PipelineCreationFeedbackFlagBitsEXT = crate::data::PipelineCreationFeedbackFlagBits;
    SemaphoreWaitFlagBitsKHR = crate::data::SemaphoreWaitFlagBits;
    ToolPurposeFlagBitsEXT = crate::data::ToolPurposeFlagBits;
    AccessFlagBits2KHR = crate::data::AccessFlagBits2;
    PipelineStageFlagBits2KHR = crate::data::PipelineStageFlagBits2;
    FormatFeatureFlagBits2KHR = crate::data::FormatFeatureFlagBits2;
    RenderingFlagBitsKHR = crate::data::RenderingFlagBits;
    ExternalMemoryHandleTypeFlagBitsKHR = crate::data::ExternalMemoryHandleTypeFlagBits;
    ExternalMemoryFeatureFlagBitsKHR = crate::data::ExternalMemoryFeatureFlagBits;
    ExternalSemaphoreHandleTypeFlagBitsKHR = crate::data::ExternalSemaphoreHandleTypeFlagBits;
    ExternalSemaphoreFeatureFlagBitsKHR = crate::data::ExternalSemaphoreFeatureFlagBits;
    SemaphoreImportFlagBitsKHR = crate::data::SemaphoreImportFlagBits;
    ExternalFenceHandleTypeFlagBitsKHR = crate::data::ExternalFenceHandleTypeFlagBits;
    ExternalFenceFeatureFlagBitsKHR = crate::data::ExternalFenceFeatureFlagBits;
    FenceImportFlagBitsKHR = crate::data::FenceImportFlagBits;
    PeerMemoryFeatureFlagBitsKHR = crate::data::PeerMemoryFeatureFlagBits;
    MemoryAllocateFlagBitsKHR = crate::data::MemoryAllocateFlagBits;
    TessellationDomainOriginKHR = crate::data::TessellationDomainOrigin;
    SamplerYcbcrModelConversionKHR = crate::data::SamplerYcbcrModelConversion;
    SamplerYcbcrRangeKHR = crate::data::SamplerYcbcrRange;
    ChromaLocationKHR = crate::data::ChromaLocation;
    SamplerReductionModeEXT = crate::data::SamplerReductionMode;
    ShaderFloatControlsIndependenceKHR = crate::data::ShaderFloatControlsIndependence;
    SubmitFlagBitsKHR = crate::data::SubmitFlagBits;
    DriverIdKHR = crate::data::DriverId;
    DevicePrivateDataCreateInfoEXT = crate::data::DevicePrivateDataCreateInfo;
    PrivateDataSlotCreateInfoEXT = crate::data::PrivateDataSlotCreateInfo;
    PhysicalDevicePrivateDataFeaturesEXT = crate::data::PhysicalDevicePrivateDataFeatures;
    PhysicalDeviceFeatures2KHR = crate::data::PhysicalDeviceFeatures2;
    PhysicalDeviceProperties2KHR = crate::data::PhysicalDeviceProperties2;
    FormatProperties2KHR = crate::data::FormatProperties2;
    ImageFormatProperties2KHR = crate::data::ImageFormatProperties2;
    PhysicalDeviceImageFormatInfo2KHR = crate::data::PhysicalDeviceImageFormatInfo2;
    QueueFamilyProperties2KHR = crate::data::QueueFamilyProperties2;
    PhysicalDeviceMemoryProperties2KHR = crate::data::PhysicalDeviceMemoryProperties2;
    SparseImageFormatProperties2KHR = crate::data::SparseImageFormatProperties2;
    PhysicalDeviceSparseImageFormatInfo2KHR = crate::data::PhysicalDeviceSparseImageFormatInfo2;
    ConformanceVersionKHR = crate::data::ConformanceVersion;
    PhysicalDeviceDriverPropertiesKHR = crate::data::PhysicalDeviceDriverProperties;
    PhysicalDeviceVariablePointersFeaturesKHR = crate::data::PhysicalDeviceVariablePointersFeatures;
    PhysicalDeviceVariablePointerFeaturesKHR = crate::data::PhysicalDeviceVariablePointersFeatures;
    PhysicalDeviceVariablePointerFeatures = crate::data::PhysicalDeviceVariablePointersFeatures;
    ExternalMemoryPropertiesKHR = crate::data::ExternalMemoryProperties;
    PhysicalDeviceExternalImageFormatInfoKHR = crate::data::PhysicalDeviceExternalImageFormatInfo;
    ExternalImageFormatPropertiesKHR = crate::data::ExternalImageFormatProperties;
    PhysicalDeviceExternalBufferInfoKHR = crate::data::PhysicalDeviceExternalBufferInfo;
    ExternalBufferPropertiesKHR = crate::data::ExternalBufferProperties;
    PhysicalDeviceIDPropertiesKHR = crate::data::PhysicalDeviceIDProperties;
    ExternalMemoryImageCreateInfoKHR = crate::data::ExternalMemoryImageCreateInfo;
    ExternalMemoryBufferCreateInfoKHR = crate::data::ExternalMemoryBufferCreateInfo;
    ExportMemoryAllocateInfoKHR = crate::data::ExportMemoryAllocateInfo;
    PhysicalDeviceExternalSemaphoreInfoKHR = crate::data::PhysicalDeviceExternalSemaphoreInfo;
    ExternalSemaphorePropertiesKHR = crate::data::ExternalSemaphoreProperties;
    ExportSemaphoreCreateInfoKHR = crate::data::ExportSemaphoreCreateInfo;
    PhysicalDeviceExternalFenceInfoKHR = crate::data::PhysicalDeviceExternalFenceInfo;
    ExternalFencePropertiesKHR = crate::data::ExternalFenceProperties;
    ExportFenceCreateInfoKHR = crate::data::ExportFenceCreateInfo;
    PhysicalDeviceMultiviewFeaturesKHR = crate::data::PhysicalDeviceMultiviewFeatures;
    PhysicalDeviceMultiviewPropertiesKHR = crate::data::PhysicalDeviceMultiviewProperties;
    RenderPassMultiviewCreateInfoKHR = crate::data::RenderPassMultiviewCreateInfo;
    PhysicalDeviceGroupPropertiesKHR = crate::data::PhysicalDeviceGroupProperties;
    MemoryAllocateFlagsInfoKHR = crate::data::MemoryAllocateFlagsInfo;
    BindBufferMemoryInfoKHR = crate::data::BindBufferMemoryInfo;
    BindBufferMemoryDeviceGroupInfoKHR = crate::data::BindBufferMemoryDeviceGroupInfo;
    BindImageMemoryInfoKHR = crate::data::BindImageMemoryInfo;
    BindImageMemoryDeviceGroupInfoKHR = crate::data::BindImageMemoryDeviceGroupInfo;
    DeviceGroupRenderPassBeginInfoKHR = crate::data::DeviceGroupRenderPassBeginInfo;
    DeviceGroupCommandBufferBeginInfoKHR = crate::data::DeviceGroupCommandBufferBeginInfo;
    DeviceGroupSubmitInfoKHR = crate::data::DeviceGroupSubmitInfo;
    DeviceGroupBindSparseInfoKHR = crate::data::DeviceGroupBindSparseInfo;
    DeviceGroupDeviceCreateInfoKHR = crate::data::DeviceGroupDeviceCreateInfo;
    DescriptorUpdateTemplateEntryKHR = crate::data::DescriptorUpdateTemplateEntry;
    DescriptorUpdateTemplateCreateInfoKHR = crate::data::DescriptorUpdateTemplateCreateInfo;
    InputAttachmentAspectReferenceKHR = crate::data::InputAttachmentAspectReference;
    RenderPassInputAttachmentAspectCreateInfoKHR = crate::data::RenderPassInputAttachmentAspectCreateInfo;
    PhysicalDevice16BitStorageFeaturesKHR = crate::data::PhysicalDevice16BitStorageFeatures;
    PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = crate::data::PhysicalDeviceShaderSubgroupExtendedTypesFeatures;
    BufferMemoryRequirementsInfo2KHR = crate::data::BufferMemoryRequirementsInfo2;
    DeviceBufferMemoryRequirementsKHR = crate::data::DeviceBufferMemoryRequirements;
    ImageMemoryRequirementsInfo2KHR = crate::data::ImageMemoryRequirementsInfo2;
    ImageSparseMemoryRequirementsInfo2KHR = crate::data::ImageSparseMemoryRequirementsInfo2;
    DeviceImageMemoryRequirementsKHR = crate::data::DeviceImageMemoryRequirements;
    MemoryRequirements2KHR = crate::data::MemoryRequirements2;
    SparseImageMemoryRequirements2KHR = crate::data::SparseImageMemoryRequirements2;
    PhysicalDevicePointClippingPropertiesKHR = crate::data::PhysicalDevicePointClippingProperties;
    MemoryDedicatedRequirementsKHR = crate::data::MemoryDedicatedRequirements;
    MemoryDedicatedAllocateInfoKHR = crate::data::MemoryDedicatedAllocateInfo;
    ImageViewUsageCreateInfoKHR = crate::data::ImageViewUsageCreateInfo;
    PipelineTessellationDomainOriginStateCreateInfoKHR = crate::data::PipelineTessellationDomainOriginStateCreateInfo;
    SamplerYcbcrConversionInfoKHR = crate::data::SamplerYcbcrConversionInfo;
    SamplerYcbcrConversionCreateInfoKHR = crate::data::SamplerYcbcrConversionCreateInfo;
    BindImagePlaneMemoryInfoKHR = crate::data::BindImagePlaneMemoryInfo;
    ImagePlaneMemoryRequirementsInfoKHR = crate::data::ImagePlaneMemoryRequirementsInfo;
    PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = crate::data::PhysicalDeviceSamplerYcbcrConversionFeatures;
    SamplerYcbcrConversionImageFormatPropertiesKHR = crate::data::SamplerYcbcrConversionImageFormatProperties;
    PhysicalDeviceSamplerFilterMinmaxPropertiesEXT = crate::data::PhysicalDeviceSamplerFilterMinmaxProperties;
    SamplerReductionModeCreateInfoEXT = crate::data::SamplerReductionModeCreateInfo;
    PhysicalDeviceInlineUniformBlockFeaturesEXT = crate::data::PhysicalDeviceInlineUniformBlockFeatures;
    PhysicalDeviceInlineUniformBlockPropertiesEXT = crate::data::PhysicalDeviceInlineUniformBlockProperties;
    WriteDescriptorSetInlineUniformBlockEXT = crate::data::WriteDescriptorSetInlineUniformBlock;
    DescriptorPoolInlineUniformBlockCreateInfoEXT = crate::data::DescriptorPoolInlineUniformBlockCreateInfo;
    ImageFormatListCreateInfoKHR = crate::data::ImageFormatListCreateInfo;
    PhysicalDeviceMaintenance3PropertiesKHR = crate::data::PhysicalDeviceMaintenance3Properties;
    PhysicalDeviceMaintenance4FeaturesKHR = crate::data::PhysicalDeviceMaintenance4Features;
    PhysicalDeviceMaintenance4PropertiesKHR = crate::data::PhysicalDeviceMaintenance4Properties;
    DescriptorSetLayoutSupportKHR = crate::data::DescriptorSetLayoutSupport;
    PhysicalDeviceShaderDrawParameterFeatures = crate::data::PhysicalDeviceShaderDrawParametersFeatures;
    PhysicalDeviceShaderFloat16Int8FeaturesKHR = crate::data::PhysicalDeviceShaderFloat16Int8Features;
    PhysicalDeviceFloat16Int8FeaturesKHR = crate::data::PhysicalDeviceShaderFloat16Int8Features;
    PhysicalDeviceFloatControlsPropertiesKHR = crate::data::PhysicalDeviceFloatControlsProperties;
    PhysicalDeviceHostQueryResetFeaturesEXT = crate::data::PhysicalDeviceHostQueryResetFeatures;
    DeviceQueueGlobalPriorityCreateInfoEXT = crate::data::DeviceQueueGlobalPriorityCreateInfoKHR;
    PhysicalDeviceGlobalPriorityQueryFeaturesEXT = crate::data::PhysicalDeviceGlobalPriorityQueryFeaturesKHR;
    QueueFamilyGlobalPriorityPropertiesEXT = crate::data::QueueFamilyGlobalPriorityPropertiesKHR;
    PhysicalDeviceDescriptorIndexingFeaturesEXT = crate::data::PhysicalDeviceDescriptorIndexingFeatures;
    PhysicalDeviceDescriptorIndexingPropertiesEXT = crate::data::PhysicalDeviceDescriptorIndexingProperties;
    DescriptorSetLayoutBindingFlagsCreateInfoEXT = crate::data::DescriptorSetLayoutBindingFlagsCreateInfo;
    DescriptorSetVariableDescriptorCountAllocateInfoEXT = crate::data::DescriptorSetVariableDescriptorCountAllocateInfo;
    DescriptorSetVariableDescriptorCountLayoutSupportEXT = crate::data::DescriptorSetVariableDescriptorCountLayoutSupport;
    AttachmentDescription2KHR = crate::data::AttachmentDescription2;
    AttachmentReference2KHR = crate::data::AttachmentReference2;
    SubpassDescription2KHR = crate::data::SubpassDescription2;
    SubpassDependency2KHR = crate::data::SubpassDependency2;
    RenderPassCreateInfo2KHR = crate::data::RenderPassCreateInfo2;
    SubpassBeginInfoKHR = crate::data::SubpassBeginInfo;
    SubpassEndInfoKHR = crate::data::SubpassEndInfo;
    PhysicalDeviceTimelineSemaphoreFeaturesKHR = crate::data::PhysicalDeviceTimelineSemaphoreFeatures;
    PhysicalDeviceTimelineSemaphorePropertiesKHR = crate::data::PhysicalDeviceTimelineSemaphoreProperties;
    SemaphoreTypeCreateInfoKHR = crate::data::SemaphoreTypeCreateInfo;
    TimelineSemaphoreSubmitInfoKHR = crate::data::TimelineSemaphoreSubmitInfo;
    SemaphoreWaitInfoKHR = crate::data::SemaphoreWaitInfo;
    SemaphoreSignalInfoKHR = crate::data::SemaphoreSignalInfo;
    PhysicalDevice8BitStorageFeaturesKHR = crate::data::PhysicalDevice8BitStorageFeatures;
    PhysicalDeviceVulkanMemoryModelFeaturesKHR = crate::data::PhysicalDeviceVulkanMemoryModelFeatures;
    PhysicalDeviceShaderAtomicInt64FeaturesKHR = crate::data::PhysicalDeviceShaderAtomicInt64Features;
    PhysicalDeviceDepthStencilResolvePropertiesKHR = crate::data::PhysicalDeviceDepthStencilResolveProperties;
    SubpassDescriptionDepthStencilResolveKHR = crate::data::SubpassDescriptionDepthStencilResolve;
    PhysicalDeviceFragmentShaderBarycentricFeaturesNV = crate::data::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
    ImageStencilUsageCreateInfoEXT = crate::data::ImageStencilUsageCreateInfo;
    PhysicalDeviceScalarBlockLayoutFeaturesEXT = crate::data::PhysicalDeviceScalarBlockLayoutFeatures;
    PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = crate::data::PhysicalDeviceUniformBufferStandardLayoutFeatures;
    PhysicalDeviceBufferDeviceAddressFeaturesKHR = crate::data::PhysicalDeviceBufferDeviceAddressFeatures;
    PhysicalDeviceBufferAddressFeaturesEXT = crate::data::PhysicalDeviceBufferDeviceAddressFeaturesEXT;
    BufferDeviceAddressInfoKHR = crate::data::BufferDeviceAddressInfo;
    BufferDeviceAddressInfoEXT = crate::data::BufferDeviceAddressInfo;
    BufferOpaqueCaptureAddressCreateInfoKHR = crate::data::BufferOpaqueCaptureAddressCreateInfo;
    PhysicalDeviceImagelessFramebufferFeaturesKHR = crate::data::PhysicalDeviceImagelessFramebufferFeatures;
    FramebufferAttachmentsCreateInfoKHR = crate::data::FramebufferAttachmentsCreateInfo;
    FramebufferAttachmentImageInfoKHR = crate::data::FramebufferAttachmentImageInfo;
    RenderPassAttachmentBeginInfoKHR = crate::data::RenderPassAttachmentBeginInfo;
    PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = crate::data::PhysicalDeviceTextureCompressionASTCHDRFeatures;
    PipelineCreationFeedbackEXT = crate::data::PipelineCreationFeedback;
    PipelineCreationFeedbackCreateInfoEXT = crate::data::PipelineCreationFeedbackCreateInfo;
    QueryPoolCreateInfoINTEL = crate::data::QueryPoolPerformanceQueryCreateInfoINTEL;
    PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = crate::data::PhysicalDeviceSeparateDepthStencilLayoutsFeatures;
    AttachmentReferenceStencilLayoutKHR = crate::data::AttachmentReferenceStencilLayout;
    AttachmentDescriptionStencilLayoutKHR = crate::data::AttachmentDescriptionStencilLayout;
    PipelineInfoEXT = crate::data::PipelineInfoKHR;
    PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = crate::data::PhysicalDeviceShaderDemoteToHelperInvocationFeatures;
    PhysicalDeviceTexelBufferAlignmentPropertiesEXT = crate::data::PhysicalDeviceTexelBufferAlignmentProperties;
    PhysicalDeviceSubgroupSizeControlFeaturesEXT = crate::data::PhysicalDeviceSubgroupSizeControlFeatures;
    PhysicalDeviceSubgroupSizeControlPropertiesEXT = crate::data::PhysicalDeviceSubgroupSizeControlProperties;
    PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = crate::data::PipelineShaderStageRequiredSubgroupSizeCreateInfo;
    MemoryOpaqueCaptureAddressAllocateInfoKHR = crate::data::MemoryOpaqueCaptureAddressAllocateInfo;
    DeviceMemoryOpaqueCaptureAddressInfoKHR = crate::data::DeviceMemoryOpaqueCaptureAddressInfo;
    PhysicalDevicePipelineCreationCacheControlFeaturesEXT = crate::data::PhysicalDevicePipelineCreationCacheControlFeatures;
    PhysicalDeviceToolPropertiesEXT = crate::data::PhysicalDeviceToolProperties;
    AabbPositionsNV = crate::data::AabbPositionsKHR;
    TransformMatrixNV = crate::data::TransformMatrixKHR;
    AccelerationStructureInstanceNV = crate::data::AccelerationStructureInstanceKHR;
    PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = crate::data::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
    PhysicalDeviceImageRobustnessFeaturesEXT = crate::data::PhysicalDeviceImageRobustnessFeatures;
    BufferCopy2KHR = crate::data::BufferCopy2;
    ImageCopy2KHR = crate::data::ImageCopy2;
    ImageBlit2KHR = crate::data::ImageBlit2;
    BufferImageCopy2KHR = crate::data::BufferImageCopy2;
    ImageResolve2KHR = crate::data::ImageResolve2;
    CopyBufferInfo2KHR = crate::data::CopyBufferInfo2;
    CopyImageInfo2KHR = crate::data::CopyImageInfo2;
    BlitImageInfo2KHR = crate::data::BlitImageInfo2;
    CopyBufferToImageInfo2KHR = crate::data::CopyBufferToImageInfo2;
    CopyImageToBufferInfo2KHR = crate::data::CopyImageToBufferInfo2;
    ResolveImageInfo2KHR = crate::data::ResolveImageInfo2;
    PhysicalDeviceShaderTerminateInvocationFeaturesKHR = crate::data::PhysicalDeviceShaderTerminateInvocationFeatures;
    PhysicalDeviceMutableDescriptorTypeFeaturesVALVE = crate::data::PhysicalDeviceMutableDescriptorTypeFeaturesEXT;
    MutableDescriptorTypeListVALVE = crate::data::MutableDescriptorTypeListEXT;
    MutableDescriptorTypeCreateInfoVALVE = crate::data::MutableDescriptorTypeCreateInfoEXT;
    MemoryBarrier2KHR = crate::data::MemoryBarrier2;
    ImageMemoryBarrier2KHR = crate::data::ImageMemoryBarrier2;
    BufferMemoryBarrier2KHR = crate::data::BufferMemoryBarrier2;
    DependencyInfoKHR = crate::data::DependencyInfo;
    SemaphoreSubmitInfoKHR = crate::data::SemaphoreSubmitInfo;
    CommandBufferSubmitInfoKHR = crate::data::CommandBufferSubmitInfo;
    SubmitInfo2KHR = crate::data::SubmitInfo2;
    PhysicalDeviceSynchronization2FeaturesKHR = crate::data::PhysicalDeviceSynchronization2Features;
    PhysicalDeviceShaderIntegerDotProductFeaturesKHR = crate::data::PhysicalDeviceShaderIntegerDotProductFeatures;
    PhysicalDeviceShaderIntegerDotProductPropertiesKHR = crate::data::PhysicalDeviceShaderIntegerDotProductProperties;
    RemoteAddressNV = c_void;
    FormatProperties3KHR = crate::data::FormatProperties3;
    PipelineRenderingCreateInfoKHR = crate::data::PipelineRenderingCreateInfo;
    RenderingInfoKHR = crate::data::RenderingInfo;
    RenderingAttachmentInfoKHR = crate::data::RenderingAttachmentInfo;
    PhysicalDeviceDynamicRenderingFeaturesKHR = crate::data::PhysicalDeviceDynamicRenderingFeatures;
    CommandBufferInheritanceRenderingInfoKHR = crate::data::CommandBufferInheritanceRenderingInfo;
    AttachmentSampleCountInfoNV = crate::data::AttachmentSampleCountInfoAMD;
    PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = crate::data::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
}

impl_handles! {
    Instance { dispatchable: true };
    PhysicalDevice { dispatchable: true };
    Device { dispatchable: true };
    Queue { dispatchable: true };
    CommandBuffer { dispatchable: true };
    DeviceMemory { dispatchable: false };
    CommandPool { dispatchable: false };
    Buffer { dispatchable: false };
    BufferView { dispatchable: false };
    Image { dispatchable: false };
    ImageView { dispatchable: false };
    ShaderModule { dispatchable: false };
    Pipeline { dispatchable: false };
    PipelineLayout { dispatchable: false };
    Sampler { dispatchable: false };
    DescriptorSet { dispatchable: false };
    DescriptorSetLayout { dispatchable: false };
    DescriptorPool { dispatchable: false };
    Fence { dispatchable: false };
    Semaphore { dispatchable: false };
    Event { dispatchable: false };
    QueryPool { dispatchable: false };
    Framebuffer { dispatchable: false };
    RenderPass { dispatchable: false };
    PipelineCache { dispatchable: false };
    IndirectCommandsLayoutNV { dispatchable: false };
    DescriptorUpdateTemplate { dispatchable: false };
    SamplerYcbcrConversion { dispatchable: false };
    ValidationCacheEXT { dispatchable: false };
    AccelerationStructureKHR { dispatchable: false };
    AccelerationStructureNV { dispatchable: false };
    PerformanceConfigurationINTEL { dispatchable: false };
    BufferCollectionFUCHSIA { dispatchable: false };
    DeferredOperationKHR { dispatchable: false };
    PrivateDataSlot { dispatchable: false };
    CuModuleNVX { dispatchable: false };
    CuFunctionNVX { dispatchable: false };
    OpticalFlowSessionNV { dispatchable: false };
    MicromapEXT { dispatchable: false };
    DisplayKHR { dispatchable: false };
    DisplayModeKHR { dispatchable: false };
    SurfaceKHR { dispatchable: false };
    SwapchainKHR { dispatchable: false };
    DebugReportCallbackEXT { dispatchable: false };
    DebugUtilsMessengerEXT { dispatchable: false };
    VideoSessionKHR { dispatchable: false };
    VideoSessionParametersKHR { dispatchable: false };
}

impl_func_pointers! {
    InternalAllocationNotification(
        p_user_data: *mut c_void,
        size: usize,
        allocation_type: crate::data::InternalAllocationType,
        allocation_scope: crate::data::SystemAllocationScope,
    );
    InternalFreeNotification(
        p_user_data: *mut c_void,
        size: usize,
        allocation_type: crate::data::InternalAllocationType,
        allocation_scope: crate::data::SystemAllocationScope,
    );
    ReallocationFunction(
        p_user_data: *mut c_void,
        p_original: *mut c_void,
        size: usize,
        alignment: usize,
        allocation_scope: crate::data::SystemAllocationScope,
    ) -> *mut c_void;
    AllocationFunction(
        p_user_data: *mut c_void,
        size: usize,
        alignment: usize,
        allocation_scope: crate::data::SystemAllocationScope,
    ) -> *mut c_void;
    FreeFunction(
        p_user_data: *mut c_void,
        p_memory: *mut c_void,
    );
    VoidFunction(
    );
    DebugReportCallbackEXT(
        flags: crate::data::DebugReportFlagsEXT,
        object_type: crate::data::DebugReportObjectTypeEXT,
        object: u64,
        location: usize,
        message_code: i32,
        p_layer_prefix: *const c_char,
        p_message: *const c_char,
        p_user_data: *mut c_void,
    ) -> crate::data::Bool32;
    DebugUtilsMessengerCallbackEXT(
        message_severity: crate::data::DebugUtilsMessageSeverityFlagBitsEXT,
        message_types: crate::data::DebugUtilsMessageTypeFlagsEXT,
        p_callback_data: *const crate::data::DebugUtilsMessengerCallbackDataEXT,
        p_user_data: *mut c_void,
    ) -> crate::data::Bool32;
    DeviceMemoryReportCallbackEXT(
        p_callback_data: *const crate::data::DeviceMemoryReportCallbackDataEXT,
        p_user_data: *mut c_void,
    );
}

mod aggregates {
    aggregate_imports!();
    impl_aggregate! {
        struct BaseOutStructure {
            s_type: crate::data::StructureType,
            p_next: *mut crate::data::BaseOutStructure,
        }
    }
    impl_aggregate! {
        struct BaseInStructure {
            s_type: crate::data::StructureType,
            p_next: *const crate::data::BaseInStructure,
        }
    }
    impl_aggregate! {
        struct Offset2D {
            x: i32,
            y: i32,
        }
    }
    impl_aggregate! {
        struct Offset3D {
            x: i32,
            y: i32,
            z: i32,
        }
    }
    impl_aggregate! {
        struct Extent2D {
            width: u32,
            height: u32,
        }
    }
    impl_aggregate! {
        struct Extent3D {
            width: u32,
            height: u32,
            depth: u32,
        }
    }
    impl_aggregate! {
        struct Viewport {
            x: c_float,
            y: c_float,
            width: c_float,
            height: c_float,
            min_depth: c_float,
            max_depth: c_float,
        }
    }
    impl_aggregate! {
        struct Rect2D {
            offset: crate::data::Offset2D,
            extent: crate::data::Extent2D,
        }
    }
    impl_aggregate! {
        struct ClearRect {
            rect: crate::data::Rect2D,
            base_array_layer: u32,
            layer_count: u32,
        }
    }
    impl_aggregate! {
        struct ComponentMapping {
            r: crate::data::ComponentSwizzle,
            g: crate::data::ComponentSwizzle,
            b: crate::data::ComponentSwizzle,
            a: crate::data::ComponentSwizzle,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceProperties {
            api_version: u32,
            driver_version: u32,
            vendor_id: u32,
            device_id: u32,
            device_type: crate::data::PhysicalDeviceType,
            device_name: [c_char; 256],
            pipeline_cache_uuid: [u8; 16],
            limits: crate::data::PhysicalDeviceLimits,
            sparse_properties: crate::data::PhysicalDeviceSparseProperties,
        }
    }
    impl_aggregate! {
        struct ExtensionProperties {
            extension_name: [c_char; 256],
            spec_version: u32,
        }
    }
    impl_aggregate! {
        struct LayerProperties {
            layer_name: [c_char; 256],
            spec_version: u32,
            implementation_version: u32,
            description: [c_char; 256],
        }
    }
    impl_aggregate! {
        struct ApplicationInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::APPLICATION_INFO,
            p_next: *const c_void,
            p_application_name: *const c_char,
            application_version: u32,
            p_engine_name: *const c_char,
            engine_version: u32,
            api_version: u32,
        }
    }
    impl_aggregate! {
        struct AllocationCallbacks {
            p_user_data: *mut c_void,
            pfn_allocation: crate::pfn::AllocationFunction,
            pfn_reallocation: crate::pfn::ReallocationFunction,
            pfn_free: crate::pfn::FreeFunction,
            pfn_internal_allocation: crate::pfn::InternalAllocationNotification,
            pfn_internal_free: crate::pfn::InternalFreeNotification,
        }
    }
    impl_aggregate! {
        struct DeviceQueueCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_QUEUE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::DeviceQueueCreateFlags,
            queue_family_index: u32,
            queue_count: u32,
            p_queue_priorities: *const c_float,
        }
    }
    impl_aggregate! {
        struct DeviceCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::DeviceCreateFlags,
            queue_create_info_count: u32,
            p_queue_create_infos: *const crate::data::DeviceQueueCreateInfo,
            enabled_layer_count: u32,
            pp_enabled_layer_names: *const *const c_char,
            enabled_extension_count: u32,
            pp_enabled_extension_names: *const *const c_char,
            p_enabled_features: *const crate::data::PhysicalDeviceFeatures,
        }
    }
    impl_aggregate! {
        struct InstanceCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::INSTANCE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::InstanceCreateFlags,
            p_application_info: *const crate::data::ApplicationInfo,
            enabled_layer_count: u32,
            pp_enabled_layer_names: *const *const c_char,
            enabled_extension_count: u32,
            pp_enabled_extension_names: *const *const c_char,
        }
    }
    impl_aggregate! {
        struct QueueFamilyProperties {
            queue_flags: crate::data::QueueFlags,
            queue_count: u32,
            timestamp_valid_bits: u32,
            min_image_transfer_granularity: crate::data::Extent3D,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMemoryProperties {
            memory_type_count: u32,
            memory_types: [crate::data::MemoryType; 32],
            memory_heap_count: u32,
            memory_heaps: [crate::data::MemoryHeap; 16],
        }
    }
    impl_aggregate! {
        struct MemoryAllocateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_ALLOCATE_INFO,
            p_next: *const c_void,
            allocation_size: crate::data::DeviceSize,
            memory_type_index: u32,
        }
    }
    impl_aggregate! {
        struct MemoryRequirements {
            size: crate::data::DeviceSize,
            alignment: crate::data::DeviceSize,
            memory_type_bits: u32,
        }
    }
    impl_aggregate! {
        struct SparseImageFormatProperties {
            aspect_mask: crate::data::ImageAspectFlags,
            image_granularity: crate::data::Extent3D,
            flags: crate::data::SparseImageFormatFlags,
        }
    }
    impl_aggregate! {
        struct SparseImageMemoryRequirements {
            format_properties: crate::data::SparseImageFormatProperties,
            image_mip_tail_first_lod: u32,
            image_mip_tail_size: crate::data::DeviceSize,
            image_mip_tail_offset: crate::data::DeviceSize,
            image_mip_tail_stride: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct MemoryType {
            property_flags: crate::data::MemoryPropertyFlags,
            heap_index: u32,
        }
    }
    impl_aggregate! {
        struct MemoryHeap {
            size: crate::data::DeviceSize,
            flags: crate::data::MemoryHeapFlags,
        }
    }
    impl_aggregate! {
        struct MappedMemoryRange {
            s_type: crate::data::StructureType = crate::data::StructureType::MAPPED_MEMORY_RANGE,
            p_next: *const c_void,
            memory: crate::data::DeviceMemory,
            offset: crate::data::DeviceSize,
            size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct FormatProperties {
            linear_tiling_features: crate::data::FormatFeatureFlags,
            optimal_tiling_features: crate::data::FormatFeatureFlags,
            buffer_features: crate::data::FormatFeatureFlags,
        }
    }
    impl_aggregate! {
        struct ImageFormatProperties {
            max_extent: crate::data::Extent3D,
            max_mip_levels: u32,
            max_array_layers: u32,
            sample_counts: crate::data::SampleCountFlags,
            max_resource_size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct DescriptorBufferInfo {
            buffer: crate::data::Buffer,
            offset: crate::data::DeviceSize,
            range: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct DescriptorImageInfo {
            sampler: crate::data::Sampler,
            image_view: crate::data::ImageView,
            image_layout: crate::data::ImageLayout,
        }
    }
    impl_aggregate! {
        struct WriteDescriptorSet {
            s_type: crate::data::StructureType = crate::data::StructureType::WRITE_DESCRIPTOR_SET,
            p_next: *const c_void,
            dst_set: crate::data::DescriptorSet,
            dst_binding: u32,
            dst_array_element: u32,
            descriptor_count: u32,
            descriptor_type: crate::data::DescriptorType,
            p_image_info: *const crate::data::DescriptorImageInfo,
            p_buffer_info: *const crate::data::DescriptorBufferInfo,
            p_texel_buffer_view: *const crate::data::BufferView,
        }
    }
    impl_aggregate! {
        struct CopyDescriptorSet {
            s_type: crate::data::StructureType = crate::data::StructureType::COPY_DESCRIPTOR_SET,
            p_next: *const c_void,
            src_set: crate::data::DescriptorSet,
            src_binding: u32,
            src_array_element: u32,
            dst_set: crate::data::DescriptorSet,
            dst_binding: u32,
            dst_array_element: u32,
            descriptor_count: u32,
        }
    }
    impl_aggregate! {
        struct BufferCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::BufferCreateFlags,
            size: crate::data::DeviceSize,
            usage: crate::data::BufferUsageFlags,
            sharing_mode: crate::data::SharingMode,
            queue_family_index_count: u32,
            p_queue_family_indices: *const u32,
        }
    }
    impl_aggregate! {
        struct BufferViewCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_VIEW_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::BufferViewCreateFlags,
            buffer: crate::data::Buffer,
            format: crate::data::Format,
            offset: crate::data::DeviceSize,
            range: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct ImageSubresource {
            aspect_mask: crate::data::ImageAspectFlags,
            mip_level: u32,
            array_layer: u32,
        }
    }
    impl_aggregate! {
        struct ImageSubresourceLayers {
            aspect_mask: crate::data::ImageAspectFlags,
            mip_level: u32,
            base_array_layer: u32,
            layer_count: u32,
        }
    }
    impl_aggregate! {
        struct ImageSubresourceRange {
            aspect_mask: crate::data::ImageAspectFlags,
            base_mip_level: u32,
            level_count: u32,
            base_array_layer: u32,
            layer_count: u32,
        }
    }
    impl_aggregate! {
        struct MemoryBarrier {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_BARRIER,
            p_next: *const c_void,
            src_access_mask: crate::data::AccessFlags,
            dst_access_mask: crate::data::AccessFlags,
        }
    }
    impl_aggregate! {
        struct BufferMemoryBarrier {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_MEMORY_BARRIER,
            p_next: *const c_void,
            src_access_mask: crate::data::AccessFlags,
            dst_access_mask: crate::data::AccessFlags,
            src_queue_family_index: u32,
            dst_queue_family_index: u32,
            buffer: crate::data::Buffer,
            offset: crate::data::DeviceSize,
            size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct ImageMemoryBarrier {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_MEMORY_BARRIER,
            p_next: *const c_void,
            src_access_mask: crate::data::AccessFlags,
            dst_access_mask: crate::data::AccessFlags,
            old_layout: crate::data::ImageLayout,
            new_layout: crate::data::ImageLayout,
            src_queue_family_index: u32,
            dst_queue_family_index: u32,
            image: crate::data::Image,
            subresource_range: crate::data::ImageSubresourceRange,
        }
    }
    impl_aggregate! {
        struct ImageCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::ImageCreateFlags,
            image_type: crate::data::ImageType,
            format: crate::data::Format,
            extent: crate::data::Extent3D,
            mip_levels: u32,
            array_layers: u32,
            samples: crate::data::SampleCountFlagBits,
            tiling: crate::data::ImageTiling,
            usage: crate::data::ImageUsageFlags,
            sharing_mode: crate::data::SharingMode,
            queue_family_index_count: u32,
            p_queue_family_indices: *const u32,
            initial_layout: crate::data::ImageLayout,
        }
    }
    impl_aggregate! {
        struct SubresourceLayout {
            offset: crate::data::DeviceSize,
            size: crate::data::DeviceSize,
            row_pitch: crate::data::DeviceSize,
            array_pitch: crate::data::DeviceSize,
            depth_pitch: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct ImageViewCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_VIEW_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::ImageViewCreateFlags,
            image: crate::data::Image,
            view_type: crate::data::ImageViewType,
            format: crate::data::Format,
            components: crate::data::ComponentMapping,
            subresource_range: crate::data::ImageSubresourceRange,
        }
    }
    impl_aggregate! {
        struct BufferCopy {
            src_offset: crate::data::DeviceSize,
            dst_offset: crate::data::DeviceSize,
            size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct SparseMemoryBind {
            resource_offset: crate::data::DeviceSize,
            size: crate::data::DeviceSize,
            memory: crate::data::DeviceMemory,
            memory_offset: crate::data::DeviceSize,
            flags: crate::data::SparseMemoryBindFlags,
        }
    }
    impl_aggregate! {
        struct SparseImageMemoryBind {
            subresource: crate::data::ImageSubresource,
            offset: crate::data::Offset3D,
            extent: crate::data::Extent3D,
            memory: crate::data::DeviceMemory,
            memory_offset: crate::data::DeviceSize,
            flags: crate::data::SparseMemoryBindFlags,
        }
    }
    impl_aggregate! {
        struct SparseBufferMemoryBindInfo {
            buffer: crate::data::Buffer,
            bind_count: u32,
            p_binds: *const crate::data::SparseMemoryBind,
        }
    }
    impl_aggregate! {
        struct SparseImageOpaqueMemoryBindInfo {
            image: crate::data::Image,
            bind_count: u32,
            p_binds: *const crate::data::SparseMemoryBind,
        }
    }
    impl_aggregate! {
        struct SparseImageMemoryBindInfo {
            image: crate::data::Image,
            bind_count: u32,
            p_binds: *const crate::data::SparseImageMemoryBind,
        }
    }
    impl_aggregate! {
        struct BindSparseInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::BIND_SPARSE_INFO,
            p_next: *const c_void,
            wait_semaphore_count: u32,
            p_wait_semaphores: *const crate::data::Semaphore,
            buffer_bind_count: u32,
            p_buffer_binds: *const crate::data::SparseBufferMemoryBindInfo,
            image_opaque_bind_count: u32,
            p_image_opaque_binds: *const crate::data::SparseImageOpaqueMemoryBindInfo,
            image_bind_count: u32,
            p_image_binds: *const crate::data::SparseImageMemoryBindInfo,
            signal_semaphore_count: u32,
            p_signal_semaphores: *const crate::data::Semaphore,
        }
    }
    impl_aggregate! {
        struct ImageCopy {
            src_subresource: crate::data::ImageSubresourceLayers,
            src_offset: crate::data::Offset3D,
            dst_subresource: crate::data::ImageSubresourceLayers,
            dst_offset: crate::data::Offset3D,
            extent: crate::data::Extent3D,
        }
    }
    impl_aggregate! {
        struct ImageBlit {
            src_subresource: crate::data::ImageSubresourceLayers,
            src_offsets: [crate::data::Offset3D; 2],
            dst_subresource: crate::data::ImageSubresourceLayers,
            dst_offsets: [crate::data::Offset3D; 2],
        }
    }
    impl_aggregate! {
        struct BufferImageCopy {
            buffer_offset: crate::data::DeviceSize,
            buffer_row_length: u32,
            buffer_image_height: u32,
            image_subresource: crate::data::ImageSubresourceLayers,
            image_offset: crate::data::Offset3D,
            image_extent: crate::data::Extent3D,
        }
    }
    impl_aggregate! {
        struct ImageResolve {
            src_subresource: crate::data::ImageSubresourceLayers,
            src_offset: crate::data::Offset3D,
            dst_subresource: crate::data::ImageSubresourceLayers,
            dst_offset: crate::data::Offset3D,
            extent: crate::data::Extent3D,
        }
    }
    impl_aggregate! {
        struct ShaderModuleCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SHADER_MODULE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::ShaderModuleCreateFlags,
            code_size: usize,
            p_code: *const u32,
        }
    }
    impl_aggregate! {
        struct DescriptorSetLayoutBinding {
            binding: u32,
            descriptor_type: crate::data::DescriptorType,
            descriptor_count: u32,
            stage_flags: crate::data::ShaderStageFlags,
            p_immutable_samplers: *const crate::data::Sampler,
        }
    }
    impl_aggregate! {
        struct DescriptorSetLayoutCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::DescriptorSetLayoutCreateFlags,
            binding_count: u32,
            p_bindings: *const crate::data::DescriptorSetLayoutBinding,
        }
    }
    impl_aggregate! {
        struct DescriptorPoolSize {
            ty: crate::data::DescriptorType,
            descriptor_count: u32,
        }
    }
    impl_aggregate! {
        struct DescriptorPoolCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_POOL_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::DescriptorPoolCreateFlags,
            max_sets: u32,
            pool_size_count: u32,
            p_pool_sizes: *const crate::data::DescriptorPoolSize,
        }
    }
    impl_aggregate! {
        struct DescriptorSetAllocateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_ALLOCATE_INFO,
            p_next: *const c_void,
            descriptor_pool: crate::data::DescriptorPool,
            descriptor_set_count: u32,
            p_set_layouts: *const crate::data::DescriptorSetLayout,
        }
    }
    impl_aggregate! {
        struct SpecializationMapEntry {
            constant_id: u32,
            offset: u32,
            size: usize,
        }
    }
    impl_aggregate! {
        struct SpecializationInfo {
            map_entry_count: u32,
            p_map_entries: *const crate::data::SpecializationMapEntry,
            data_size: usize,
            p_data: *const c_void,
        }
    }
    impl_aggregate! {
        struct PipelineShaderStageCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_SHADER_STAGE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineShaderStageCreateFlags,
            stage: crate::data::ShaderStageFlagBits,
            module: crate::data::ShaderModule,
            p_name: *const c_char,
            p_specialization_info: *const crate::data::SpecializationInfo,
        }
    }
    impl_aggregate! {
        struct ComputePipelineCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::COMPUTE_PIPELINE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineCreateFlags,
            stage: crate::data::PipelineShaderStageCreateInfo,
            layout: crate::data::PipelineLayout,
            base_pipeline_handle: crate::data::Pipeline,
            base_pipeline_index: i32,
        }
    }
    impl_aggregate! {
        struct VertexInputBindingDescription {
            binding: u32,
            stride: u32,
            input_rate: crate::data::VertexInputRate,
        }
    }
    impl_aggregate! {
        struct VertexInputAttributeDescription {
            location: u32,
            binding: u32,
            format: crate::data::Format,
            offset: u32,
        }
    }
    impl_aggregate! {
        struct PipelineVertexInputStateCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineVertexInputStateCreateFlags,
            vertex_binding_description_count: u32,
            p_vertex_binding_descriptions: *const crate::data::VertexInputBindingDescription,
            vertex_attribute_description_count: u32,
            p_vertex_attribute_descriptions: *const crate::data::VertexInputAttributeDescription,
        }
    }
    impl_aggregate! {
        struct PipelineInputAssemblyStateCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineInputAssemblyStateCreateFlags,
            topology: crate::data::PrimitiveTopology,
            primitive_restart_enable: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineTessellationStateCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_TESSELLATION_STATE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineTessellationStateCreateFlags,
            patch_control_points: u32,
        }
    }
    impl_aggregate! {
        struct PipelineViewportStateCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineViewportStateCreateFlags,
            viewport_count: u32,
            p_viewports: *const crate::data::Viewport,
            scissor_count: u32,
            p_scissors: *const crate::data::Rect2D,
        }
    }
    impl_aggregate! {
        struct PipelineRasterizationStateCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineRasterizationStateCreateFlags,
            depth_clamp_enable: crate::data::Bool32,
            rasterizer_discard_enable: crate::data::Bool32,
            polygon_mode: crate::data::PolygonMode,
            cull_mode: crate::data::CullModeFlags,
            front_face: crate::data::FrontFace,
            depth_bias_enable: crate::data::Bool32,
            depth_bias_constant_factor: c_float,
            depth_bias_clamp: c_float,
            depth_bias_slope_factor: c_float,
            line_width: c_float,
        }
    }
    impl_aggregate! {
        struct PipelineMultisampleStateCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineMultisampleStateCreateFlags,
            rasterization_samples: crate::data::SampleCountFlagBits,
            sample_shading_enable: crate::data::Bool32,
            min_sample_shading: c_float,
            p_sample_mask: *const crate::data::SampleMask,
            alpha_to_coverage_enable: crate::data::Bool32,
            alpha_to_one_enable: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineColorBlendAttachmentState {
            blend_enable: crate::data::Bool32,
            src_color_blend_factor: crate::data::BlendFactor,
            dst_color_blend_factor: crate::data::BlendFactor,
            color_blend_op: crate::data::BlendOp,
            src_alpha_blend_factor: crate::data::BlendFactor,
            dst_alpha_blend_factor: crate::data::BlendFactor,
            alpha_blend_op: crate::data::BlendOp,
            color_write_mask: crate::data::ColorComponentFlags,
        }
    }
    impl_aggregate! {
        struct PipelineColorBlendStateCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineColorBlendStateCreateFlags,
            logic_op_enable: crate::data::Bool32,
            logic_op: crate::data::LogicOp,
            attachment_count: u32,
            p_attachments: *const crate::data::PipelineColorBlendAttachmentState,
            blend_constants: [c_float; 4],
        }
    }
    impl_aggregate! {
        struct PipelineDynamicStateCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_DYNAMIC_STATE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineDynamicStateCreateFlags,
            dynamic_state_count: u32,
            p_dynamic_states: *const crate::data::DynamicState,
        }
    }
    impl_aggregate! {
        struct StencilOpState {
            fail_op: crate::data::StencilOp,
            pass_op: crate::data::StencilOp,
            depth_fail_op: crate::data::StencilOp,
            compare_op: crate::data::CompareOp,
            compare_mask: u32,
            write_mask: u32,
            reference: u32,
        }
    }
    impl_aggregate! {
        struct PipelineDepthStencilStateCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineDepthStencilStateCreateFlags,
            depth_test_enable: crate::data::Bool32,
            depth_write_enable: crate::data::Bool32,
            depth_compare_op: crate::data::CompareOp,
            depth_bounds_test_enable: crate::data::Bool32,
            stencil_test_enable: crate::data::Bool32,
            front: crate::data::StencilOpState,
            back: crate::data::StencilOpState,
            min_depth_bounds: c_float,
            max_depth_bounds: c_float,
        }
    }
    impl_aggregate! {
        struct GraphicsPipelineCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::GRAPHICS_PIPELINE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineCreateFlags,
            stage_count: u32,
            p_stages: *const crate::data::PipelineShaderStageCreateInfo,
            p_vertex_input_state: *const crate::data::PipelineVertexInputStateCreateInfo,
            p_input_assembly_state: *const crate::data::PipelineInputAssemblyStateCreateInfo,
            p_tessellation_state: *const crate::data::PipelineTessellationStateCreateInfo,
            p_viewport_state: *const crate::data::PipelineViewportStateCreateInfo,
            p_rasterization_state: *const crate::data::PipelineRasterizationStateCreateInfo,
            p_multisample_state: *const crate::data::PipelineMultisampleStateCreateInfo,
            p_depth_stencil_state: *const crate::data::PipelineDepthStencilStateCreateInfo,
            p_color_blend_state: *const crate::data::PipelineColorBlendStateCreateInfo,
            p_dynamic_state: *const crate::data::PipelineDynamicStateCreateInfo,
            layout: crate::data::PipelineLayout,
            render_pass: crate::data::RenderPass,
            subpass: u32,
            base_pipeline_handle: crate::data::Pipeline,
            base_pipeline_index: i32,
        }
    }
    impl_aggregate! {
        struct PipelineCacheCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_CACHE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineCacheCreateFlags,
            initial_data_size: usize,
            p_initial_data: *const c_void,
        }
    }
    impl_aggregate! {
        struct PipelineCacheHeaderVersionOne {
            header_size: u32,
            header_version: crate::data::PipelineCacheHeaderVersion,
            vendor_id: u32,
            device_id: u32,
            pipeline_cache_uuid: [u8; 16],
        }
    }
    impl_aggregate! {
        struct PushConstantRange {
            stage_flags: crate::data::ShaderStageFlags,
            offset: u32,
            size: u32,
        }
    }
    impl_aggregate! {
        struct PipelineLayoutCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_LAYOUT_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PipelineLayoutCreateFlags,
            set_layout_count: u32,
            p_set_layouts: *const crate::data::DescriptorSetLayout,
            push_constant_range_count: u32,
            p_push_constant_ranges: *const crate::data::PushConstantRange,
        }
    }
    impl_aggregate! {
        struct SamplerCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SAMPLER_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::SamplerCreateFlags,
            mag_filter: crate::data::Filter,
            min_filter: crate::data::Filter,
            mipmap_mode: crate::data::SamplerMipmapMode,
            address_mode_u: crate::data::SamplerAddressMode,
            address_mode_v: crate::data::SamplerAddressMode,
            address_mode_w: crate::data::SamplerAddressMode,
            mip_lod_bias: c_float,
            anisotropy_enable: crate::data::Bool32,
            max_anisotropy: c_float,
            compare_enable: crate::data::Bool32,
            compare_op: crate::data::CompareOp,
            min_lod: c_float,
            max_lod: c_float,
            border_color: crate::data::BorderColor,
            unnormalized_coordinates: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct CommandPoolCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_POOL_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::CommandPoolCreateFlags,
            queue_family_index: u32,
        }
    }
    impl_aggregate! {
        struct CommandBufferAllocateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_BUFFER_ALLOCATE_INFO,
            p_next: *const c_void,
            command_pool: crate::data::CommandPool,
            level: crate::data::CommandBufferLevel,
            command_buffer_count: u32,
        }
    }
    impl_aggregate! {
        struct CommandBufferInheritanceInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_BUFFER_INHERITANCE_INFO,
            p_next: *const c_void,
            render_pass: crate::data::RenderPass,
            subpass: u32,
            framebuffer: crate::data::Framebuffer,
            occlusion_query_enable: crate::data::Bool32,
            query_flags: crate::data::QueryControlFlags,
            pipeline_statistics: crate::data::QueryPipelineStatisticFlags,
        }
    }
    impl_aggregate! {
        struct CommandBufferBeginInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_BUFFER_BEGIN_INFO,
            p_next: *const c_void,
            flags: crate::data::CommandBufferUsageFlags,
            p_inheritance_info: *const crate::data::CommandBufferInheritanceInfo,
        }
    }
    impl_aggregate! {
        struct RenderPassBeginInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_BEGIN_INFO,
            p_next: *const c_void,
            render_pass: crate::data::RenderPass,
            framebuffer: crate::data::Framebuffer,
            render_area: crate::data::Rect2D,
            clear_value_count: u32,
            p_clear_values: *const crate::data::ClearValue,
        }
    }
    impl_aggregate! {
        union ClearColorValue {
            float_32: [c_float; 4],
            int_32: [i32; 4],
            uint_32: [u32; 4],
        }
    }
    impl_aggregate! {
        struct ClearDepthStencilValue {
            depth: c_float,
            stencil: u32,
        }
    }
    impl_aggregate! {
        union ClearValue {
            color: crate::data::ClearColorValue,
            depth_stencil: crate::data::ClearDepthStencilValue,
        }
    }
    impl_aggregate! {
        struct ClearAttachment {
            aspect_mask: crate::data::ImageAspectFlags,
            color_attachment: u32,
            clear_value: crate::data::ClearValue,
        }
    }
    impl_aggregate! {
        struct AttachmentDescription {
            flags: crate::data::AttachmentDescriptionFlags,
            format: crate::data::Format,
            samples: crate::data::SampleCountFlagBits,
            load_op: crate::data::AttachmentLoadOp,
            store_op: crate::data::AttachmentStoreOp,
            stencil_load_op: crate::data::AttachmentLoadOp,
            stencil_store_op: crate::data::AttachmentStoreOp,
            initial_layout: crate::data::ImageLayout,
            final_layout: crate::data::ImageLayout,
        }
    }
    impl_aggregate! {
        struct AttachmentReference {
            attachment: u32,
            layout: crate::data::ImageLayout,
        }
    }
    impl_aggregate! {
        struct SubpassDescription {
            flags: crate::data::SubpassDescriptionFlags,
            pipeline_bind_point: crate::data::PipelineBindPoint,
            input_attachment_count: u32,
            p_input_attachments: *const crate::data::AttachmentReference,
            color_attachment_count: u32,
            p_color_attachments: *const crate::data::AttachmentReference,
            p_resolve_attachments: *const crate::data::AttachmentReference,
            p_depth_stencil_attachment: *const crate::data::AttachmentReference,
            preserve_attachment_count: u32,
            p_preserve_attachments: *const u32,
        }
    }
    impl_aggregate! {
        struct SubpassDependency {
            src_subpass: u32,
            dst_subpass: u32,
            src_stage_mask: crate::data::PipelineStageFlags,
            dst_stage_mask: crate::data::PipelineStageFlags,
            src_access_mask: crate::data::AccessFlags,
            dst_access_mask: crate::data::AccessFlags,
            dependency_flags: crate::data::DependencyFlags,
        }
    }
    impl_aggregate! {
        struct RenderPassCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::RenderPassCreateFlags,
            attachment_count: u32,
            p_attachments: *const crate::data::AttachmentDescription,
            subpass_count: u32,
            p_subpasses: *const crate::data::SubpassDescription,
            dependency_count: u32,
            p_dependencies: *const crate::data::SubpassDependency,
        }
    }
    impl_aggregate! {
        struct EventCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::EVENT_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::EventCreateFlags,
        }
    }
    impl_aggregate! {
        struct FenceCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::FENCE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::FenceCreateFlags,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFeatures {
            robust_buffer_access: crate::data::Bool32,
            full_draw_index_uint_32: crate::data::Bool32,
            image_cube_array: crate::data::Bool32,
            independent_blend: crate::data::Bool32,
            geometry_shader: crate::data::Bool32,
            tessellation_shader: crate::data::Bool32,
            sample_rate_shading: crate::data::Bool32,
            dual_src_blend: crate::data::Bool32,
            logic_op: crate::data::Bool32,
            multi_draw_indirect: crate::data::Bool32,
            draw_indirect_first_instance: crate::data::Bool32,
            depth_clamp: crate::data::Bool32,
            depth_bias_clamp: crate::data::Bool32,
            fill_mode_non_solid: crate::data::Bool32,
            depth_bounds: crate::data::Bool32,
            wide_lines: crate::data::Bool32,
            large_points: crate::data::Bool32,
            alpha_to_one: crate::data::Bool32,
            multi_viewport: crate::data::Bool32,
            sampler_anisotropy: crate::data::Bool32,
            texture_compression_etc_2: crate::data::Bool32,
            texture_compression_astc_ldr: crate::data::Bool32,
            texture_compression_bc: crate::data::Bool32,
            occlusion_query_precise: crate::data::Bool32,
            pipeline_statistics_query: crate::data::Bool32,
            vertex_pipeline_stores_and_atomics: crate::data::Bool32,
            fragment_stores_and_atomics: crate::data::Bool32,
            shader_tessellation_and_geometry_point_size: crate::data::Bool32,
            shader_image_gather_extended: crate::data::Bool32,
            shader_storage_image_extended_formats: crate::data::Bool32,
            shader_storage_image_multisample: crate::data::Bool32,
            shader_storage_image_read_without_format: crate::data::Bool32,
            shader_storage_image_write_without_format: crate::data::Bool32,
            shader_uniform_buffer_array_dynamic_indexing: crate::data::Bool32,
            shader_sampled_image_array_dynamic_indexing: crate::data::Bool32,
            shader_storage_buffer_array_dynamic_indexing: crate::data::Bool32,
            shader_storage_image_array_dynamic_indexing: crate::data::Bool32,
            shader_clip_distance: crate::data::Bool32,
            shader_cull_distance: crate::data::Bool32,
            shader_float_64: crate::data::Bool32,
            shader_int_64: crate::data::Bool32,
            shader_int_16: crate::data::Bool32,
            shader_resource_residency: crate::data::Bool32,
            shader_resource_min_lod: crate::data::Bool32,
            sparse_binding: crate::data::Bool32,
            sparse_residency_buffer: crate::data::Bool32,
            sparse_residency_image_2d: crate::data::Bool32,
            sparse_residency_image_3d: crate::data::Bool32,
            sparse_residency_2_samples: crate::data::Bool32,
            sparse_residency_4_samples: crate::data::Bool32,
            sparse_residency_8_samples: crate::data::Bool32,
            sparse_residency_16_samples: crate::data::Bool32,
            sparse_residency_aliased: crate::data::Bool32,
            variable_multisample_rate: crate::data::Bool32,
            inherited_queries: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSparseProperties {
            residency_standard_2d_block_shape: crate::data::Bool32,
            residency_standard_2d_multisample_block_shape: crate::data::Bool32,
            residency_standard_3d_block_shape: crate::data::Bool32,
            residency_aligned_mip_size: crate::data::Bool32,
            residency_non_resident_strict: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceLimits {
            max_image_dimension_1d: u32,
            max_image_dimension_2d: u32,
            max_image_dimension_3d: u32,
            max_image_dimension_cube: u32,
            max_image_array_layers: u32,
            max_texel_buffer_elements: u32,
            max_uniform_buffer_range: u32,
            max_storage_buffer_range: u32,
            max_push_constants_size: u32,
            max_memory_allocation_count: u32,
            max_sampler_allocation_count: u32,
            buffer_image_granularity: crate::data::DeviceSize,
            sparse_address_space_size: crate::data::DeviceSize,
            max_bound_descriptor_sets: u32,
            max_per_stage_descriptor_samplers: u32,
            max_per_stage_descriptor_uniform_buffers: u32,
            max_per_stage_descriptor_storage_buffers: u32,
            max_per_stage_descriptor_sampled_images: u32,
            max_per_stage_descriptor_storage_images: u32,
            max_per_stage_descriptor_input_attachments: u32,
            max_per_stage_resources: u32,
            max_descriptor_set_samplers: u32,
            max_descriptor_set_uniform_buffers: u32,
            max_descriptor_set_uniform_buffers_dynamic: u32,
            max_descriptor_set_storage_buffers: u32,
            max_descriptor_set_storage_buffers_dynamic: u32,
            max_descriptor_set_sampled_images: u32,
            max_descriptor_set_storage_images: u32,
            max_descriptor_set_input_attachments: u32,
            max_vertex_input_attributes: u32,
            max_vertex_input_bindings: u32,
            max_vertex_input_attribute_offset: u32,
            max_vertex_input_binding_stride: u32,
            max_vertex_output_components: u32,
            max_tessellation_generation_level: u32,
            max_tessellation_patch_size: u32,
            max_tessellation_control_per_vertex_input_components: u32,
            max_tessellation_control_per_vertex_output_components: u32,
            max_tessellation_control_per_patch_output_components: u32,
            max_tessellation_control_total_output_components: u32,
            max_tessellation_evaluation_input_components: u32,
            max_tessellation_evaluation_output_components: u32,
            max_geometry_shader_invocations: u32,
            max_geometry_input_components: u32,
            max_geometry_output_components: u32,
            max_geometry_output_vertices: u32,
            max_geometry_total_output_components: u32,
            max_fragment_input_components: u32,
            max_fragment_output_attachments: u32,
            max_fragment_dual_src_attachments: u32,
            max_fragment_combined_output_resources: u32,
            max_compute_shared_memory_size: u32,
            max_compute_work_group_count: [u32; 3],
            max_compute_work_group_invocations: u32,
            max_compute_work_group_size: [u32; 3],
            sub_pixel_precision_bits: u32,
            sub_texel_precision_bits: u32,
            mipmap_precision_bits: u32,
            max_draw_indexed_index_value: u32,
            max_draw_indirect_count: u32,
            max_sampler_lod_bias: c_float,
            max_sampler_anisotropy: c_float,
            max_viewports: u32,
            max_viewport_dimensions: [u32; 2],
            viewport_bounds_range: [c_float; 2],
            viewport_sub_pixel_bits: u32,
            min_memory_map_alignment: usize,
            min_texel_buffer_offset_alignment: crate::data::DeviceSize,
            min_uniform_buffer_offset_alignment: crate::data::DeviceSize,
            min_storage_buffer_offset_alignment: crate::data::DeviceSize,
            min_texel_offset: i32,
            max_texel_offset: u32,
            min_texel_gather_offset: i32,
            max_texel_gather_offset: u32,
            min_interpolation_offset: c_float,
            max_interpolation_offset: c_float,
            sub_pixel_interpolation_offset_bits: u32,
            max_framebuffer_width: u32,
            max_framebuffer_height: u32,
            max_framebuffer_layers: u32,
            framebuffer_color_sample_counts: crate::data::SampleCountFlags,
            framebuffer_depth_sample_counts: crate::data::SampleCountFlags,
            framebuffer_stencil_sample_counts: crate::data::SampleCountFlags,
            framebuffer_no_attachments_sample_counts: crate::data::SampleCountFlags,
            max_color_attachments: u32,
            sampled_image_color_sample_counts: crate::data::SampleCountFlags,
            sampled_image_integer_sample_counts: crate::data::SampleCountFlags,
            sampled_image_depth_sample_counts: crate::data::SampleCountFlags,
            sampled_image_stencil_sample_counts: crate::data::SampleCountFlags,
            storage_image_sample_counts: crate::data::SampleCountFlags,
            max_sample_mask_words: u32,
            timestamp_compute_and_graphics: crate::data::Bool32,
            timestamp_period: c_float,
            max_clip_distances: u32,
            max_cull_distances: u32,
            max_combined_clip_and_cull_distances: u32,
            discrete_queue_priorities: u32,
            point_size_range: [c_float; 2],
            line_width_range: [c_float; 2],
            point_size_granularity: c_float,
            line_width_granularity: c_float,
            strict_lines: crate::data::Bool32,
            standard_sample_locations: crate::data::Bool32,
            optimal_buffer_copy_offset_alignment: crate::data::DeviceSize,
            optimal_buffer_copy_row_pitch_alignment: crate::data::DeviceSize,
            non_coherent_atom_size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct SemaphoreCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SEMAPHORE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::SemaphoreCreateFlags,
        }
    }
    impl_aggregate! {
        struct QueryPoolCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::QUERY_POOL_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::QueryPoolCreateFlags,
            query_type: crate::data::QueryType,
            query_count: u32,
            pipeline_statistics: crate::data::QueryPipelineStatisticFlags,
        }
    }
    impl_aggregate! {
        struct FramebufferCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::FRAMEBUFFER_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::FramebufferCreateFlags,
            render_pass: crate::data::RenderPass,
            attachment_count: u32,
            p_attachments: *const crate::data::ImageView,
            width: u32,
            height: u32,
            layers: u32,
        }
    }
    impl_aggregate! {
        struct DrawIndirectCommand {
            vertex_count: u32,
            instance_count: u32,
            first_vertex: u32,
            first_instance: u32,
        }
    }
    impl_aggregate! {
        struct DrawIndexedIndirectCommand {
            index_count: u32,
            instance_count: u32,
            first_index: u32,
            vertex_offset: i32,
            first_instance: u32,
        }
    }
    impl_aggregate! {
        struct DispatchIndirectCommand {
            x: u32,
            y: u32,
            z: u32,
        }
    }
    impl_aggregate! {
        struct MultiDrawInfoEXT {
            first_vertex: u32,
            vertex_count: u32,
        }
    }
    impl_aggregate! {
        struct MultiDrawIndexedInfoEXT {
            first_index: u32,
            index_count: u32,
            vertex_offset: i32,
        }
    }
    impl_aggregate! {
        struct SubmitInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SUBMIT_INFO,
            p_next: *const c_void,
            wait_semaphore_count: u32,
            p_wait_semaphores: *const crate::data::Semaphore,
            p_wait_dst_stage_mask: *const crate::data::PipelineStageFlags,
            command_buffer_count: u32,
            p_command_buffers: *const crate::data::CommandBuffer,
            signal_semaphore_count: u32,
            p_signal_semaphores: *const crate::data::Semaphore,
        }
    }
    impl_aggregate! {
        struct DisplayPropertiesKHR {
            display: crate::data::DisplayKHR,
            display_name: *const c_char,
            physical_dimensions: crate::data::Extent2D,
            physical_resolution: crate::data::Extent2D,
            supported_transforms: crate::data::SurfaceTransformFlagsKHR,
            plane_reorder_possible: crate::data::Bool32,
            persistent_content: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct DisplayPlanePropertiesKHR {
            current_display: crate::data::DisplayKHR,
            current_stack_index: u32,
        }
    }
    impl_aggregate! {
        struct DisplayModeParametersKHR {
            visible_region: crate::data::Extent2D,
            refresh_rate: u32,
        }
    }
    impl_aggregate! {
        struct DisplayModePropertiesKHR {
            display_mode: crate::data::DisplayModeKHR,
            parameters: crate::data::DisplayModeParametersKHR,
        }
    }
    impl_aggregate! {
        struct DisplayModeCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_MODE_CREATE_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::DisplayModeCreateFlagsKHR,
            parameters: crate::data::DisplayModeParametersKHR,
        }
    }
    impl_aggregate! {
        struct DisplayPlaneCapabilitiesKHR {
            supported_alpha: crate::data::DisplayPlaneAlphaFlagsKHR,
            min_src_position: crate::data::Offset2D,
            max_src_position: crate::data::Offset2D,
            min_src_extent: crate::data::Extent2D,
            max_src_extent: crate::data::Extent2D,
            min_dst_position: crate::data::Offset2D,
            max_dst_position: crate::data::Offset2D,
            min_dst_extent: crate::data::Extent2D,
            max_dst_extent: crate::data::Extent2D,
        }
    }
    impl_aggregate! {
        struct DisplaySurfaceCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_SURFACE_CREATE_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::DisplaySurfaceCreateFlagsKHR,
            display_mode: crate::data::DisplayModeKHR,
            plane_index: u32,
            plane_stack_index: u32,
            transform: crate::data::SurfaceTransformFlagBitsKHR,
            global_alpha: c_float,
            alpha_mode: crate::data::DisplayPlaneAlphaFlagBitsKHR,
            image_extent: crate::data::Extent2D,
        }
    }
    impl_aggregate! {
        struct DisplayPresentInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_PRESENT_INFO_KHR,
            p_next: *const c_void,
            src_rect: crate::data::Rect2D,
            dst_rect: crate::data::Rect2D,
            persistent: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct SurfaceCapabilitiesKHR {
            min_image_count: u32,
            max_image_count: u32,
            current_extent: crate::data::Extent2D,
            min_image_extent: crate::data::Extent2D,
            max_image_extent: crate::data::Extent2D,
            max_image_array_layers: u32,
            supported_transforms: crate::data::SurfaceTransformFlagsKHR,
            current_transform: crate::data::SurfaceTransformFlagBitsKHR,
            supported_composite_alpha: crate::data::CompositeAlphaFlagsKHR,
            supported_usage_flags: crate::data::ImageUsageFlags,
        }
    }
    impl_aggregate! {
        struct AndroidSurfaceCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::ANDROID_SURFACE_CREATE_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::AndroidSurfaceCreateFlagsKHR,
            window: *mut ANativeWindow,
        }
    }
    impl_aggregate! {
        struct ViSurfaceCreateInfoNN {
            s_type: crate::data::StructureType = crate::data::StructureType::VI_SURFACE_CREATE_INFO_NN,
            p_next: *const c_void,
            flags: crate::data::ViSurfaceCreateFlagsNN,
            window: *mut c_void,
        }
    }
    impl_aggregate! {
        struct WaylandSurfaceCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::WAYLAND_SURFACE_CREATE_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::WaylandSurfaceCreateFlagsKHR,
            display: *mut wl_display,
            surface: *mut wl_surface,
        }
    }
    impl_aggregate! {
        struct Win32SurfaceCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::WIN32_SURFACE_CREATE_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::Win32SurfaceCreateFlagsKHR,
            hinstance: HINSTANCE,
            hwnd: HWND,
        }
    }
    impl_aggregate! {
        struct XlibSurfaceCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::XLIB_SURFACE_CREATE_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::XlibSurfaceCreateFlagsKHR,
            dpy: *mut Display,
            window: Window,
        }
    }
    impl_aggregate! {
        struct XcbSurfaceCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::XCB_SURFACE_CREATE_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::XcbSurfaceCreateFlagsKHR,
            connection: *mut xcb_connection_t,
            window: xcb_window_t,
        }
    }
    impl_aggregate! {
        struct DirectFBSurfaceCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DIRECTFB_SURFACE_CREATE_INFO_EXT,
            p_next: *const c_void,
            flags: crate::data::DirectFBSurfaceCreateFlagsEXT,
            dfb: *mut IDirectFB,
            surface: *mut IDirectFBSurface,
        }
    }
    impl_aggregate! {
        struct ImagePipeSurfaceCreateInfoFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA,
            p_next: *const c_void,
            flags: crate::data::ImagePipeSurfaceCreateFlagsFUCHSIA,
            image_pipe_handle: zx_handle_t,
        }
    }
    impl_aggregate! {
        struct StreamDescriptorSurfaceCreateInfoGGP {
            s_type: crate::data::StructureType = crate::data::StructureType::STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP,
            p_next: *const c_void,
            flags: crate::data::StreamDescriptorSurfaceCreateFlagsGGP,
            stream_descriptor: GgpStreamDescriptor,
        }
    }
    impl_aggregate! {
        struct ScreenSurfaceCreateInfoQNX {
            s_type: crate::data::StructureType = crate::data::StructureType::SCREEN_SURFACE_CREATE_INFO_QNX,
            p_next: *const c_void,
            flags: crate::data::ScreenSurfaceCreateFlagsQNX,
            context: *mut _screen_context,
            window: *mut _screen_window,
        }
    }
    impl_aggregate! {
        struct SurfaceFormatKHR {
            format: crate::data::Format,
            color_space: crate::data::ColorSpaceKHR,
        }
    }
    impl_aggregate! {
        struct SwapchainCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::SWAPCHAIN_CREATE_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::SwapchainCreateFlagsKHR,
            surface: crate::data::SurfaceKHR,
            min_image_count: u32,
            image_format: crate::data::Format,
            image_color_space: crate::data::ColorSpaceKHR,
            image_extent: crate::data::Extent2D,
            image_array_layers: u32,
            image_usage: crate::data::ImageUsageFlags,
            image_sharing_mode: crate::data::SharingMode,
            queue_family_index_count: u32,
            p_queue_family_indices: *const u32,
            pre_transform: crate::data::SurfaceTransformFlagBitsKHR,
            composite_alpha: crate::data::CompositeAlphaFlagBitsKHR,
            present_mode: crate::data::PresentModeKHR,
            clipped: crate::data::Bool32,
            old_swapchain: crate::data::SwapchainKHR,
        }
    }
    impl_aggregate! {
        struct PresentInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PRESENT_INFO_KHR,
            p_next: *const c_void,
            wait_semaphore_count: u32,
            p_wait_semaphores: *const crate::data::Semaphore,
            swapchain_count: u32,
            p_swapchains: *const crate::data::SwapchainKHR,
            p_image_indices: *const u32,
            p_results: *mut crate::data::Result,
        }
    }
    impl_aggregate! {
        struct DebugReportCallbackCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
            p_next: *const c_void,
            flags: crate::data::DebugReportFlagsEXT,
            pfn_callback: crate::pfn::DebugReportCallbackEXT,
            p_user_data: *mut c_void,
        }
    }
    impl_aggregate! {
        struct ValidationFlagsEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VALIDATION_FLAGS_EXT,
            p_next: *const c_void,
            disabled_validation_check_count: u32,
            p_disabled_validation_checks: *const crate::data::ValidationCheckEXT,
        }
    }
    impl_aggregate! {
        struct ValidationFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VALIDATION_FEATURES_EXT,
            p_next: *const c_void,
            enabled_validation_feature_count: u32,
            p_enabled_validation_features: *const crate::data::ValidationFeatureEnableEXT,
            disabled_validation_feature_count: u32,
            p_disabled_validation_features: *const crate::data::ValidationFeatureDisableEXT,
        }
    }
    impl_aggregate! {
        struct PipelineRasterizationStateRasterizationOrderAMD {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
            p_next: *const c_void,
            rasterization_order: crate::data::RasterizationOrderAMD,
        }
    }
    impl_aggregate! {
        struct DebugMarkerObjectNameInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
            p_next: *const c_void,
            object_type: crate::data::DebugReportObjectTypeEXT,
            object: u64,
            p_object_name: *const c_char,
        }
    }
    impl_aggregate! {
        struct DebugMarkerObjectTagInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
            p_next: *const c_void,
            object_type: crate::data::DebugReportObjectTypeEXT,
            object: u64,
            tag_name: u64,
            tag_size: usize,
            p_tag: *const c_void,
        }
    }
    impl_aggregate! {
        struct DebugMarkerMarkerInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_MARKER_MARKER_INFO_EXT,
            p_next: *const c_void,
            p_marker_name: *const c_char,
            color: [c_float; 4],
        }
    }
    impl_aggregate! {
        struct DedicatedAllocationImageCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
            p_next: *const c_void,
            dedicated_allocation: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct DedicatedAllocationBufferCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
            p_next: *const c_void,
            dedicated_allocation: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct DedicatedAllocationMemoryAllocateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
            p_next: *const c_void,
            image: crate::data::Image,
            buffer: crate::data::Buffer,
        }
    }
    impl_aggregate! {
        struct ExternalImageFormatPropertiesNV {
            image_format_properties: crate::data::ImageFormatProperties,
            external_memory_features: crate::data::ExternalMemoryFeatureFlagsNV,
            export_from_imported_handle_types: crate::data::ExternalMemoryHandleTypeFlagsNV,
            compatible_handle_types: crate::data::ExternalMemoryHandleTypeFlagsNV,
        }
    }
    impl_aggregate! {
        struct ExternalMemoryImageCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
            p_next: *const c_void,
            handle_types: crate::data::ExternalMemoryHandleTypeFlagsNV,
        }
    }
    impl_aggregate! {
        struct ExportMemoryAllocateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_MEMORY_ALLOCATE_INFO_NV,
            p_next: *const c_void,
            handle_types: crate::data::ExternalMemoryHandleTypeFlagsNV,
        }
    }
    impl_aggregate! {
        struct ImportMemoryWin32HandleInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
            p_next: *const c_void,
            handle_type: crate::data::ExternalMemoryHandleTypeFlagsNV,
            handle: HANDLE,
        }
    }
    impl_aggregate! {
        struct ExportMemoryWin32HandleInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
            p_next: *const c_void,
            p_attributes: *const SECURITY_ATTRIBUTES,
            dw_access: DWORD,
        }
    }
    impl_aggregate! {
        struct Win32KeyedMutexAcquireReleaseInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
            p_next: *const c_void,
            acquire_count: u32,
            p_acquire_syncs: *const crate::data::DeviceMemory,
            p_acquire_keys: *const u64,
            p_acquire_timeout_milliseconds: *const u32,
            release_count: u32,
            p_release_syncs: *const crate::data::DeviceMemory,
            p_release_keys: *const u64,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV,
            p_next: *mut c_void,
            device_generated_commands: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct DevicePrivateDataCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_PRIVATE_DATA_CREATE_INFO,
            p_next: *const c_void,
            private_data_slot_request_count: u32,
        }
    }
    impl_aggregate! {
        struct PrivateDataSlotCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PRIVATE_DATA_SLOT_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::PrivateDataSlotCreateFlags,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePrivateDataFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
            p_next: *mut c_void,
            private_data: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV,
            p_next: *mut c_void,
            max_graphics_shader_group_count: u32,
            max_indirect_sequence_count: u32,
            max_indirect_commands_token_count: u32,
            max_indirect_commands_stream_count: u32,
            max_indirect_commands_token_offset: u32,
            max_indirect_commands_stream_stride: u32,
            min_sequences_count_buffer_offset_alignment: u32,
            min_sequences_index_buffer_offset_alignment: u32,
            min_indirect_commands_buffer_offset_alignment: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMultiDrawPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT,
            p_next: *mut c_void,
            max_multi_draw_count: u32,
        }
    }
    impl_aggregate! {
        struct GraphicsShaderGroupCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::GRAPHICS_SHADER_GROUP_CREATE_INFO_NV,
            p_next: *const c_void,
            stage_count: u32,
            p_stages: *const crate::data::PipelineShaderStageCreateInfo,
            p_vertex_input_state: *const crate::data::PipelineVertexInputStateCreateInfo,
            p_tessellation_state: *const crate::data::PipelineTessellationStateCreateInfo,
        }
    }
    impl_aggregate! {
        struct GraphicsPipelineShaderGroupsCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV,
            p_next: *const c_void,
            group_count: u32,
            p_groups: *const crate::data::GraphicsShaderGroupCreateInfoNV,
            pipeline_count: u32,
            p_pipelines: *const crate::data::Pipeline,
        }
    }
    impl_aggregate! {
        struct BindShaderGroupIndirectCommandNV {
            group_index: u32,
        }
    }
    impl_aggregate! {
        struct BindIndexBufferIndirectCommandNV {
            buffer_address: crate::data::DeviceAddress,
            size: u32,
            index_type: crate::data::IndexType,
        }
    }
    impl_aggregate! {
        struct BindVertexBufferIndirectCommandNV {
            buffer_address: crate::data::DeviceAddress,
            size: u32,
            stride: u32,
        }
    }
    impl_aggregate! {
        struct SetStateFlagsIndirectCommandNV {
            data: u32,
        }
    }
    impl_aggregate! {
        struct IndirectCommandsStreamNV {
            buffer: crate::data::Buffer,
            offset: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct IndirectCommandsLayoutTokenNV {
            s_type: crate::data::StructureType = crate::data::StructureType::INDIRECT_COMMANDS_LAYOUT_TOKEN_NV,
            p_next: *const c_void,
            token_type: crate::data::IndirectCommandsTokenTypeNV,
            stream: u32,
            offset: u32,
            vertex_binding_unit: u32,
            vertex_dynamic_stride: crate::data::Bool32,
            pushconstant_pipeline_layout: crate::data::PipelineLayout,
            pushconstant_shader_stage_flags: crate::data::ShaderStageFlags,
            pushconstant_offset: u32,
            pushconstant_size: u32,
            indirect_state_flags: crate::data::IndirectStateFlagsNV,
            index_type_count: u32,
            p_index_types: *const crate::data::IndexType,
            p_index_type_values: *const u32,
        }
    }
    impl_aggregate! {
        struct IndirectCommandsLayoutCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV,
            p_next: *const c_void,
            flags: crate::data::IndirectCommandsLayoutUsageFlagsNV,
            pipeline_bind_point: crate::data::PipelineBindPoint,
            token_count: u32,
            p_tokens: *const crate::data::IndirectCommandsLayoutTokenNV,
            stream_count: u32,
            p_stream_strides: *const u32,
        }
    }
    impl_aggregate! {
        struct GeneratedCommandsInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::GENERATED_COMMANDS_INFO_NV,
            p_next: *const c_void,
            pipeline_bind_point: crate::data::PipelineBindPoint,
            pipeline: crate::data::Pipeline,
            indirect_commands_layout: crate::data::IndirectCommandsLayoutNV,
            stream_count: u32,
            p_streams: *const crate::data::IndirectCommandsStreamNV,
            sequences_count: u32,
            preprocess_buffer: crate::data::Buffer,
            preprocess_offset: crate::data::DeviceSize,
            preprocess_size: crate::data::DeviceSize,
            sequences_count_buffer: crate::data::Buffer,
            sequences_count_offset: crate::data::DeviceSize,
            sequences_index_buffer: crate::data::Buffer,
            sequences_index_offset: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct GeneratedCommandsMemoryRequirementsInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV,
            p_next: *const c_void,
            pipeline_bind_point: crate::data::PipelineBindPoint,
            pipeline: crate::data::Pipeline,
            indirect_commands_layout: crate::data::IndirectCommandsLayoutNV,
            max_sequences_count: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFeatures2 {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FEATURES_2,
            p_next: *mut c_void,
            features: crate::data::PhysicalDeviceFeatures,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceProperties2 {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PROPERTIES_2,
            p_next: *mut c_void,
            properties: crate::data::PhysicalDeviceProperties,
        }
    }
    impl_aggregate! {
        struct FormatProperties2 {
            s_type: crate::data::StructureType = crate::data::StructureType::FORMAT_PROPERTIES_2,
            p_next: *mut c_void,
            format_properties: crate::data::FormatProperties,
        }
    }
    impl_aggregate! {
        struct ImageFormatProperties2 {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_FORMAT_PROPERTIES_2,
            p_next: *mut c_void,
            image_format_properties: crate::data::ImageFormatProperties,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceImageFormatInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
            p_next: *const c_void,
            format: crate::data::Format,
            ty: crate::data::ImageType,
            tiling: crate::data::ImageTiling,
            usage: crate::data::ImageUsageFlags,
            flags: crate::data::ImageCreateFlags,
        }
    }
    impl_aggregate! {
        struct QueueFamilyProperties2 {
            s_type: crate::data::StructureType = crate::data::StructureType::QUEUE_FAMILY_PROPERTIES_2,
            p_next: *mut c_void,
            queue_family_properties: crate::data::QueueFamilyProperties,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMemoryProperties2 {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
            p_next: *mut c_void,
            memory_properties: crate::data::PhysicalDeviceMemoryProperties,
        }
    }
    impl_aggregate! {
        struct SparseImageFormatProperties2 {
            s_type: crate::data::StructureType = crate::data::StructureType::SPARSE_IMAGE_FORMAT_PROPERTIES_2,
            p_next: *mut c_void,
            properties: crate::data::SparseImageFormatProperties,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSparseImageFormatInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
            p_next: *const c_void,
            format: crate::data::Format,
            ty: crate::data::ImageType,
            samples: crate::data::SampleCountFlagBits,
            usage: crate::data::ImageUsageFlags,
            tiling: crate::data::ImageTiling,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePushDescriptorPropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
            p_next: *mut c_void,
            max_push_descriptors: u32,
        }
    }
    impl_aggregate! {
        struct ConformanceVersion {
            major: u8,
            minor: u8,
            subminor: u8,
            patch: u8,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDriverProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DRIVER_PROPERTIES,
            p_next: *mut c_void,
            driver_id: crate::data::DriverId,
            driver_name: [c_char; 256],
            driver_info: [c_char; 256],
            conformance_version: crate::data::ConformanceVersion,
        }
    }
    impl_aggregate! {
        struct PresentRegionsKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PRESENT_REGIONS_KHR,
            p_next: *const c_void,
            swapchain_count: u32,
            p_regions: *const crate::data::PresentRegionKHR,
        }
    }
    impl_aggregate! {
        struct PresentRegionKHR {
            rectangle_count: u32,
            p_rectangles: *const crate::data::RectLayerKHR,
        }
    }
    impl_aggregate! {
        struct RectLayerKHR {
            offset: crate::data::Offset2D,
            extent: crate::data::Extent2D,
            layer: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceVariablePointersFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
            p_next: *mut c_void,
            variable_pointers_storage_buffer: crate::data::Bool32,
            variable_pointers: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct ExternalMemoryProperties {
            external_memory_features: crate::data::ExternalMemoryFeatureFlags,
            export_from_imported_handle_types: crate::data::ExternalMemoryHandleTypeFlags,
            compatible_handle_types: crate::data::ExternalMemoryHandleTypeFlags,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceExternalImageFormatInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
            p_next: *const c_void,
            handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct ExternalImageFormatProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_IMAGE_FORMAT_PROPERTIES,
            p_next: *mut c_void,
            external_memory_properties: crate::data::ExternalMemoryProperties,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceExternalBufferInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
            p_next: *const c_void,
            flags: crate::data::BufferCreateFlags,
            usage: crate::data::BufferUsageFlags,
            handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct ExternalBufferProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_BUFFER_PROPERTIES,
            p_next: *mut c_void,
            external_memory_properties: crate::data::ExternalMemoryProperties,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceIDProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_ID_PROPERTIES,
            p_next: *mut c_void,
            device_uuid: [u8; 16],
            driver_uuid: [u8; 16],
            device_luid: [u8; 8],
            device_node_mask: u32,
            device_luid_valid: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct ExternalMemoryImageCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
            p_next: *const c_void,
            handle_types: crate::data::ExternalMemoryHandleTypeFlags,
        }
    }
    impl_aggregate! {
        struct ExternalMemoryBufferCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
            p_next: *const c_void,
            handle_types: crate::data::ExternalMemoryHandleTypeFlags,
        }
    }
    impl_aggregate! {
        struct ExportMemoryAllocateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_MEMORY_ALLOCATE_INFO,
            p_next: *const c_void,
            handle_types: crate::data::ExternalMemoryHandleTypeFlags,
        }
    }
    impl_aggregate! {
        struct ImportMemoryWin32HandleInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
            p_next: *const c_void,
            handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
            handle: HANDLE,
            name: LPCWSTR,
        }
    }
    impl_aggregate! {
        struct ExportMemoryWin32HandleInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
            p_next: *const c_void,
            p_attributes: *const SECURITY_ATTRIBUTES,
            dw_access: DWORD,
            name: LPCWSTR,
        }
    }
    impl_aggregate! {
        struct ImportMemoryZirconHandleInfoFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA,
            p_next: *const c_void,
            handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
            handle: zx_handle_t,
        }
    }
    impl_aggregate! {
        struct MemoryZirconHandlePropertiesFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA,
            p_next: *mut c_void,
            memory_type_bits: u32,
        }
    }
    impl_aggregate! {
        struct MemoryGetZirconHandleInfoFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA,
            p_next: *const c_void,
            memory: crate::data::DeviceMemory,
            handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct MemoryWin32HandlePropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
            p_next: *mut c_void,
            memory_type_bits: u32,
        }
    }
    impl_aggregate! {
        struct MemoryGetWin32HandleInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_GET_WIN32_HANDLE_INFO_KHR,
            p_next: *const c_void,
            memory: crate::data::DeviceMemory,
            handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct ImportMemoryFdInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_MEMORY_FD_INFO_KHR,
            p_next: *const c_void,
            handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
            fd: c_int,
        }
    }
    impl_aggregate! {
        struct MemoryFdPropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_FD_PROPERTIES_KHR,
            p_next: *mut c_void,
            memory_type_bits: u32,
        }
    }
    impl_aggregate! {
        struct MemoryGetFdInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_GET_FD_INFO_KHR,
            p_next: *const c_void,
            memory: crate::data::DeviceMemory,
            handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct Win32KeyedMutexAcquireReleaseInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
            p_next: *const c_void,
            acquire_count: u32,
            p_acquire_syncs: *const crate::data::DeviceMemory,
            p_acquire_keys: *const u64,
            p_acquire_timeouts: *const u32,
            release_count: u32,
            p_release_syncs: *const crate::data::DeviceMemory,
            p_release_keys: *const u64,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceExternalSemaphoreInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
            p_next: *const c_void,
            handle_type: crate::data::ExternalSemaphoreHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct ExternalSemaphoreProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_SEMAPHORE_PROPERTIES,
            p_next: *mut c_void,
            export_from_imported_handle_types: crate::data::ExternalSemaphoreHandleTypeFlags,
            compatible_handle_types: crate::data::ExternalSemaphoreHandleTypeFlags,
            external_semaphore_features: crate::data::ExternalSemaphoreFeatureFlags,
        }
    }
    impl_aggregate! {
        struct ExportSemaphoreCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_SEMAPHORE_CREATE_INFO,
            p_next: *const c_void,
            handle_types: crate::data::ExternalSemaphoreHandleTypeFlags,
        }
    }
    impl_aggregate! {
        struct ImportSemaphoreWin32HandleInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
            p_next: *const c_void,
            semaphore: crate::data::Semaphore,
            flags: crate::data::SemaphoreImportFlags,
            handle_type: crate::data::ExternalSemaphoreHandleTypeFlagBits,
            handle: HANDLE,
            name: LPCWSTR,
        }
    }
    impl_aggregate! {
        struct ExportSemaphoreWin32HandleInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
            p_next: *const c_void,
            p_attributes: *const SECURITY_ATTRIBUTES,
            dw_access: DWORD,
            name: LPCWSTR,
        }
    }
    impl_aggregate! {
        struct D3D12FenceSubmitInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::D3D12_FENCE_SUBMIT_INFO_KHR,
            p_next: *const c_void,
            wait_semaphore_values_count: u32,
            p_wait_semaphore_values: *const u64,
            signal_semaphore_values_count: u32,
            p_signal_semaphore_values: *const u64,
        }
    }
    impl_aggregate! {
        struct SemaphoreGetWin32HandleInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
            p_next: *const c_void,
            semaphore: crate::data::Semaphore,
            handle_type: crate::data::ExternalSemaphoreHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct ImportSemaphoreFdInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_SEMAPHORE_FD_INFO_KHR,
            p_next: *const c_void,
            semaphore: crate::data::Semaphore,
            flags: crate::data::SemaphoreImportFlags,
            handle_type: crate::data::ExternalSemaphoreHandleTypeFlagBits,
            fd: c_int,
        }
    }
    impl_aggregate! {
        struct SemaphoreGetFdInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::SEMAPHORE_GET_FD_INFO_KHR,
            p_next: *const c_void,
            semaphore: crate::data::Semaphore,
            handle_type: crate::data::ExternalSemaphoreHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct ImportSemaphoreZirconHandleInfoFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA,
            p_next: *const c_void,
            semaphore: crate::data::Semaphore,
            flags: crate::data::SemaphoreImportFlags,
            handle_type: crate::data::ExternalSemaphoreHandleTypeFlagBits,
            zircon_handle: zx_handle_t,
        }
    }
    impl_aggregate! {
        struct SemaphoreGetZirconHandleInfoFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA,
            p_next: *const c_void,
            semaphore: crate::data::Semaphore,
            handle_type: crate::data::ExternalSemaphoreHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceExternalFenceInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
            p_next: *const c_void,
            handle_type: crate::data::ExternalFenceHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct ExternalFenceProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_FENCE_PROPERTIES,
            p_next: *mut c_void,
            export_from_imported_handle_types: crate::data::ExternalFenceHandleTypeFlags,
            compatible_handle_types: crate::data::ExternalFenceHandleTypeFlags,
            external_fence_features: crate::data::ExternalFenceFeatureFlags,
        }
    }
    impl_aggregate! {
        struct ExportFenceCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_FENCE_CREATE_INFO,
            p_next: *const c_void,
            handle_types: crate::data::ExternalFenceHandleTypeFlags,
        }
    }
    impl_aggregate! {
        struct ImportFenceWin32HandleInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_FENCE_WIN32_HANDLE_INFO_KHR,
            p_next: *const c_void,
            fence: crate::data::Fence,
            flags: crate::data::FenceImportFlags,
            handle_type: crate::data::ExternalFenceHandleTypeFlagBits,
            handle: HANDLE,
            name: LPCWSTR,
        }
    }
    impl_aggregate! {
        struct ExportFenceWin32HandleInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
            p_next: *const c_void,
            p_attributes: *const SECURITY_ATTRIBUTES,
            dw_access: DWORD,
            name: LPCWSTR,
        }
    }
    impl_aggregate! {
        struct FenceGetWin32HandleInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::FENCE_GET_WIN32_HANDLE_INFO_KHR,
            p_next: *const c_void,
            fence: crate::data::Fence,
            handle_type: crate::data::ExternalFenceHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct ImportFenceFdInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_FENCE_FD_INFO_KHR,
            p_next: *const c_void,
            fence: crate::data::Fence,
            flags: crate::data::FenceImportFlags,
            handle_type: crate::data::ExternalFenceHandleTypeFlagBits,
            fd: c_int,
        }
    }
    impl_aggregate! {
        struct FenceGetFdInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::FENCE_GET_FD_INFO_KHR,
            p_next: *const c_void,
            fence: crate::data::Fence,
            handle_type: crate::data::ExternalFenceHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMultiviewFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
            p_next: *mut c_void,
            multiview: crate::data::Bool32,
            multiview_geometry_shader: crate::data::Bool32,
            multiview_tessellation_shader: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMultiviewProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
            p_next: *mut c_void,
            max_multiview_view_count: u32,
            max_multiview_instance_index: u32,
        }
    }
    impl_aggregate! {
        struct RenderPassMultiviewCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_MULTIVIEW_CREATE_INFO,
            p_next: *const c_void,
            subpass_count: u32,
            p_view_masks: *const u32,
            dependency_count: u32,
            p_view_offsets: *const i32,
            correlation_mask_count: u32,
            p_correlation_masks: *const u32,
        }
    }
    impl_aggregate! {
        struct SurfaceCapabilities2EXT {
            s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_CAPABILITIES_2_EXT,
            p_next: *mut c_void,
            min_image_count: u32,
            max_image_count: u32,
            current_extent: crate::data::Extent2D,
            min_image_extent: crate::data::Extent2D,
            max_image_extent: crate::data::Extent2D,
            max_image_array_layers: u32,
            supported_transforms: crate::data::SurfaceTransformFlagsKHR,
            current_transform: crate::data::SurfaceTransformFlagBitsKHR,
            supported_composite_alpha: crate::data::CompositeAlphaFlagsKHR,
            supported_usage_flags: crate::data::ImageUsageFlags,
            supported_surface_counters: crate::data::SurfaceCounterFlagsEXT,
        }
    }
    impl_aggregate! {
        struct DisplayPowerInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_POWER_INFO_EXT,
            p_next: *const c_void,
            power_state: crate::data::DisplayPowerStateEXT,
        }
    }
    impl_aggregate! {
        struct DeviceEventInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_EVENT_INFO_EXT,
            p_next: *const c_void,
            device_event: crate::data::DeviceEventTypeEXT,
        }
    }
    impl_aggregate! {
        struct DisplayEventInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_EVENT_INFO_EXT,
            p_next: *const c_void,
            display_event: crate::data::DisplayEventTypeEXT,
        }
    }
    impl_aggregate! {
        struct SwapchainCounterCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
            p_next: *const c_void,
            surface_counters: crate::data::SurfaceCounterFlagsEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceGroupProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_GROUP_PROPERTIES,
            p_next: *mut c_void,
            physical_device_count: u32,
            physical_devices: [crate::data::PhysicalDevice; 32],
            subset_allocation: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct MemoryAllocateFlagsInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_ALLOCATE_FLAGS_INFO,
            p_next: *const c_void,
            flags: crate::data::MemoryAllocateFlags,
            device_mask: u32,
        }
    }
    impl_aggregate! {
        struct BindBufferMemoryInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::BIND_BUFFER_MEMORY_INFO,
            p_next: *const c_void,
            buffer: crate::data::Buffer,
            memory: crate::data::DeviceMemory,
            memory_offset: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct BindBufferMemoryDeviceGroupInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
            p_next: *const c_void,
            device_index_count: u32,
            p_device_indices: *const u32,
        }
    }
    impl_aggregate! {
        struct BindImageMemoryInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::BIND_IMAGE_MEMORY_INFO,
            p_next: *const c_void,
            image: crate::data::Image,
            memory: crate::data::DeviceMemory,
            memory_offset: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct BindImageMemoryDeviceGroupInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
            p_next: *const c_void,
            device_index_count: u32,
            p_device_indices: *const u32,
            split_instance_bind_region_count: u32,
            p_split_instance_bind_regions: *const crate::data::Rect2D,
        }
    }
    impl_aggregate! {
        struct DeviceGroupRenderPassBeginInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            p_next: *const c_void,
            device_mask: u32,
            device_render_area_count: u32,
            p_device_render_areas: *const crate::data::Rect2D,
        }
    }
    impl_aggregate! {
        struct DeviceGroupCommandBufferBeginInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
            p_next: *const c_void,
            device_mask: u32,
        }
    }
    impl_aggregate! {
        struct DeviceGroupSubmitInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_SUBMIT_INFO,
            p_next: *const c_void,
            wait_semaphore_count: u32,
            p_wait_semaphore_device_indices: *const u32,
            command_buffer_count: u32,
            p_command_buffer_device_masks: *const u32,
            signal_semaphore_count: u32,
            p_signal_semaphore_device_indices: *const u32,
        }
    }
    impl_aggregate! {
        struct DeviceGroupBindSparseInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_BIND_SPARSE_INFO,
            p_next: *const c_void,
            resource_device_index: u32,
            memory_device_index: u32,
        }
    }
    impl_aggregate! {
        struct DeviceGroupPresentCapabilitiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
            p_next: *mut c_void,
            present_mask: [u32; 32],
            modes: crate::data::DeviceGroupPresentModeFlagsKHR,
        }
    }
    impl_aggregate! {
        struct ImageSwapchainCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
            p_next: *const c_void,
            swapchain: crate::data::SwapchainKHR,
        }
    }
    impl_aggregate! {
        struct BindImageMemorySwapchainInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
            p_next: *const c_void,
            swapchain: crate::data::SwapchainKHR,
            image_index: u32,
        }
    }
    impl_aggregate! {
        struct AcquireNextImageInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::ACQUIRE_NEXT_IMAGE_INFO_KHR,
            p_next: *const c_void,
            swapchain: crate::data::SwapchainKHR,
            timeout: u64,
            semaphore: crate::data::Semaphore,
            fence: crate::data::Fence,
            device_mask: u32,
        }
    }
    impl_aggregate! {
        struct DeviceGroupPresentInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_PRESENT_INFO_KHR,
            p_next: *const c_void,
            swapchain_count: u32,
            p_device_masks: *const u32,
            mode: crate::data::DeviceGroupPresentModeFlagBitsKHR,
        }
    }
    impl_aggregate! {
        struct DeviceGroupDeviceCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_DEVICE_CREATE_INFO,
            p_next: *const c_void,
            physical_device_count: u32,
            p_physical_devices: *const crate::data::PhysicalDevice,
        }
    }
    impl_aggregate! {
        struct DeviceGroupSwapchainCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
            p_next: *const c_void,
            modes: crate::data::DeviceGroupPresentModeFlagsKHR,
        }
    }
    impl_aggregate! {
        struct DescriptorUpdateTemplateEntry {
            dst_binding: u32,
            dst_array_element: u32,
            descriptor_count: u32,
            descriptor_type: crate::data::DescriptorType,
            offset: usize,
            stride: usize,
        }
    }
    impl_aggregate! {
        struct DescriptorUpdateTemplateCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
            p_next: *const c_void,
            flags: crate::data::DescriptorUpdateTemplateCreateFlags,
            descriptor_update_entry_count: u32,
            p_descriptor_update_entries: *const crate::data::DescriptorUpdateTemplateEntry,
            template_type: crate::data::DescriptorUpdateTemplateType,
            descriptor_set_layout: crate::data::DescriptorSetLayout,
            pipeline_bind_point: crate::data::PipelineBindPoint,
            pipeline_layout: crate::data::PipelineLayout,
            set: u32,
        }
    }
    impl_aggregate! {
        struct XYColorEXT {
            x: c_float,
            y: c_float,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePresentIdFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
            p_next: *mut c_void,
            present_id: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PresentIdKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PRESENT_ID_KHR,
            p_next: *const c_void,
            swapchain_count: u32,
            p_present_ids: *const u64,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePresentWaitFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
            p_next: *mut c_void,
            present_wait: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct HdrMetadataEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::HDR_METADATA_EXT,
            p_next: *const c_void,
            display_primary_red: crate::data::XYColorEXT,
            display_primary_green: crate::data::XYColorEXT,
            display_primary_blue: crate::data::XYColorEXT,
            white_point: crate::data::XYColorEXT,
            max_luminance: c_float,
            min_luminance: c_float,
            max_content_light_level: c_float,
            max_frame_average_light_level: c_float,
        }
    }
    impl_aggregate! {
        struct DisplayNativeHdrSurfaceCapabilitiesAMD {
            s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
            p_next: *mut c_void,
            local_dimming_support: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct SwapchainDisplayNativeHdrCreateInfoAMD {
            s_type: crate::data::StructureType = crate::data::StructureType::SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
            p_next: *const c_void,
            local_dimming_enable: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct RefreshCycleDurationGOOGLE {
            refresh_duration: u64,
        }
    }
    impl_aggregate! {
        struct PastPresentationTimingGOOGLE {
            present_id: u32,
            desired_present_time: u64,
            actual_present_time: u64,
            earliest_present_time: u64,
            present_margin: u64,
        }
    }
    impl_aggregate! {
        struct PresentTimesInfoGOOGLE {
            s_type: crate::data::StructureType = crate::data::StructureType::PRESENT_TIMES_INFO_GOOGLE,
            p_next: *const c_void,
            swapchain_count: u32,
            p_times: *const crate::data::PresentTimeGOOGLE,
        }
    }
    impl_aggregate! {
        struct PresentTimeGOOGLE {
            present_id: u32,
            desired_present_time: u64,
        }
    }
    impl_aggregate! {
        struct IOSSurfaceCreateInfoMVK {
            s_type: crate::data::StructureType = crate::data::StructureType::IOS_SURFACE_CREATE_INFO_MVK,
            p_next: *const c_void,
            flags: crate::data::IOSSurfaceCreateFlagsMVK,
            p_view: *const c_void,
        }
    }
    impl_aggregate! {
        struct MacOSSurfaceCreateInfoMVK {
            s_type: crate::data::StructureType = crate::data::StructureType::MACOS_SURFACE_CREATE_INFO_MVK,
            p_next: *const c_void,
            flags: crate::data::MacOSSurfaceCreateFlagsMVK,
            p_view: *const c_void,
        }
    }
    impl_aggregate! {
        struct MetalSurfaceCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::METAL_SURFACE_CREATE_INFO_EXT,
            p_next: *const c_void,
            flags: crate::data::MetalSurfaceCreateFlagsEXT,
            p_layer: *const CAMetalLayer,
        }
    }
    impl_aggregate! {
        struct ViewportWScalingNV {
            xcoeff: c_float,
            ycoeff: c_float,
        }
    }
    impl_aggregate! {
        struct PipelineViewportWScalingStateCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
            p_next: *const c_void,
            viewport_w_scaling_enable: crate::data::Bool32,
            viewport_count: u32,
            p_viewport_w_scalings: *const crate::data::ViewportWScalingNV,
        }
    }
    impl_aggregate! {
        struct ViewportSwizzleNV {
            x: crate::data::ViewportCoordinateSwizzleNV,
            y: crate::data::ViewportCoordinateSwizzleNV,
            z: crate::data::ViewportCoordinateSwizzleNV,
            w: crate::data::ViewportCoordinateSwizzleNV,
        }
    }
    impl_aggregate! {
        struct PipelineViewportSwizzleStateCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
            p_next: *const c_void,
            flags: crate::data::PipelineViewportSwizzleStateCreateFlagsNV,
            viewport_count: u32,
            p_viewport_swizzles: *const crate::data::ViewportSwizzleNV,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDiscardRectanglePropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
            p_next: *mut c_void,
            max_discard_rectangles: u32,
        }
    }
    impl_aggregate! {
        struct PipelineDiscardRectangleStateCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
            p_next: *const c_void,
            flags: crate::data::PipelineDiscardRectangleStateCreateFlagsEXT,
            discard_rectangle_mode: crate::data::DiscardRectangleModeEXT,
            discard_rectangle_count: u32,
            p_discard_rectangles: *const crate::data::Rect2D,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
            p_next: *mut c_void,
            per_view_position_all_components: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct InputAttachmentAspectReference {
            subpass: u32,
            input_attachment_index: u32,
            aspect_mask: crate::data::ImageAspectFlags,
        }
    }
    impl_aggregate! {
        struct RenderPassInputAttachmentAspectCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
            p_next: *const c_void,
            aspect_reference_count: u32,
            p_aspect_references: *const crate::data::InputAttachmentAspectReference,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSurfaceInfo2KHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
            p_next: *const c_void,
            surface: crate::data::SurfaceKHR,
        }
    }
    impl_aggregate! {
        struct SurfaceCapabilities2KHR {
            s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_CAPABILITIES_2_KHR,
            p_next: *mut c_void,
            surface_capabilities: crate::data::SurfaceCapabilitiesKHR,
        }
    }
    impl_aggregate! {
        struct SurfaceFormat2KHR {
            s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_FORMAT_2_KHR,
            p_next: *mut c_void,
            surface_format: crate::data::SurfaceFormatKHR,
        }
    }
    impl_aggregate! {
        struct DisplayProperties2KHR {
            s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_PROPERTIES_2_KHR,
            p_next: *mut c_void,
            display_properties: crate::data::DisplayPropertiesKHR,
        }
    }
    impl_aggregate! {
        struct DisplayPlaneProperties2KHR {
            s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_PLANE_PROPERTIES_2_KHR,
            p_next: *mut c_void,
            display_plane_properties: crate::data::DisplayPlanePropertiesKHR,
        }
    }
    impl_aggregate! {
        struct DisplayModeProperties2KHR {
            s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_MODE_PROPERTIES_2_KHR,
            p_next: *mut c_void,
            display_mode_properties: crate::data::DisplayModePropertiesKHR,
        }
    }
    impl_aggregate! {
        struct DisplayPlaneInfo2KHR {
            s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_PLANE_INFO_2_KHR,
            p_next: *const c_void,
            mode: crate::data::DisplayModeKHR,
            plane_index: u32,
        }
    }
    impl_aggregate! {
        struct DisplayPlaneCapabilities2KHR {
            s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_PLANE_CAPABILITIES_2_KHR,
            p_next: *mut c_void,
            capabilities: crate::data::DisplayPlaneCapabilitiesKHR,
        }
    }
    impl_aggregate! {
        struct SharedPresentSurfaceCapabilitiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
            p_next: *mut c_void,
            shared_present_supported_usage_flags: crate::data::ImageUsageFlags,
        }
    }
    impl_aggregate! {
        struct PhysicalDevice16BitStorageFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
            p_next: *mut c_void,
            storage_buffer_16_bit_access: crate::data::Bool32,
            uniform_and_storage_buffer_16_bit_access: crate::data::Bool32,
            storage_push_constant_16: crate::data::Bool32,
            storage_input_output_16: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSubgroupProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
            p_next: *mut c_void,
            subgroup_size: u32,
            supported_stages: crate::data::ShaderStageFlags,
            supported_operations: crate::data::SubgroupFeatureFlags,
            quad_operations_in_all_stages: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
            p_next: *mut c_void,
            shader_subgroup_extended_types: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct BufferMemoryRequirementsInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_MEMORY_REQUIREMENTS_INFO_2,
            p_next: *const c_void,
            buffer: crate::data::Buffer,
        }
    }
    impl_aggregate! {
        struct DeviceBufferMemoryRequirements {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_BUFFER_MEMORY_REQUIREMENTS,
            p_next: *const c_void,
            p_create_info: *const crate::data::BufferCreateInfo,
        }
    }
    impl_aggregate! {
        struct ImageMemoryRequirementsInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_MEMORY_REQUIREMENTS_INFO_2,
            p_next: *const c_void,
            image: crate::data::Image,
        }
    }
    impl_aggregate! {
        struct ImageSparseMemoryRequirementsInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
            p_next: *const c_void,
            image: crate::data::Image,
        }
    }
    impl_aggregate! {
        struct DeviceImageMemoryRequirements {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_IMAGE_MEMORY_REQUIREMENTS,
            p_next: *const c_void,
            p_create_info: *const crate::data::ImageCreateInfo,
            plane_aspect: crate::data::ImageAspectFlagBits,
        }
    }
    impl_aggregate! {
        struct MemoryRequirements2 {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_REQUIREMENTS_2,
            p_next: *mut c_void,
            memory_requirements: crate::data::MemoryRequirements,
        }
    }
    impl_aggregate! {
        struct SparseImageMemoryRequirements2 {
            s_type: crate::data::StructureType = crate::data::StructureType::SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
            p_next: *mut c_void,
            memory_requirements: crate::data::SparseImageMemoryRequirements,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePointClippingProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
            p_next: *mut c_void,
            point_clipping_behavior: crate::data::PointClippingBehavior,
        }
    }
    impl_aggregate! {
        struct MemoryDedicatedRequirements {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_DEDICATED_REQUIREMENTS,
            p_next: *mut c_void,
            prefers_dedicated_allocation: crate::data::Bool32,
            requires_dedicated_allocation: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct MemoryDedicatedAllocateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_DEDICATED_ALLOCATE_INFO,
            p_next: *const c_void,
            image: crate::data::Image,
            buffer: crate::data::Buffer,
        }
    }
    impl_aggregate! {
        struct ImageViewUsageCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_VIEW_USAGE_CREATE_INFO,
            p_next: *const c_void,
            usage: crate::data::ImageUsageFlags,
        }
    }
    impl_aggregate! {
        struct PipelineTessellationDomainOriginStateCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
            p_next: *const c_void,
            domain_origin: crate::data::TessellationDomainOrigin,
        }
    }
    impl_aggregate! {
        struct SamplerYcbcrConversionInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SAMPLER_YCBCR_CONVERSION_INFO,
            p_next: *const c_void,
            conversion: crate::data::SamplerYcbcrConversion,
        }
    }
    impl_aggregate! {
        struct SamplerYcbcrConversionCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
            p_next: *const c_void,
            format: crate::data::Format,
            ycbcr_model: crate::data::SamplerYcbcrModelConversion,
            ycbcr_range: crate::data::SamplerYcbcrRange,
            components: crate::data::ComponentMapping,
            x_chroma_offset: crate::data::ChromaLocation,
            y_chroma_offset: crate::data::ChromaLocation,
            chroma_filter: crate::data::Filter,
            force_explicit_reconstruction: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct BindImagePlaneMemoryInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::BIND_IMAGE_PLANE_MEMORY_INFO,
            p_next: *const c_void,
            plane_aspect: crate::data::ImageAspectFlagBits,
        }
    }
    impl_aggregate! {
        struct ImagePlaneMemoryRequirementsInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
            p_next: *const c_void,
            plane_aspect: crate::data::ImageAspectFlagBits,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSamplerYcbcrConversionFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
            p_next: *mut c_void,
            sampler_ycbcr_conversion: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct SamplerYcbcrConversionImageFormatProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
            p_next: *mut c_void,
            combined_image_sampler_descriptor_count: u32,
        }
    }
    impl_aggregate! {
        struct TextureLODGatherFormatPropertiesAMD {
            s_type: crate::data::StructureType = crate::data::StructureType::TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
            p_next: *mut c_void,
            supports_texture_gather_lod_bias_amd: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct ConditionalRenderingBeginInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
            p_next: *const c_void,
            buffer: crate::data::Buffer,
            offset: crate::data::DeviceSize,
            flags: crate::data::ConditionalRenderingFlagsEXT,
        }
    }
    impl_aggregate! {
        struct ProtectedSubmitInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PROTECTED_SUBMIT_INFO,
            p_next: *const c_void,
            protected_submit: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceProtectedMemoryFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
            p_next: *mut c_void,
            protected_memory: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceProtectedMemoryProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
            p_next: *mut c_void,
            protected_no_fault: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct DeviceQueueInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_QUEUE_INFO_2,
            p_next: *const c_void,
            flags: crate::data::DeviceQueueCreateFlags,
            queue_family_index: u32,
            queue_index: u32,
        }
    }
    impl_aggregate! {
        struct PipelineCoverageToColorStateCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
            p_next: *const c_void,
            flags: crate::data::PipelineCoverageToColorStateCreateFlagsNV,
            coverage_to_color_enable: crate::data::Bool32,
            coverage_to_color_location: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSamplerFilterMinmaxProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
            p_next: *mut c_void,
            filter_minmax_single_component_formats: crate::data::Bool32,
            filter_minmax_image_component_mapping: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct SampleLocationEXT {
            x: c_float,
            y: c_float,
        }
    }
    impl_aggregate! {
        struct SampleLocationsInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::SAMPLE_LOCATIONS_INFO_EXT,
            p_next: *const c_void,
            sample_locations_per_pixel: crate::data::SampleCountFlagBits,
            sample_location_grid_size: crate::data::Extent2D,
            sample_locations_count: u32,
            p_sample_locations: *const crate::data::SampleLocationEXT,
        }
    }
    impl_aggregate! {
        struct AttachmentSampleLocationsEXT {
            attachment_index: u32,
            sample_locations_info: crate::data::SampleLocationsInfoEXT,
        }
    }
    impl_aggregate! {
        struct SubpassSampleLocationsEXT {
            subpass_index: u32,
            sample_locations_info: crate::data::SampleLocationsInfoEXT,
        }
    }
    impl_aggregate! {
        struct RenderPassSampleLocationsBeginInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
            p_next: *const c_void,
            attachment_initial_sample_locations_count: u32,
            p_attachment_initial_sample_locations: *const crate::data::AttachmentSampleLocationsEXT,
            post_subpass_sample_locations_count: u32,
            p_post_subpass_sample_locations: *const crate::data::SubpassSampleLocationsEXT,
        }
    }
    impl_aggregate! {
        struct PipelineSampleLocationsStateCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
            p_next: *const c_void,
            sample_locations_enable: crate::data::Bool32,
            sample_locations_info: crate::data::SampleLocationsInfoEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSampleLocationsPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
            p_next: *mut c_void,
            sample_location_sample_counts: crate::data::SampleCountFlags,
            max_sample_location_grid_size: crate::data::Extent2D,
            sample_location_coordinate_range: [c_float; 2],
            sample_location_sub_pixel_bits: u32,
            variable_sample_locations: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct MultisamplePropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::MULTISAMPLE_PROPERTIES_EXT,
            p_next: *mut c_void,
            max_sample_location_grid_size: crate::data::Extent2D,
        }
    }
    impl_aggregate! {
        struct SamplerReductionModeCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SAMPLER_REDUCTION_MODE_CREATE_INFO,
            p_next: *const c_void,
            reduction_mode: crate::data::SamplerReductionMode,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
            p_next: *mut c_void,
            advanced_blend_coherent_operations: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMultiDrawFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
            p_next: *mut c_void,
            multi_draw: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
            p_next: *mut c_void,
            advanced_blend_max_color_attachments: u32,
            advanced_blend_independent_blend: crate::data::Bool32,
            advanced_blend_non_premultiplied_src_color: crate::data::Bool32,
            advanced_blend_non_premultiplied_dst_color: crate::data::Bool32,
            advanced_blend_correlated_overlap: crate::data::Bool32,
            advanced_blend_all_operations: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineColorBlendAdvancedStateCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
            p_next: *const c_void,
            src_premultiplied: crate::data::Bool32,
            dst_premultiplied: crate::data::Bool32,
            blend_overlap: crate::data::BlendOverlapEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceInlineUniformBlockFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
            p_next: *mut c_void,
            inline_uniform_block: crate::data::Bool32,
            descriptor_binding_inline_uniform_block_update_after_bind: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceInlineUniformBlockProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
            p_next: *mut c_void,
            max_inline_uniform_block_size: u32,
            max_per_stage_descriptor_inline_uniform_blocks: u32,
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
            max_descriptor_set_inline_uniform_blocks: u32,
            max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
        }
    }
    impl_aggregate! {
        struct WriteDescriptorSetInlineUniformBlock {
            s_type: crate::data::StructureType = crate::data::StructureType::WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
            p_next: *const c_void,
            data_size: u32,
            p_data: *const c_void,
        }
    }
    impl_aggregate! {
        struct DescriptorPoolInlineUniformBlockCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
            p_next: *const c_void,
            max_inline_uniform_block_bindings: u32,
        }
    }
    impl_aggregate! {
        struct PipelineCoverageModulationStateCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
            p_next: *const c_void,
            flags: crate::data::PipelineCoverageModulationStateCreateFlagsNV,
            coverage_modulation_mode: crate::data::CoverageModulationModeNV,
            coverage_modulation_table_enable: crate::data::Bool32,
            coverage_modulation_table_count: u32,
            p_coverage_modulation_table: *const c_float,
        }
    }
    impl_aggregate! {
        struct ImageFormatListCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_FORMAT_LIST_CREATE_INFO,
            p_next: *const c_void,
            view_format_count: u32,
            p_view_formats: *const crate::data::Format,
        }
    }
    impl_aggregate! {
        struct ValidationCacheCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VALIDATION_CACHE_CREATE_INFO_EXT,
            p_next: *const c_void,
            flags: crate::data::ValidationCacheCreateFlagsEXT,
            initial_data_size: usize,
            p_initial_data: *const c_void,
        }
    }
    impl_aggregate! {
        struct ShaderModuleValidationCacheCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
            p_next: *const c_void,
            validation_cache: crate::data::ValidationCacheEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMaintenance3Properties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
            p_next: *mut c_void,
            max_per_set_descriptors: u32,
            max_memory_allocation_size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMaintenance4Features {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
            p_next: *mut c_void,
            maintenance_4: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMaintenance4Properties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
            p_next: *mut c_void,
            max_buffer_size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct DescriptorSetLayoutSupport {
            s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_LAYOUT_SUPPORT,
            p_next: *mut c_void,
            supported: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderDrawParametersFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
            p_next: *mut c_void,
            shader_draw_parameters: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderFloat16Int8Features {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
            p_next: *mut c_void,
            shader_float_16: crate::data::Bool32,
            shader_int_8: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFloatControlsProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
            p_next: *mut c_void,
            denorm_behavior_independence: crate::data::ShaderFloatControlsIndependence,
            rounding_mode_independence: crate::data::ShaderFloatControlsIndependence,
            shader_signed_zero_inf_nan_preserve_float_16: crate::data::Bool32,
            shader_signed_zero_inf_nan_preserve_float_32: crate::data::Bool32,
            shader_signed_zero_inf_nan_preserve_float_64: crate::data::Bool32,
            shader_denorm_preserve_float_16: crate::data::Bool32,
            shader_denorm_preserve_float_32: crate::data::Bool32,
            shader_denorm_preserve_float_64: crate::data::Bool32,
            shader_denorm_flush_to_zero_float_16: crate::data::Bool32,
            shader_denorm_flush_to_zero_float_32: crate::data::Bool32,
            shader_denorm_flush_to_zero_float_64: crate::data::Bool32,
            shader_rounding_mode_rte_float_16: crate::data::Bool32,
            shader_rounding_mode_rte_float_32: crate::data::Bool32,
            shader_rounding_mode_rte_float_64: crate::data::Bool32,
            shader_rounding_mode_rtz_float_16: crate::data::Bool32,
            shader_rounding_mode_rtz_float_32: crate::data::Bool32,
            shader_rounding_mode_rtz_float_64: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceHostQueryResetFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
            p_next: *mut c_void,
            host_query_reset: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct NativeBufferUsage2ANDROID {
            consumer: u64,
            producer: u64,
        }
    }
    impl_aggregate! {
        struct NativeBufferANDROID {
            s_type: crate::data::StructureType = crate::data::StructureType::NATIVE_BUFFER_ANDROID,
            p_next: *const c_void,
            handle: *const c_void,
            stride: c_int,
            format: c_int,
            usage: c_int,
            usage_2: crate::data::NativeBufferUsage2ANDROID,
        }
    }
    impl_aggregate! {
        struct SwapchainImageCreateInfoANDROID {
            s_type: crate::data::StructureType = crate::data::StructureType::SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID,
            p_next: *const c_void,
            usage: crate::data::SwapchainImageUsageFlagsANDROID,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePresentationPropertiesANDROID {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID,
            p_next: *const c_void,
            shared_image: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct ShaderResourceUsageAMD {
            num_used_vgprs: u32,
            num_used_sgprs: u32,
            lds_size_per_local_work_group: u32,
            lds_usage_size_in_bytes: usize,
            scratch_mem_usage_in_bytes: usize,
        }
    }
    impl_aggregate! {
        struct ShaderStatisticsInfoAMD {
            shader_stage_mask: crate::data::ShaderStageFlags,
            resource_usage: crate::data::ShaderResourceUsageAMD,
            num_physical_vgprs: u32,
            num_physical_sgprs: u32,
            num_available_vgprs: u32,
            num_available_sgprs: u32,
            compute_work_group_size: [u32; 3],
        }
    }
    impl_aggregate! {
        struct DeviceQueueGlobalPriorityCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR,
            p_next: *const c_void,
            global_priority: crate::data::QueueGlobalPriorityKHR,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceGlobalPriorityQueryFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR,
            p_next: *mut c_void,
            global_priority_query: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct QueueFamilyGlobalPriorityPropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR,
            p_next: *mut c_void,
            priority_count: u32,
            priorities: [crate::data::QueueGlobalPriorityKHR; 16],
        }
    }
    impl_aggregate! {
        struct DebugUtilsObjectNameInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
            p_next: *const c_void,
            object_type: crate::data::ObjectType,
            object_handle: u64,
            p_object_name: *const c_char,
        }
    }
    impl_aggregate! {
        struct DebugUtilsObjectTagInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
            p_next: *const c_void,
            object_type: crate::data::ObjectType,
            object_handle: u64,
            tag_name: u64,
            tag_size: usize,
            p_tag: *const c_void,
        }
    }
    impl_aggregate! {
        struct DebugUtilsLabelEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_UTILS_LABEL_EXT,
            p_next: *const c_void,
            p_label_name: *const c_char,
            color: [c_float; 4],
        }
    }
    impl_aggregate! {
        struct DebugUtilsMessengerCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
            p_next: *const c_void,
            flags: crate::data::DebugUtilsMessengerCreateFlagsEXT,
            message_severity: crate::data::DebugUtilsMessageSeverityFlagsEXT,
            message_type: crate::data::DebugUtilsMessageTypeFlagsEXT,
            pfn_user_callback: crate::pfn::DebugUtilsMessengerCallbackEXT,
            p_user_data: *mut c_void,
        }
    }
    impl_aggregate! {
        struct DebugUtilsMessengerCallbackDataEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
            p_next: *const c_void,
            flags: crate::data::DebugUtilsMessengerCallbackDataFlagsEXT,
            p_message_id_name: *const c_char,
            message_id_number: i32,
            p_message: *const c_char,
            queue_label_count: u32,
            p_queue_labels: *const crate::data::DebugUtilsLabelEXT,
            cmd_buf_label_count: u32,
            p_cmd_buf_labels: *const crate::data::DebugUtilsLabelEXT,
            object_count: u32,
            p_objects: *const crate::data::DebugUtilsObjectNameInfoEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDeviceMemoryReportFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
            p_next: *mut c_void,
            device_memory_report: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct DeviceDeviceMemoryReportCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
            p_next: *const c_void,
            flags: crate::data::DeviceMemoryReportFlagsEXT,
            pfn_user_callback: crate::pfn::DeviceMemoryReportCallbackEXT,
            p_user_data: *mut c_void,
        }
    }
    impl_aggregate! {
        struct DeviceMemoryReportCallbackDataEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT,
            p_next: *mut c_void,
            flags: crate::data::DeviceMemoryReportFlagsEXT,
            ty: crate::data::DeviceMemoryReportEventTypeEXT,
            memory_object_id: u64,
            size: crate::data::DeviceSize,
            object_type: crate::data::ObjectType,
            object_handle: u64,
            heap_index: u32,
        }
    }
    impl_aggregate! {
        struct ImportMemoryHostPointerInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
            p_next: *const c_void,
            handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
            p_host_pointer: *mut c_void,
        }
    }
    impl_aggregate! {
        struct MemoryHostPointerPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_HOST_POINTER_PROPERTIES_EXT,
            p_next: *mut c_void,
            memory_type_bits: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceExternalMemoryHostPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
            p_next: *mut c_void,
            min_imported_host_pointer_alignment: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceConservativeRasterizationPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
            p_next: *mut c_void,
            primitive_overestimation_size: c_float,
            max_extra_primitive_overestimation_size: c_float,
            extra_primitive_overestimation_size_granularity: c_float,
            primitive_underestimation: crate::data::Bool32,
            conservative_point_and_line_rasterization: crate::data::Bool32,
            degenerate_triangles_rasterized: crate::data::Bool32,
            degenerate_lines_rasterized: crate::data::Bool32,
            fully_covered_fragment_shader_input_variable: crate::data::Bool32,
            conservative_rasterization_post_depth_coverage: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct CalibratedTimestampInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::CALIBRATED_TIMESTAMP_INFO_EXT,
            p_next: *const c_void,
            time_domain: crate::data::TimeDomainEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderCorePropertiesAMD {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
            p_next: *mut c_void,
            shader_engine_count: u32,
            shader_arrays_per_engine_count: u32,
            compute_units_per_shader_array: u32,
            simd_per_compute_unit: u32,
            wavefronts_per_simd: u32,
            wavefront_size: u32,
            sgprs_per_simd: u32,
            min_sgpr_allocation: u32,
            max_sgpr_allocation: u32,
            sgpr_allocation_granularity: u32,
            vgprs_per_simd: u32,
            min_vgpr_allocation: u32,
            max_vgpr_allocation: u32,
            vgpr_allocation_granularity: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderCoreProperties2AMD {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD,
            p_next: *mut c_void,
            shader_core_features: crate::data::ShaderCorePropertiesFlagsAMD,
            active_compute_unit_count: u32,
        }
    }
    impl_aggregate! {
        struct PipelineRasterizationConservativeStateCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
            p_next: *const c_void,
            flags: crate::data::PipelineRasterizationConservativeStateCreateFlagsEXT,
            conservative_rasterization_mode: crate::data::ConservativeRasterizationModeEXT,
            extra_primitive_overestimation_size: c_float,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDescriptorIndexingFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
            p_next: *mut c_void,
            shader_input_attachment_array_dynamic_indexing: crate::data::Bool32,
            shader_uniform_texel_buffer_array_dynamic_indexing: crate::data::Bool32,
            shader_storage_texel_buffer_array_dynamic_indexing: crate::data::Bool32,
            shader_uniform_buffer_array_non_uniform_indexing: crate::data::Bool32,
            shader_sampled_image_array_non_uniform_indexing: crate::data::Bool32,
            shader_storage_buffer_array_non_uniform_indexing: crate::data::Bool32,
            shader_storage_image_array_non_uniform_indexing: crate::data::Bool32,
            shader_input_attachment_array_non_uniform_indexing: crate::data::Bool32,
            shader_uniform_texel_buffer_array_non_uniform_indexing: crate::data::Bool32,
            shader_storage_texel_buffer_array_non_uniform_indexing: crate::data::Bool32,
            descriptor_binding_uniform_buffer_update_after_bind: crate::data::Bool32,
            descriptor_binding_sampled_image_update_after_bind: crate::data::Bool32,
            descriptor_binding_storage_image_update_after_bind: crate::data::Bool32,
            descriptor_binding_storage_buffer_update_after_bind: crate::data::Bool32,
            descriptor_binding_uniform_texel_buffer_update_after_bind: crate::data::Bool32,
            descriptor_binding_storage_texel_buffer_update_after_bind: crate::data::Bool32,
            descriptor_binding_update_unused_while_pending: crate::data::Bool32,
            descriptor_binding_partially_bound: crate::data::Bool32,
            descriptor_binding_variable_descriptor_count: crate::data::Bool32,
            runtime_descriptor_array: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDescriptorIndexingProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
            p_next: *mut c_void,
            max_update_after_bind_descriptors_in_all_pools: u32,
            shader_uniform_buffer_array_non_uniform_indexing_native: crate::data::Bool32,
            shader_sampled_image_array_non_uniform_indexing_native: crate::data::Bool32,
            shader_storage_buffer_array_non_uniform_indexing_native: crate::data::Bool32,
            shader_storage_image_array_non_uniform_indexing_native: crate::data::Bool32,
            shader_input_attachment_array_non_uniform_indexing_native: crate::data::Bool32,
            robust_buffer_access_update_after_bind: crate::data::Bool32,
            quad_divergent_implicit_lod: crate::data::Bool32,
            max_per_stage_descriptor_update_after_bind_samplers: u32,
            max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
            max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
            max_per_stage_descriptor_update_after_bind_sampled_images: u32,
            max_per_stage_descriptor_update_after_bind_storage_images: u32,
            max_per_stage_descriptor_update_after_bind_input_attachments: u32,
            max_per_stage_update_after_bind_resources: u32,
            max_descriptor_set_update_after_bind_samplers: u32,
            max_descriptor_set_update_after_bind_uniform_buffers: u32,
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
            max_descriptor_set_update_after_bind_storage_buffers: u32,
            max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
            max_descriptor_set_update_after_bind_sampled_images: u32,
            max_descriptor_set_update_after_bind_storage_images: u32,
            max_descriptor_set_update_after_bind_input_attachments: u32,
        }
    }
    impl_aggregate! {
        struct DescriptorSetLayoutBindingFlagsCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
            p_next: *const c_void,
            binding_count: u32,
            p_binding_flags: *const crate::data::DescriptorBindingFlags,
        }
    }
    impl_aggregate! {
        struct DescriptorSetVariableDescriptorCountAllocateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
            p_next: *const c_void,
            descriptor_set_count: u32,
            p_descriptor_counts: *const u32,
        }
    }
    impl_aggregate! {
        struct DescriptorSetVariableDescriptorCountLayoutSupport {
            s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
            p_next: *mut c_void,
            max_variable_descriptor_count: u32,
        }
    }
    impl_aggregate! {
        struct AttachmentDescription2 {
            s_type: crate::data::StructureType = crate::data::StructureType::ATTACHMENT_DESCRIPTION_2,
            p_next: *const c_void,
            flags: crate::data::AttachmentDescriptionFlags,
            format: crate::data::Format,
            samples: crate::data::SampleCountFlagBits,
            load_op: crate::data::AttachmentLoadOp,
            store_op: crate::data::AttachmentStoreOp,
            stencil_load_op: crate::data::AttachmentLoadOp,
            stencil_store_op: crate::data::AttachmentStoreOp,
            initial_layout: crate::data::ImageLayout,
            final_layout: crate::data::ImageLayout,
        }
    }
    impl_aggregate! {
        struct AttachmentReference2 {
            s_type: crate::data::StructureType = crate::data::StructureType::ATTACHMENT_REFERENCE_2,
            p_next: *const c_void,
            attachment: u32,
            layout: crate::data::ImageLayout,
            aspect_mask: crate::data::ImageAspectFlags,
        }
    }
    impl_aggregate! {
        struct SubpassDescription2 {
            s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_DESCRIPTION_2,
            p_next: *const c_void,
            flags: crate::data::SubpassDescriptionFlags,
            pipeline_bind_point: crate::data::PipelineBindPoint,
            view_mask: u32,
            input_attachment_count: u32,
            p_input_attachments: *const crate::data::AttachmentReference2,
            color_attachment_count: u32,
            p_color_attachments: *const crate::data::AttachmentReference2,
            p_resolve_attachments: *const crate::data::AttachmentReference2,
            p_depth_stencil_attachment: *const crate::data::AttachmentReference2,
            preserve_attachment_count: u32,
            p_preserve_attachments: *const u32,
        }
    }
    impl_aggregate! {
        struct SubpassDependency2 {
            s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_DEPENDENCY_2,
            p_next: *const c_void,
            src_subpass: u32,
            dst_subpass: u32,
            src_stage_mask: crate::data::PipelineStageFlags,
            dst_stage_mask: crate::data::PipelineStageFlags,
            src_access_mask: crate::data::AccessFlags,
            dst_access_mask: crate::data::AccessFlags,
            dependency_flags: crate::data::DependencyFlags,
            view_offset: i32,
        }
    }
    impl_aggregate! {
        struct RenderPassCreateInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_CREATE_INFO_2,
            p_next: *const c_void,
            flags: crate::data::RenderPassCreateFlags,
            attachment_count: u32,
            p_attachments: *const crate::data::AttachmentDescription2,
            subpass_count: u32,
            p_subpasses: *const crate::data::SubpassDescription2,
            dependency_count: u32,
            p_dependencies: *const crate::data::SubpassDependency2,
            correlated_view_mask_count: u32,
            p_correlated_view_masks: *const u32,
        }
    }
    impl_aggregate! {
        struct SubpassBeginInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_BEGIN_INFO,
            p_next: *const c_void,
            contents: crate::data::SubpassContents,
        }
    }
    impl_aggregate! {
        struct SubpassEndInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_END_INFO,
            p_next: *const c_void,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceTimelineSemaphoreFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
            p_next: *mut c_void,
            timeline_semaphore: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceTimelineSemaphoreProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
            p_next: *mut c_void,
            max_timeline_semaphore_value_difference: u64,
        }
    }
    impl_aggregate! {
        struct SemaphoreTypeCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SEMAPHORE_TYPE_CREATE_INFO,
            p_next: *const c_void,
            semaphore_type: crate::data::SemaphoreType,
            initial_value: u64,
        }
    }
    impl_aggregate! {
        struct TimelineSemaphoreSubmitInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::TIMELINE_SEMAPHORE_SUBMIT_INFO,
            p_next: *const c_void,
            wait_semaphore_value_count: u32,
            p_wait_semaphore_values: *const u64,
            signal_semaphore_value_count: u32,
            p_signal_semaphore_values: *const u64,
        }
    }
    impl_aggregate! {
        struct SemaphoreWaitInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SEMAPHORE_WAIT_INFO,
            p_next: *const c_void,
            flags: crate::data::SemaphoreWaitFlags,
            semaphore_count: u32,
            p_semaphores: *const crate::data::Semaphore,
            p_values: *const u64,
        }
    }
    impl_aggregate! {
        struct SemaphoreSignalInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SEMAPHORE_SIGNAL_INFO,
            p_next: *const c_void,
            semaphore: crate::data::Semaphore,
            value: u64,
        }
    }
    impl_aggregate! {
        struct VertexInputBindingDivisorDescriptionEXT {
            binding: u32,
            divisor: u32,
        }
    }
    impl_aggregate! {
        struct PipelineVertexInputDivisorStateCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
            p_next: *const c_void,
            vertex_binding_divisor_count: u32,
            p_vertex_binding_divisors: *const crate::data::VertexInputBindingDivisorDescriptionEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
            p_next: *mut c_void,
            max_vertex_attrib_divisor: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePCIBusInfoPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
            p_next: *mut c_void,
            pci_domain: u32,
            pci_bus: u32,
            pci_device: u32,
            pci_function: u32,
        }
    }
    impl_aggregate! {
        struct ImportAndroidHardwareBufferInfoANDROID {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
            p_next: *const c_void,
            buffer: *mut AHardwareBuffer,
        }
    }
    impl_aggregate! {
        struct AndroidHardwareBufferUsageANDROID {
            s_type: crate::data::StructureType = crate::data::StructureType::ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
            p_next: *mut c_void,
            android_hardware_buffer_usage: u64,
        }
    }
    impl_aggregate! {
        struct AndroidHardwareBufferPropertiesANDROID {
            s_type: crate::data::StructureType = crate::data::StructureType::ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
            p_next: *mut c_void,
            allocation_size: crate::data::DeviceSize,
            memory_type_bits: u32,
        }
    }
    impl_aggregate! {
        struct MemoryGetAndroidHardwareBufferInfoANDROID {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
            p_next: *const c_void,
            memory: crate::data::DeviceMemory,
        }
    }
    impl_aggregate! {
        struct AndroidHardwareBufferFormatPropertiesANDROID {
            s_type: crate::data::StructureType = crate::data::StructureType::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
            p_next: *mut c_void,
            format: crate::data::Format,
            external_format: u64,
            format_features: crate::data::FormatFeatureFlags,
            sampler_ycbcr_conversion_components: crate::data::ComponentMapping,
            suggested_ycbcr_model: crate::data::SamplerYcbcrModelConversion,
            suggested_ycbcr_range: crate::data::SamplerYcbcrRange,
            suggested_x_chroma_offset: crate::data::ChromaLocation,
            suggested_y_chroma_offset: crate::data::ChromaLocation,
        }
    }
    impl_aggregate! {
        struct CommandBufferInheritanceConditionalRenderingInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
            p_next: *const c_void,
            conditional_rendering_enable: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct ExternalFormatANDROID {
            s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_FORMAT_ANDROID,
            p_next: *mut c_void,
            external_format: u64,
        }
    }
    impl_aggregate! {
        struct PhysicalDevice8BitStorageFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
            p_next: *mut c_void,
            storage_buffer_8_bit_access: crate::data::Bool32,
            uniform_and_storage_buffer_8_bit_access: crate::data::Bool32,
            storage_push_constant_8: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceConditionalRenderingFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
            p_next: *mut c_void,
            conditional_rendering: crate::data::Bool32,
            inherited_conditional_rendering: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceVulkanMemoryModelFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
            p_next: *mut c_void,
            vulkan_memory_model: crate::data::Bool32,
            vulkan_memory_model_device_scope: crate::data::Bool32,
            vulkan_memory_model_availability_visibility_chains: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderAtomicInt64Features {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
            p_next: *mut c_void,
            shader_buffer_int_64_atomics: crate::data::Bool32,
            shader_shared_int_64_atomics: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderAtomicFloatFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
            p_next: *mut c_void,
            shader_buffer_float_32_atomics: crate::data::Bool32,
            shader_buffer_float_32_atomic_add: crate::data::Bool32,
            shader_buffer_float_64_atomics: crate::data::Bool32,
            shader_buffer_float_64_atomic_add: crate::data::Bool32,
            shader_shared_float_32_atomics: crate::data::Bool32,
            shader_shared_float_32_atomic_add: crate::data::Bool32,
            shader_shared_float_64_atomics: crate::data::Bool32,
            shader_shared_float_64_atomic_add: crate::data::Bool32,
            shader_image_float_32_atomics: crate::data::Bool32,
            shader_image_float_32_atomic_add: crate::data::Bool32,
            sparse_image_float_32_atomics: crate::data::Bool32,
            sparse_image_float_32_atomic_add: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
            p_next: *mut c_void,
            shader_buffer_float_16_atomics: crate::data::Bool32,
            shader_buffer_float_16_atomic_add: crate::data::Bool32,
            shader_buffer_float_16_atomic_min_max: crate::data::Bool32,
            shader_buffer_float_32_atomic_min_max: crate::data::Bool32,
            shader_buffer_float_64_atomic_min_max: crate::data::Bool32,
            shader_shared_float_16_atomics: crate::data::Bool32,
            shader_shared_float_16_atomic_add: crate::data::Bool32,
            shader_shared_float_16_atomic_min_max: crate::data::Bool32,
            shader_shared_float_32_atomic_min_max: crate::data::Bool32,
            shader_shared_float_64_atomic_min_max: crate::data::Bool32,
            shader_image_float_32_atomic_min_max: crate::data::Bool32,
            sparse_image_float_32_atomic_min_max: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT,
            p_next: *mut c_void,
            vertex_attribute_instance_rate_divisor: crate::data::Bool32,
            vertex_attribute_instance_rate_zero_divisor: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct QueueFamilyCheckpointPropertiesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
            p_next: *mut c_void,
            checkpoint_execution_stage_mask: crate::data::PipelineStageFlags,
        }
    }
    impl_aggregate! {
        struct CheckpointDataNV {
            s_type: crate::data::StructureType = crate::data::StructureType::CHECKPOINT_DATA_NV,
            p_next: *mut c_void,
            stage: crate::data::PipelineStageFlagBits,
            p_checkpoint_marker: *mut c_void,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDepthStencilResolveProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
            p_next: *mut c_void,
            supported_depth_resolve_modes: crate::data::ResolveModeFlags,
            supported_stencil_resolve_modes: crate::data::ResolveModeFlags,
            independent_resolve_none: crate::data::Bool32,
            independent_resolve: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct SubpassDescriptionDepthStencilResolve {
            s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
            p_next: *const c_void,
            depth_resolve_mode: crate::data::ResolveModeFlagBits,
            stencil_resolve_mode: crate::data::ResolveModeFlagBits,
            p_depth_stencil_resolve_attachment: *const crate::data::AttachmentReference2,
        }
    }
    impl_aggregate! {
        struct ImageViewASTCDecodeModeEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
            p_next: *const c_void,
            decode_mode: crate::data::Format,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceASTCDecodeFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
            p_next: *mut c_void,
            decode_mode_shared_exponent: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceTransformFeedbackFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
            p_next: *mut c_void,
            transform_feedback: crate::data::Bool32,
            geometry_streams: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceTransformFeedbackPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
            p_next: *mut c_void,
            max_transform_feedback_streams: u32,
            max_transform_feedback_buffers: u32,
            max_transform_feedback_buffer_size: crate::data::DeviceSize,
            max_transform_feedback_stream_data_size: u32,
            max_transform_feedback_buffer_data_size: u32,
            max_transform_feedback_buffer_data_stride: u32,
            transform_feedback_queries: crate::data::Bool32,
            transform_feedback_streams_lines_triangles: crate::data::Bool32,
            transform_feedback_rasterization_stream_select: crate::data::Bool32,
            transform_feedback_draw: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineRasterizationStateStreamCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
            p_next: *const c_void,
            flags: crate::data::PipelineRasterizationStateStreamCreateFlagsEXT,
            rasterization_stream: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
            p_next: *mut c_void,
            representative_fragment_test: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineRepresentativeFragmentTestStateCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
            p_next: *const c_void,
            representative_fragment_test_enable: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceExclusiveScissorFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
            p_next: *mut c_void,
            exclusive_scissor: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineViewportExclusiveScissorStateCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
            p_next: *const c_void,
            exclusive_scissor_count: u32,
            p_exclusive_scissors: *const crate::data::Rect2D,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceCornerSampledImageFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
            p_next: *mut c_void,
            corner_sampled_image: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceComputeShaderDerivativesFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV,
            p_next: *mut c_void,
            compute_derivative_group_quads: crate::data::Bool32,
            compute_derivative_group_linear: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderImageFootprintFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
            p_next: *mut c_void,
            image_footprint: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
            p_next: *mut c_void,
            dedicated_allocation_image_aliasing: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct ShadingRatePaletteNV {
            shading_rate_palette_entry_count: u32,
            p_shading_rate_palette_entries: *const crate::data::ShadingRatePaletteEntryNV,
        }
    }
    impl_aggregate! {
        struct PipelineViewportShadingRateImageStateCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
            p_next: *const c_void,
            shading_rate_image_enable: crate::data::Bool32,
            viewport_count: u32,
            p_shading_rate_palettes: *const crate::data::ShadingRatePaletteNV,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShadingRateImageFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
            p_next: *mut c_void,
            shading_rate_image: crate::data::Bool32,
            shading_rate_coarse_sample_order: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShadingRateImagePropertiesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
            p_next: *mut c_void,
            shading_rate_texel_size: crate::data::Extent2D,
            shading_rate_palette_size: u32,
            shading_rate_max_coarse_samples: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceInvocationMaskFeaturesHUAWEI {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
            p_next: *mut c_void,
            invocation_mask: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct CoarseSampleLocationNV {
            pixel_x: u32,
            pixel_y: u32,
            sample: u32,
        }
    }
    impl_aggregate! {
        struct CoarseSampleOrderCustomNV {
            shading_rate: crate::data::ShadingRatePaletteEntryNV,
            sample_count: u32,
            sample_location_count: u32,
            p_sample_locations: *const crate::data::CoarseSampleLocationNV,
        }
    }
    impl_aggregate! {
        struct PipelineViewportCoarseSampleOrderStateCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
            p_next: *const c_void,
            sample_order_type: crate::data::CoarseSampleOrderTypeNV,
            custom_sample_order_count: u32,
            p_custom_sample_orders: *const crate::data::CoarseSampleOrderCustomNV,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMeshShaderFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
            p_next: *mut c_void,
            task_shader: crate::data::Bool32,
            mesh_shader: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMeshShaderPropertiesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
            p_next: *mut c_void,
            max_draw_mesh_tasks_count: u32,
            max_task_work_group_invocations: u32,
            max_task_work_group_size: [u32; 3],
            max_task_total_memory_size: u32,
            max_task_output_count: u32,
            max_mesh_work_group_invocations: u32,
            max_mesh_work_group_size: [u32; 3],
            max_mesh_total_memory_size: u32,
            max_mesh_output_vertices: u32,
            max_mesh_output_primitives: u32,
            max_mesh_multiview_view_count: u32,
            mesh_output_per_vertex_granularity: u32,
            mesh_output_per_primitive_granularity: u32,
        }
    }
    impl_aggregate! {
        struct DrawMeshTasksIndirectCommandNV {
            task_count: u32,
            first_task: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMeshShaderFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
            p_next: *mut c_void,
            task_shader: crate::data::Bool32,
            mesh_shader: crate::data::Bool32,
            multiview_mesh_shader: crate::data::Bool32,
            primitive_fragment_shading_rate_mesh_shader: crate::data::Bool32,
            mesh_shader_queries: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMeshShaderPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT,
            p_next: *mut c_void,
            max_task_work_group_total_count: u32,
            max_task_work_group_count: [u32; 3],
            max_task_work_group_invocations: u32,
            max_task_work_group_size: [u32; 3],
            max_task_payload_size: u32,
            max_task_shared_memory_size: u32,
            max_task_payload_and_shared_memory_size: u32,
            max_mesh_work_group_total_count: u32,
            max_mesh_work_group_count: [u32; 3],
            max_mesh_work_group_invocations: u32,
            max_mesh_work_group_size: [u32; 3],
            max_mesh_shared_memory_size: u32,
            max_mesh_payload_and_shared_memory_size: u32,
            max_mesh_output_memory_size: u32,
            max_mesh_payload_and_output_memory_size: u32,
            max_mesh_output_components: u32,
            max_mesh_output_vertices: u32,
            max_mesh_output_primitives: u32,
            max_mesh_output_layers: u32,
            max_mesh_multiview_view_count: u32,
            mesh_output_per_vertex_granularity: u32,
            mesh_output_per_primitive_granularity: u32,
            max_preferred_task_work_group_invocations: u32,
            max_preferred_mesh_work_group_invocations: u32,
            prefers_local_invocation_vertex_output: crate::data::Bool32,
            prefers_local_invocation_primitive_output: crate::data::Bool32,
            prefers_compact_vertex_output: crate::data::Bool32,
            prefers_compact_primitive_output: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct DrawMeshTasksIndirectCommandEXT {
            group_count_x: u32,
            group_count_y: u32,
            group_count_z: u32,
        }
    }
    impl_aggregate! {
        struct RayTracingShaderGroupCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV,
            p_next: *const c_void,
            ty: crate::data::RayTracingShaderGroupTypeKHR,
            general_shader: u32,
            closest_hit_shader: u32,
            any_hit_shader: u32,
            intersection_shader: u32,
        }
    }
    impl_aggregate! {
        struct RayTracingShaderGroupCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
            p_next: *const c_void,
            ty: crate::data::RayTracingShaderGroupTypeKHR,
            general_shader: u32,
            closest_hit_shader: u32,
            any_hit_shader: u32,
            intersection_shader: u32,
            p_shader_group_capture_replay_handle: *const c_void,
        }
    }
    impl_aggregate! {
        struct RayTracingPipelineCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::RAY_TRACING_PIPELINE_CREATE_INFO_NV,
            p_next: *const c_void,
            flags: crate::data::PipelineCreateFlags,
            stage_count: u32,
            p_stages: *const crate::data::PipelineShaderStageCreateInfo,
            group_count: u32,
            p_groups: *const crate::data::RayTracingShaderGroupCreateInfoNV,
            max_recursion_depth: u32,
            layout: crate::data::PipelineLayout,
            base_pipeline_handle: crate::data::Pipeline,
            base_pipeline_index: i32,
        }
    }
    impl_aggregate! {
        struct RayTracingPipelineCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::PipelineCreateFlags,
            stage_count: u32,
            p_stages: *const crate::data::PipelineShaderStageCreateInfo,
            group_count: u32,
            p_groups: *const crate::data::RayTracingShaderGroupCreateInfoKHR,
            max_pipeline_ray_recursion_depth: u32,
            p_library_info: *const crate::data::PipelineLibraryCreateInfoKHR,
            p_library_interface: *const crate::data::RayTracingPipelineInterfaceCreateInfoKHR,
            p_dynamic_state: *const crate::data::PipelineDynamicStateCreateInfo,
            layout: crate::data::PipelineLayout,
            base_pipeline_handle: crate::data::Pipeline,
            base_pipeline_index: i32,
        }
    }
    impl_aggregate! {
        struct GeometryTrianglesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::GEOMETRY_TRIANGLES_NV,
            p_next: *const c_void,
            vertex_data: crate::data::Buffer,
            vertex_offset: crate::data::DeviceSize,
            vertex_count: u32,
            vertex_stride: crate::data::DeviceSize,
            vertex_format: crate::data::Format,
            index_data: crate::data::Buffer,
            index_offset: crate::data::DeviceSize,
            index_count: u32,
            index_type: crate::data::IndexType,
            transform_data: crate::data::Buffer,
            transform_offset: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct GeometryAABBNV {
            s_type: crate::data::StructureType = crate::data::StructureType::GEOMETRY_AABB_NV,
            p_next: *const c_void,
            aabb_data: crate::data::Buffer,
            num_aab_bs: u32,
            stride: u32,
            offset: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct GeometryDataNV {
            triangles: crate::data::GeometryTrianglesNV,
            aabbs: crate::data::GeometryAABBNV,
        }
    }
    impl_aggregate! {
        struct GeometryNV {
            s_type: crate::data::StructureType = crate::data::StructureType::GEOMETRY_NV,
            p_next: *const c_void,
            geometry_type: crate::data::GeometryTypeKHR,
            geometry: crate::data::GeometryDataNV,
            flags: crate::data::GeometryFlagsKHR,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_INFO_NV,
            p_next: *const c_void,
            ty: crate::data::AccelerationStructureTypeNV,
            flags: crate::data::BuildAccelerationStructureFlagsNV,
            instance_count: u32,
            geometry_count: u32,
            p_geometries: *const crate::data::GeometryNV,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_CREATE_INFO_NV,
            p_next: *const c_void,
            compacted_size: crate::data::DeviceSize,
            info: crate::data::AccelerationStructureInfoNV,
        }
    }
    impl_aggregate! {
        struct BindAccelerationStructureMemoryInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV,
            p_next: *const c_void,
            acceleration_structure: crate::data::AccelerationStructureNV,
            memory: crate::data::DeviceMemory,
            memory_offset: crate::data::DeviceSize,
            device_index_count: u32,
            p_device_indices: *const u32,
        }
    }
    impl_aggregate! {
        struct WriteDescriptorSetAccelerationStructureKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
            p_next: *const c_void,
            acceleration_structure_count: u32,
            p_acceleration_structures: *const crate::data::AccelerationStructureKHR,
        }
    }
    impl_aggregate! {
        struct WriteDescriptorSetAccelerationStructureNV {
            s_type: crate::data::StructureType = crate::data::StructureType::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
            p_next: *const c_void,
            acceleration_structure_count: u32,
            p_acceleration_structures: *const crate::data::AccelerationStructureNV,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureMemoryRequirementsInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
            p_next: *const c_void,
            ty: crate::data::AccelerationStructureMemoryRequirementsTypeNV,
            acceleration_structure: crate::data::AccelerationStructureNV,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceAccelerationStructureFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
            p_next: *mut c_void,
            acceleration_structure: crate::data::Bool32,
            acceleration_structure_capture_replay: crate::data::Bool32,
            acceleration_structure_indirect_build: crate::data::Bool32,
            acceleration_structure_host_commands: crate::data::Bool32,
            descriptor_binding_acceleration_structure_update_after_bind: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceRayTracingPipelineFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
            p_next: *mut c_void,
            ray_tracing_pipeline: crate::data::Bool32,
            ray_tracing_pipeline_shader_group_handle_capture_replay: crate::data::Bool32,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: crate::data::Bool32,
            ray_tracing_pipeline_trace_rays_indirect: crate::data::Bool32,
            ray_traversal_primitive_culling: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceRayQueryFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
            p_next: *mut c_void,
            ray_query: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceAccelerationStructurePropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
            p_next: *mut c_void,
            max_geometry_count: u64,
            max_instance_count: u64,
            max_primitive_count: u64,
            max_per_stage_descriptor_acceleration_structures: u32,
            max_per_stage_descriptor_update_after_bind_acceleration_structures: u32,
            max_descriptor_set_acceleration_structures: u32,
            max_descriptor_set_update_after_bind_acceleration_structures: u32,
            min_acceleration_structure_scratch_offset_alignment: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceRayTracingPipelinePropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
            p_next: *mut c_void,
            shader_group_handle_size: u32,
            max_ray_recursion_depth: u32,
            max_shader_group_stride: u32,
            shader_group_base_alignment: u32,
            shader_group_handle_capture_replay_size: u32,
            max_ray_dispatch_invocation_count: u32,
            shader_group_handle_alignment: u32,
            max_ray_hit_attribute_size: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceRayTracingPropertiesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
            p_next: *mut c_void,
            shader_group_handle_size: u32,
            max_recursion_depth: u32,
            max_shader_group_stride: u32,
            shader_group_base_alignment: u32,
            max_geometry_count: u64,
            max_instance_count: u64,
            max_triangle_count: u64,
            max_descriptor_set_acceleration_structures: u32,
        }
    }
    impl_aggregate! {
        struct StridedDeviceAddressRegionKHR {
            device_address: crate::data::DeviceAddress,
            stride: crate::data::DeviceSize,
            size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct TraceRaysIndirectCommandKHR {
            width: u32,
            height: u32,
            depth: u32,
        }
    }
    impl_aggregate! {
        struct TraceRaysIndirectCommand2KHR {
            raygen_shader_record_address: crate::data::DeviceAddress,
            raygen_shader_record_size: crate::data::DeviceSize,
            miss_shader_binding_table_address: crate::data::DeviceAddress,
            miss_shader_binding_table_size: crate::data::DeviceSize,
            miss_shader_binding_table_stride: crate::data::DeviceSize,
            hit_shader_binding_table_address: crate::data::DeviceAddress,
            hit_shader_binding_table_size: crate::data::DeviceSize,
            hit_shader_binding_table_stride: crate::data::DeviceSize,
            callable_shader_binding_table_address: crate::data::DeviceAddress,
            callable_shader_binding_table_size: crate::data::DeviceSize,
            callable_shader_binding_table_stride: crate::data::DeviceSize,
            width: u32,
            height: u32,
            depth: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceRayTracingMaintenance1FeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR,
            p_next: *mut c_void,
            ray_tracing_maintenance_1: crate::data::Bool32,
            ray_tracing_pipeline_trace_rays_indirect_2: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct DrmFormatModifierPropertiesListEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
            p_next: *mut c_void,
            drm_format_modifier_count: u32,
            p_drm_format_modifier_properties: *mut crate::data::DrmFormatModifierPropertiesEXT,
        }
    }
    impl_aggregate! {
        struct DrmFormatModifierPropertiesEXT {
            drm_format_modifier: u64,
            drm_format_modifier_plane_count: u32,
            drm_format_modifier_tiling_features: crate::data::FormatFeatureFlags,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceImageDrmFormatModifierInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
            p_next: *const c_void,
            drm_format_modifier: u64,
            sharing_mode: crate::data::SharingMode,
            queue_family_index_count: u32,
            p_queue_family_indices: *const u32,
        }
    }
    impl_aggregate! {
        struct ImageDrmFormatModifierListCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
            p_next: *const c_void,
            drm_format_modifier_count: u32,
            p_drm_format_modifiers: *const u64,
        }
    }
    impl_aggregate! {
        struct ImageDrmFormatModifierExplicitCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
            p_next: *const c_void,
            drm_format_modifier: u64,
            drm_format_modifier_plane_count: u32,
            p_plane_layouts: *const crate::data::SubresourceLayout,
        }
    }
    impl_aggregate! {
        struct ImageDrmFormatModifierPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
            p_next: *mut c_void,
            drm_format_modifier: u64,
        }
    }
    impl_aggregate! {
        struct ImageStencilUsageCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_STENCIL_USAGE_CREATE_INFO,
            p_next: *const c_void,
            stencil_usage: crate::data::ImageUsageFlags,
        }
    }
    impl_aggregate! {
        struct DeviceMemoryOverallocationCreateInfoAMD {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
            p_next: *const c_void,
            overallocation_behavior: crate::data::MemoryOverallocationBehaviorAMD,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentDensityMapFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
            p_next: *mut c_void,
            fragment_density_map: crate::data::Bool32,
            fragment_density_map_dynamic: crate::data::Bool32,
            fragment_density_map_non_subsampled_images: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentDensityMap2FeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
            p_next: *mut c_void,
            fragment_density_map_deferred: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM,
            p_next: *mut c_void,
            fragment_density_map_offset: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentDensityMapPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
            p_next: *mut c_void,
            min_fragment_density_texel_size: crate::data::Extent2D,
            max_fragment_density_texel_size: crate::data::Extent2D,
            fragment_density_invocations: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentDensityMap2PropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT,
            p_next: *mut c_void,
            subsampled_loads: crate::data::Bool32,
            subsampled_coarse_reconstruction_early_access: crate::data::Bool32,
            max_subsampled_array_layers: u32,
            max_descriptor_set_subsampled_samplers: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM,
            p_next: *mut c_void,
            fragment_density_offset_granularity: crate::data::Extent2D,
        }
    }
    impl_aggregate! {
        struct RenderPassFragmentDensityMapCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
            p_next: *const c_void,
            fragment_density_map_attachment: crate::data::AttachmentReference,
        }
    }
    impl_aggregate! {
        struct SubpassFragmentDensityMapOffsetEndInfoQCOM {
            s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM,
            p_next: *const c_void,
            fragment_density_offset_count: u32,
            p_fragment_density_offsets: *const crate::data::Offset2D,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceScalarBlockLayoutFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
            p_next: *mut c_void,
            scalar_block_layout: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct SurfaceProtectedCapabilitiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_PROTECTED_CAPABILITIES_KHR,
            p_next: *const c_void,
            supports_protected: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceUniformBufferStandardLayoutFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
            p_next: *mut c_void,
            uniform_buffer_standard_layout: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDepthClipEnableFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
            p_next: *mut c_void,
            depth_clip_enable: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineRasterizationDepthClipStateCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
            p_next: *const c_void,
            flags: crate::data::PipelineRasterizationDepthClipStateCreateFlagsEXT,
            depth_clip_enable: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMemoryBudgetPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
            p_next: *mut c_void,
            heap_budget: [crate::data::DeviceSize; 16],
            heap_usage: [crate::data::DeviceSize; 16],
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMemoryPriorityFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
            p_next: *mut c_void,
            memory_priority: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct MemoryPriorityAllocateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
            p_next: *const c_void,
            priority: c_float,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
            p_next: *mut c_void,
            pageable_device_local_memory: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceBufferDeviceAddressFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
            p_next: *mut c_void,
            buffer_device_address: crate::data::Bool32,
            buffer_device_address_capture_replay: crate::data::Bool32,
            buffer_device_address_multi_device: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceBufferDeviceAddressFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
            p_next: *mut c_void,
            buffer_device_address: crate::data::Bool32,
            buffer_device_address_capture_replay: crate::data::Bool32,
            buffer_device_address_multi_device: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct BufferDeviceAddressInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_DEVICE_ADDRESS_INFO,
            p_next: *const c_void,
            buffer: crate::data::Buffer,
        }
    }
    impl_aggregate! {
        struct BufferOpaqueCaptureAddressCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
            p_next: *const c_void,
            opaque_capture_address: u64,
        }
    }
    impl_aggregate! {
        struct BufferDeviceAddressCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
            p_next: *const c_void,
            device_address: crate::data::DeviceAddress,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceImageViewImageFormatInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
            p_next: *mut c_void,
            image_view_type: crate::data::ImageViewType,
        }
    }
    impl_aggregate! {
        struct FilterCubicImageViewImageFormatPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
            p_next: *mut c_void,
            filter_cubic: crate::data::Bool32,
            filter_cubic_minmax: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceImagelessFramebufferFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
            p_next: *mut c_void,
            imageless_framebuffer: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct FramebufferAttachmentsCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
            p_next: *const c_void,
            attachment_image_info_count: u32,
            p_attachment_image_infos: *const crate::data::FramebufferAttachmentImageInfo,
        }
    }
    impl_aggregate! {
        struct FramebufferAttachmentImageInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
            p_next: *const c_void,
            flags: crate::data::ImageCreateFlags,
            usage: crate::data::ImageUsageFlags,
            width: u32,
            height: u32,
            layer_count: u32,
            view_format_count: u32,
            p_view_formats: *const crate::data::Format,
        }
    }
    impl_aggregate! {
        struct RenderPassAttachmentBeginInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_ATTACHMENT_BEGIN_INFO,
            p_next: *const c_void,
            attachment_count: u32,
            p_attachments: *const crate::data::ImageView,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceTextureCompressionASTCHDRFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
            p_next: *mut c_void,
            texture_compression_astc_hdr: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceCooperativeMatrixFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
            p_next: *mut c_void,
            cooperative_matrix: crate::data::Bool32,
            cooperative_matrix_robust_buffer_access: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceCooperativeMatrixPropertiesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
            p_next: *mut c_void,
            cooperative_matrix_supported_stages: crate::data::ShaderStageFlags,
        }
    }
    impl_aggregate! {
        struct CooperativeMatrixPropertiesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::COOPERATIVE_MATRIX_PROPERTIES_NV,
            p_next: *mut c_void,
            m_size: u32,
            n_size: u32,
            k_size: u32,
            a_type: crate::data::ComponentTypeNV,
            b_type: crate::data::ComponentTypeNV,
            c_type: crate::data::ComponentTypeNV,
            d_type: crate::data::ComponentTypeNV,
            scope: crate::data::ScopeNV,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceYcbcrImageArraysFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
            p_next: *mut c_void,
            ycbcr_image_arrays: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct ImageViewHandleInfoNVX {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_VIEW_HANDLE_INFO_NVX,
            p_next: *const c_void,
            image_view: crate::data::ImageView,
            descriptor_type: crate::data::DescriptorType,
            sampler: crate::data::Sampler,
        }
    }
    impl_aggregate! {
        struct ImageViewAddressPropertiesNVX {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_VIEW_ADDRESS_PROPERTIES_NVX,
            p_next: *mut c_void,
            device_address: crate::data::DeviceAddress,
            size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct PresentFrameTokenGGP {
            s_type: crate::data::StructureType = crate::data::StructureType::PRESENT_FRAME_TOKEN_GGP,
            p_next: *const c_void,
            frame_token: GgpFrameToken,
        }
    }
    impl_aggregate! {
        struct PipelineCreationFeedback {
            flags: crate::data::PipelineCreationFeedbackFlags,
            duration: u64,
        }
    }
    impl_aggregate! {
        struct PipelineCreationFeedbackCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
            p_next: *const c_void,
            p_pipeline_creation_feedback: *mut crate::data::PipelineCreationFeedback,
            pipeline_stage_creation_feedback_count: u32,
            p_pipeline_stage_creation_feedbacks: *mut crate::data::PipelineCreationFeedback,
        }
    }
    impl_aggregate! {
        struct SurfaceFullScreenExclusiveInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            p_next: *mut c_void,
            full_screen_exclusive: crate::data::FullScreenExclusiveEXT,
        }
    }
    impl_aggregate! {
        struct SurfaceFullScreenExclusiveWin32InfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
            p_next: *const c_void,
            hmonitor: HMONITOR,
        }
    }
    impl_aggregate! {
        struct SurfaceCapabilitiesFullScreenExclusiveEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
            p_next: *mut c_void,
            full_screen_exclusive_supported: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePresentBarrierFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV,
            p_next: *mut c_void,
            present_barrier: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct SurfaceCapabilitiesPresentBarrierNV {
            s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_CAPABILITIES_PRESENT_BARRIER_NV,
            p_next: *mut c_void,
            present_barrier_supported: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct SwapchainPresentBarrierCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV,
            p_next: *mut c_void,
            present_barrier_enable: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePerformanceQueryFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
            p_next: *mut c_void,
            performance_counter_query_pools: crate::data::Bool32,
            performance_counter_multiple_query_pools: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePerformanceQueryPropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
            p_next: *mut c_void,
            allow_command_buffer_query_copies: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PerformanceCounterKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PERFORMANCE_COUNTER_KHR,
            p_next: *mut c_void,
            unit: crate::data::PerformanceCounterUnitKHR,
            scope: crate::data::PerformanceCounterScopeKHR,
            storage: crate::data::PerformanceCounterStorageKHR,
            uuid: [u8; 16],
        }
    }
    impl_aggregate! {
        struct PerformanceCounterDescriptionKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PERFORMANCE_COUNTER_DESCRIPTION_KHR,
            p_next: *mut c_void,
            flags: crate::data::PerformanceCounterDescriptionFlagsKHR,
            name: [c_char; 256],
            category: [c_char; 256],
            description: [c_char; 256],
        }
    }
    impl_aggregate! {
        struct QueryPoolPerformanceCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
            p_next: *const c_void,
            queue_family_index: u32,
            counter_index_count: u32,
            p_counter_indices: *const u32,
        }
    }
    impl_aggregate! {
        union PerformanceCounterResultKHR {
            int_32: i32,
            int_64: i64,
            uint_32: u32,
            uint_64: u64,
            float_32: c_float,
            float_64: c_double,
        }
    }
    impl_aggregate! {
        struct AcquireProfilingLockInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::ACQUIRE_PROFILING_LOCK_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::AcquireProfilingLockFlagsKHR,
            timeout: u64,
        }
    }
    impl_aggregate! {
        struct PerformanceQuerySubmitInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
            p_next: *const c_void,
            counter_pass_index: u32,
        }
    }
    impl_aggregate! {
        struct HeadlessSurfaceCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::HEADLESS_SURFACE_CREATE_INFO_EXT,
            p_next: *const c_void,
            flags: crate::data::HeadlessSurfaceCreateFlagsEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceCoverageReductionModeFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
            p_next: *mut c_void,
            coverage_reduction_mode: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineCoverageReductionStateCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
            p_next: *const c_void,
            flags: crate::data::PipelineCoverageReductionStateCreateFlagsNV,
            coverage_reduction_mode: crate::data::CoverageReductionModeNV,
        }
    }
    impl_aggregate! {
        struct FramebufferMixedSamplesCombinationNV {
            s_type: crate::data::StructureType = crate::data::StructureType::FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV,
            p_next: *mut c_void,
            coverage_reduction_mode: crate::data::CoverageReductionModeNV,
            rasterization_samples: crate::data::SampleCountFlagBits,
            depth_stencil_samples: crate::data::SampleCountFlags,
            color_samples: crate::data::SampleCountFlags,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
            p_next: *mut c_void,
            shader_integer_functions_2: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        union PerformanceValueDataINTEL {
            value_32: u32,
            value_64: u64,
            value_float: c_float,
            value_bool: crate::data::Bool32,
            value_string: *const c_char,
        }
    }
    impl_aggregate! {
        struct PerformanceValueINTEL {
            ty: crate::data::PerformanceValueTypeINTEL,
            data: crate::data::PerformanceValueDataINTEL,
        }
    }
    impl_aggregate! {
        struct InitializePerformanceApiInfoINTEL {
            s_type: crate::data::StructureType = crate::data::StructureType::INITIALIZE_PERFORMANCE_API_INFO_INTEL,
            p_next: *const c_void,
            p_user_data: *mut c_void,
        }
    }
    impl_aggregate! {
        struct QueryPoolPerformanceQueryCreateInfoINTEL {
            s_type: crate::data::StructureType = crate::data::StructureType::QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
            p_next: *const c_void,
            performance_counters_sampling: crate::data::QueryPoolSamplingModeINTEL,
        }
    }
    impl_aggregate! {
        struct PerformanceMarkerInfoINTEL {
            s_type: crate::data::StructureType = crate::data::StructureType::PERFORMANCE_MARKER_INFO_INTEL,
            p_next: *const c_void,
            marker: u64,
        }
    }
    impl_aggregate! {
        struct PerformanceStreamMarkerInfoINTEL {
            s_type: crate::data::StructureType = crate::data::StructureType::PERFORMANCE_STREAM_MARKER_INFO_INTEL,
            p_next: *const c_void,
            marker: u32,
        }
    }
    impl_aggregate! {
        struct PerformanceOverrideInfoINTEL {
            s_type: crate::data::StructureType = crate::data::StructureType::PERFORMANCE_OVERRIDE_INFO_INTEL,
            p_next: *const c_void,
            ty: crate::data::PerformanceOverrideTypeINTEL,
            enable: crate::data::Bool32,
            parameter: u64,
        }
    }
    impl_aggregate! {
        struct PerformanceConfigurationAcquireInfoINTEL {
            s_type: crate::data::StructureType = crate::data::StructureType::PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL,
            p_next: *const c_void,
            ty: crate::data::PerformanceConfigurationTypeINTEL,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderClockFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
            p_next: *mut c_void,
            shader_subgroup_clock: crate::data::Bool32,
            shader_device_clock: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceIndexTypeUint8FeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT,
            p_next: *mut c_void,
            index_type_uint_8: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderSMBuiltinsPropertiesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV,
            p_next: *mut c_void,
            shader_sm_count: u32,
            shader_warps_per_sm: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderSMBuiltinsFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV,
            p_next: *mut c_void,
            shader_sm_builtins: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
            p_next: *mut c_void,
            fragment_shader_sample_interlock: crate::data::Bool32,
            fragment_shader_pixel_interlock: crate::data::Bool32,
            fragment_shader_shading_rate_interlock: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
            p_next: *mut c_void,
            separate_depth_stencil_layouts: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct AttachmentReferenceStencilLayout {
            s_type: crate::data::StructureType = crate::data::StructureType::ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
            p_next: *mut c_void,
            stencil_layout: crate::data::ImageLayout,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
            p_next: *mut c_void,
            primitive_topology_list_restart: crate::data::Bool32,
            primitive_topology_patch_list_restart: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct AttachmentDescriptionStencilLayout {
            s_type: crate::data::StructureType = crate::data::StructureType::ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
            p_next: *mut c_void,
            stencil_initial_layout: crate::data::ImageLayout,
            stencil_final_layout: crate::data::ImageLayout,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
            p_next: *mut c_void,
            pipeline_executable_info: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_INFO_KHR,
            p_next: *const c_void,
            pipeline: crate::data::Pipeline,
        }
    }
    impl_aggregate! {
        struct PipelineExecutablePropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_EXECUTABLE_PROPERTIES_KHR,
            p_next: *mut c_void,
            stages: crate::data::ShaderStageFlags,
            name: [c_char; 256],
            description: [c_char; 256],
            subgroup_size: u32,
        }
    }
    impl_aggregate! {
        struct PipelineExecutableInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_EXECUTABLE_INFO_KHR,
            p_next: *const c_void,
            pipeline: crate::data::Pipeline,
            executable_index: u32,
        }
    }
    impl_aggregate! {
        union PipelineExecutableStatisticValueKHR {
            b_32: crate::data::Bool32,
            i_64: i64,
            u_64: u64,
            f_64: c_double,
        }
    }
    impl_aggregate! {
        struct PipelineExecutableStatisticKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_EXECUTABLE_STATISTIC_KHR,
            p_next: *mut c_void,
            name: [c_char; 256],
            description: [c_char; 256],
            format: crate::data::PipelineExecutableStatisticFormatKHR,
            value: crate::data::PipelineExecutableStatisticValueKHR,
        }
    }
    impl_aggregate! {
        struct PipelineExecutableInternalRepresentationKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR,
            p_next: *mut c_void,
            name: [c_char; 256],
            description: [c_char; 256],
            is_text: crate::data::Bool32,
            data_size: usize,
            p_data: *mut c_void,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
            p_next: *mut c_void,
            shader_demote_to_helper_invocation: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
            p_next: *mut c_void,
            texel_buffer_alignment: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceTexelBufferAlignmentProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
            p_next: *mut c_void,
            storage_texel_buffer_offset_alignment_bytes: crate::data::DeviceSize,
            storage_texel_buffer_offset_single_texel_alignment: crate::data::Bool32,
            uniform_texel_buffer_offset_alignment_bytes: crate::data::DeviceSize,
            uniform_texel_buffer_offset_single_texel_alignment: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSubgroupSizeControlFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
            p_next: *mut c_void,
            subgroup_size_control: crate::data::Bool32,
            compute_full_subgroups: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSubgroupSizeControlProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
            p_next: *mut c_void,
            min_subgroup_size: u32,
            max_subgroup_size: u32,
            max_compute_workgroup_subgroups: u32,
            required_subgroup_size_stages: crate::data::ShaderStageFlags,
        }
    }
    impl_aggregate! {
        struct PipelineShaderStageRequiredSubgroupSizeCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
            p_next: *mut c_void,
            required_subgroup_size: u32,
        }
    }
    impl_aggregate! {
        struct SubpassShadingPipelineCreateInfoHUAWEI {
            s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI,
            p_next: *mut c_void,
            render_pass: crate::data::RenderPass,
            subpass: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSubpassShadingPropertiesHUAWEI {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI,
            p_next: *mut c_void,
            max_subpass_shading_workgroup_size_aspect_ratio: u32,
        }
    }
    impl_aggregate! {
        struct MemoryOpaqueCaptureAddressAllocateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
            p_next: *const c_void,
            opaque_capture_address: u64,
        }
    }
    impl_aggregate! {
        struct DeviceMemoryOpaqueCaptureAddressInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
            p_next: *const c_void,
            memory: crate::data::DeviceMemory,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceLineRasterizationFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT,
            p_next: *mut c_void,
            rectangular_lines: crate::data::Bool32,
            bresenham_lines: crate::data::Bool32,
            smooth_lines: crate::data::Bool32,
            stippled_rectangular_lines: crate::data::Bool32,
            stippled_bresenham_lines: crate::data::Bool32,
            stippled_smooth_lines: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceLineRasterizationPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT,
            p_next: *mut c_void,
            line_sub_pixel_precision_bits: u32,
        }
    }
    impl_aggregate! {
        struct PipelineRasterizationLineStateCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT,
            p_next: *const c_void,
            line_rasterization_mode: crate::data::LineRasterizationModeEXT,
            stippled_line_enable: crate::data::Bool32,
            line_stipple_factor: u32,
            line_stipple_pattern: u16,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePipelineCreationCacheControlFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
            p_next: *mut c_void,
            pipeline_creation_cache_control: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceVulkan11Features {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
            p_next: *mut c_void,
            storage_buffer_16_bit_access: crate::data::Bool32,
            uniform_and_storage_buffer_16_bit_access: crate::data::Bool32,
            storage_push_constant_16: crate::data::Bool32,
            storage_input_output_16: crate::data::Bool32,
            multiview: crate::data::Bool32,
            multiview_geometry_shader: crate::data::Bool32,
            multiview_tessellation_shader: crate::data::Bool32,
            variable_pointers_storage_buffer: crate::data::Bool32,
            variable_pointers: crate::data::Bool32,
            protected_memory: crate::data::Bool32,
            sampler_ycbcr_conversion: crate::data::Bool32,
            shader_draw_parameters: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceVulkan11Properties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
            p_next: *mut c_void,
            device_uuid: [u8; 16],
            driver_uuid: [u8; 16],
            device_luid: [u8; 8],
            device_node_mask: u32,
            device_luid_valid: crate::data::Bool32,
            subgroup_size: u32,
            subgroup_supported_stages: crate::data::ShaderStageFlags,
            subgroup_supported_operations: crate::data::SubgroupFeatureFlags,
            subgroup_quad_operations_in_all_stages: crate::data::Bool32,
            point_clipping_behavior: crate::data::PointClippingBehavior,
            max_multiview_view_count: u32,
            max_multiview_instance_index: u32,
            protected_no_fault: crate::data::Bool32,
            max_per_set_descriptors: u32,
            max_memory_allocation_size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceVulkan12Features {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
            p_next: *mut c_void,
            sampler_mirror_clamp_to_edge: crate::data::Bool32,
            draw_indirect_count: crate::data::Bool32,
            storage_buffer_8_bit_access: crate::data::Bool32,
            uniform_and_storage_buffer_8_bit_access: crate::data::Bool32,
            storage_push_constant_8: crate::data::Bool32,
            shader_buffer_int_64_atomics: crate::data::Bool32,
            shader_shared_int_64_atomics: crate::data::Bool32,
            shader_float_16: crate::data::Bool32,
            shader_int_8: crate::data::Bool32,
            descriptor_indexing: crate::data::Bool32,
            shader_input_attachment_array_dynamic_indexing: crate::data::Bool32,
            shader_uniform_texel_buffer_array_dynamic_indexing: crate::data::Bool32,
            shader_storage_texel_buffer_array_dynamic_indexing: crate::data::Bool32,
            shader_uniform_buffer_array_non_uniform_indexing: crate::data::Bool32,
            shader_sampled_image_array_non_uniform_indexing: crate::data::Bool32,
            shader_storage_buffer_array_non_uniform_indexing: crate::data::Bool32,
            shader_storage_image_array_non_uniform_indexing: crate::data::Bool32,
            shader_input_attachment_array_non_uniform_indexing: crate::data::Bool32,
            shader_uniform_texel_buffer_array_non_uniform_indexing: crate::data::Bool32,
            shader_storage_texel_buffer_array_non_uniform_indexing: crate::data::Bool32,
            descriptor_binding_uniform_buffer_update_after_bind: crate::data::Bool32,
            descriptor_binding_sampled_image_update_after_bind: crate::data::Bool32,
            descriptor_binding_storage_image_update_after_bind: crate::data::Bool32,
            descriptor_binding_storage_buffer_update_after_bind: crate::data::Bool32,
            descriptor_binding_uniform_texel_buffer_update_after_bind: crate::data::Bool32,
            descriptor_binding_storage_texel_buffer_update_after_bind: crate::data::Bool32,
            descriptor_binding_update_unused_while_pending: crate::data::Bool32,
            descriptor_binding_partially_bound: crate::data::Bool32,
            descriptor_binding_variable_descriptor_count: crate::data::Bool32,
            runtime_descriptor_array: crate::data::Bool32,
            sampler_filter_minmax: crate::data::Bool32,
            scalar_block_layout: crate::data::Bool32,
            imageless_framebuffer: crate::data::Bool32,
            uniform_buffer_standard_layout: crate::data::Bool32,
            shader_subgroup_extended_types: crate::data::Bool32,
            separate_depth_stencil_layouts: crate::data::Bool32,
            host_query_reset: crate::data::Bool32,
            timeline_semaphore: crate::data::Bool32,
            buffer_device_address: crate::data::Bool32,
            buffer_device_address_capture_replay: crate::data::Bool32,
            buffer_device_address_multi_device: crate::data::Bool32,
            vulkan_memory_model: crate::data::Bool32,
            vulkan_memory_model_device_scope: crate::data::Bool32,
            vulkan_memory_model_availability_visibility_chains: crate::data::Bool32,
            shader_output_viewport_index: crate::data::Bool32,
            shader_output_layer: crate::data::Bool32,
            subgroup_broadcast_dynamic_id: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceVulkan12Properties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
            p_next: *mut c_void,
            driver_id: crate::data::DriverId,
            driver_name: [c_char; 256],
            driver_info: [c_char; 256],
            conformance_version: crate::data::ConformanceVersion,
            denorm_behavior_independence: crate::data::ShaderFloatControlsIndependence,
            rounding_mode_independence: crate::data::ShaderFloatControlsIndependence,
            shader_signed_zero_inf_nan_preserve_float_16: crate::data::Bool32,
            shader_signed_zero_inf_nan_preserve_float_32: crate::data::Bool32,
            shader_signed_zero_inf_nan_preserve_float_64: crate::data::Bool32,
            shader_denorm_preserve_float_16: crate::data::Bool32,
            shader_denorm_preserve_float_32: crate::data::Bool32,
            shader_denorm_preserve_float_64: crate::data::Bool32,
            shader_denorm_flush_to_zero_float_16: crate::data::Bool32,
            shader_denorm_flush_to_zero_float_32: crate::data::Bool32,
            shader_denorm_flush_to_zero_float_64: crate::data::Bool32,
            shader_rounding_mode_rte_float_16: crate::data::Bool32,
            shader_rounding_mode_rte_float_32: crate::data::Bool32,
            shader_rounding_mode_rte_float_64: crate::data::Bool32,
            shader_rounding_mode_rtz_float_16: crate::data::Bool32,
            shader_rounding_mode_rtz_float_32: crate::data::Bool32,
            shader_rounding_mode_rtz_float_64: crate::data::Bool32,
            max_update_after_bind_descriptors_in_all_pools: u32,
            shader_uniform_buffer_array_non_uniform_indexing_native: crate::data::Bool32,
            shader_sampled_image_array_non_uniform_indexing_native: crate::data::Bool32,
            shader_storage_buffer_array_non_uniform_indexing_native: crate::data::Bool32,
            shader_storage_image_array_non_uniform_indexing_native: crate::data::Bool32,
            shader_input_attachment_array_non_uniform_indexing_native: crate::data::Bool32,
            robust_buffer_access_update_after_bind: crate::data::Bool32,
            quad_divergent_implicit_lod: crate::data::Bool32,
            max_per_stage_descriptor_update_after_bind_samplers: u32,
            max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
            max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
            max_per_stage_descriptor_update_after_bind_sampled_images: u32,
            max_per_stage_descriptor_update_after_bind_storage_images: u32,
            max_per_stage_descriptor_update_after_bind_input_attachments: u32,
            max_per_stage_update_after_bind_resources: u32,
            max_descriptor_set_update_after_bind_samplers: u32,
            max_descriptor_set_update_after_bind_uniform_buffers: u32,
            max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
            max_descriptor_set_update_after_bind_storage_buffers: u32,
            max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
            max_descriptor_set_update_after_bind_sampled_images: u32,
            max_descriptor_set_update_after_bind_storage_images: u32,
            max_descriptor_set_update_after_bind_input_attachments: u32,
            supported_depth_resolve_modes: crate::data::ResolveModeFlags,
            supported_stencil_resolve_modes: crate::data::ResolveModeFlags,
            independent_resolve_none: crate::data::Bool32,
            independent_resolve: crate::data::Bool32,
            filter_minmax_single_component_formats: crate::data::Bool32,
            filter_minmax_image_component_mapping: crate::data::Bool32,
            max_timeline_semaphore_value_difference: u64,
            framebuffer_integer_color_sample_counts: crate::data::SampleCountFlags,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceVulkan13Features {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
            p_next: *mut c_void,
            robust_image_access: crate::data::Bool32,
            inline_uniform_block: crate::data::Bool32,
            descriptor_binding_inline_uniform_block_update_after_bind: crate::data::Bool32,
            pipeline_creation_cache_control: crate::data::Bool32,
            private_data: crate::data::Bool32,
            shader_demote_to_helper_invocation: crate::data::Bool32,
            shader_terminate_invocation: crate::data::Bool32,
            subgroup_size_control: crate::data::Bool32,
            compute_full_subgroups: crate::data::Bool32,
            synchronization_2: crate::data::Bool32,
            texture_compression_astc_hdr: crate::data::Bool32,
            shader_zero_initialize_workgroup_memory: crate::data::Bool32,
            dynamic_rendering: crate::data::Bool32,
            shader_integer_dot_product: crate::data::Bool32,
            maintenance_4: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceVulkan13Properties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES,
            p_next: *mut c_void,
            min_subgroup_size: u32,
            max_subgroup_size: u32,
            max_compute_workgroup_subgroups: u32,
            required_subgroup_size_stages: crate::data::ShaderStageFlags,
            max_inline_uniform_block_size: u32,
            max_per_stage_descriptor_inline_uniform_blocks: u32,
            max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
            max_descriptor_set_inline_uniform_blocks: u32,
            max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
            max_inline_uniform_total_size: u32,
            integer_dot_product_8_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_8_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_8_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_4x_8_bit_packed_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_4x_8_bit_packed_signed_accelerated: crate::data::Bool32,
            integer_dot_product_4x_8_bit_packed_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_16_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_16_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_16_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_32_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_32_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_32_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_64_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_64_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_64_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_8_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_8_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_8_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_4x_8_bit_packed_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_4x_8_bit_packed_signed_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_4x_8_bit_packed_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_16_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_16_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_16_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_32_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_32_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_32_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_64_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_64_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_64_bit_mixed_signedness_accelerated: crate::data::Bool32,
            storage_texel_buffer_offset_alignment_bytes: crate::data::DeviceSize,
            storage_texel_buffer_offset_single_texel_alignment: crate::data::Bool32,
            uniform_texel_buffer_offset_alignment_bytes: crate::data::DeviceSize,
            uniform_texel_buffer_offset_single_texel_alignment: crate::data::Bool32,
            max_buffer_size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct PipelineCompilerControlCreateInfoAMD {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
            p_next: *const c_void,
            compiler_control_flags: crate::data::PipelineCompilerControlFlagsAMD,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceCoherentMemoryFeaturesAMD {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
            p_next: *mut c_void,
            device_coherent_memory: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceToolProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_TOOL_PROPERTIES,
            p_next: *mut c_void,
            name: [c_char; 256],
            version: [c_char; 256],
            purposes: crate::data::ToolPurposeFlags,
            description: [c_char; 256],
            layer: [c_char; 256],
        }
    }
    impl_aggregate! {
        struct SamplerCustomBorderColorCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
            p_next: *const c_void,
            custom_border_color: crate::data::ClearColorValue,
            format: crate::data::Format,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceCustomBorderColorPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
            p_next: *mut c_void,
            max_custom_border_color_samplers: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceCustomBorderColorFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
            p_next: *mut c_void,
            custom_border_colors: crate::data::Bool32,
            custom_border_color_without_format: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct SamplerBorderColorComponentMappingCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT,
            p_next: *const c_void,
            components: crate::data::ComponentMapping,
            srgb: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceBorderColorSwizzleFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
            p_next: *mut c_void,
            border_color_swizzle: crate::data::Bool32,
            border_color_swizzle_from_image: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        union DeviceOrHostAddressKHR {
            device_address: crate::data::DeviceAddress,
            host_address: *mut c_void,
        }
    }
    impl_aggregate! {
        union DeviceOrHostAddressConstKHR {
            device_address: crate::data::DeviceAddress,
            host_address: *const c_void,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureGeometryTrianglesDataKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
            p_next: *const c_void,
            vertex_format: crate::data::Format,
            vertex_data: crate::data::DeviceOrHostAddressConstKHR,
            vertex_stride: crate::data::DeviceSize,
            max_vertex: u32,
            index_type: crate::data::IndexType,
            index_data: crate::data::DeviceOrHostAddressConstKHR,
            transform_data: crate::data::DeviceOrHostAddressConstKHR,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureGeometryAabbsDataKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR,
            p_next: *const c_void,
            data: crate::data::DeviceOrHostAddressConstKHR,
            stride: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureGeometryInstancesDataKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,
            p_next: *const c_void,
            array_of_pointers: crate::data::Bool32,
            data: crate::data::DeviceOrHostAddressConstKHR,
        }
    }
    impl_aggregate! {
        union AccelerationStructureGeometryDataKHR {
            triangles: crate::data::AccelerationStructureGeometryTrianglesDataKHR,
            aabbs: crate::data::AccelerationStructureGeometryAabbsDataKHR,
            instances: crate::data::AccelerationStructureGeometryInstancesDataKHR,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureGeometryKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_GEOMETRY_KHR,
            p_next: *const c_void,
            geometry_type: crate::data::GeometryTypeKHR,
            geometry: crate::data::AccelerationStructureGeometryDataKHR,
            flags: crate::data::GeometryFlagsKHR,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureBuildGeometryInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
            p_next: *const c_void,
            ty: crate::data::AccelerationStructureTypeKHR,
            flags: crate::data::BuildAccelerationStructureFlagsKHR,
            mode: crate::data::BuildAccelerationStructureModeKHR,
            src_acceleration_structure: crate::data::AccelerationStructureKHR,
            dst_acceleration_structure: crate::data::AccelerationStructureKHR,
            geometry_count: u32,
            p_geometries: *const crate::data::AccelerationStructureGeometryKHR,
            pp_geometries: *const *const crate::data::AccelerationStructureGeometryKHR,
            scratch_data: crate::data::DeviceOrHostAddressKHR,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureBuildRangeInfoKHR {
            primitive_count: u32,
            primitive_offset: u32,
            first_vertex: u32,
            transform_offset: u32,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
            p_next: *const c_void,
            create_flags: crate::data::AccelerationStructureCreateFlagsKHR,
            buffer: crate::data::Buffer,
            offset: crate::data::DeviceSize,
            size: crate::data::DeviceSize,
            ty: crate::data::AccelerationStructureTypeKHR,
            device_address: crate::data::DeviceAddress,
        }
    }
    impl_aggregate! {
        struct AabbPositionsKHR {
            min_x: c_float,
            min_y: c_float,
            min_z: c_float,
            max_x: c_float,
            max_y: c_float,
            max_z: c_float,
        }
    }
    impl_aggregate! {
        struct TransformMatrixKHR {
            matrix: [c_float; 3],
        }
    }
    impl_aggregate! {
        struct AccelerationStructureInstanceKHR {
            transform: crate::data::TransformMatrixKHR,
            instance_custom_index: u32,
            mask: u32,
            instance_shader_binding_table_record_offset: u32,
            flags: crate::data::GeometryInstanceFlagsKHR,
            acceleration_structure_reference: u64,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureDeviceAddressInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,
            p_next: *const c_void,
            acceleration_structure: crate::data::AccelerationStructureKHR,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureVersionInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_VERSION_INFO_KHR,
            p_next: *const c_void,
            p_version_data: *const u8,
        }
    }
    impl_aggregate! {
        struct CopyAccelerationStructureInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::COPY_ACCELERATION_STRUCTURE_INFO_KHR,
            p_next: *const c_void,
            src: crate::data::AccelerationStructureKHR,
            dst: crate::data::AccelerationStructureKHR,
            mode: crate::data::CopyAccelerationStructureModeKHR,
        }
    }
    impl_aggregate! {
        struct CopyAccelerationStructureToMemoryInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR,
            p_next: *const c_void,
            src: crate::data::AccelerationStructureKHR,
            dst: crate::data::DeviceOrHostAddressKHR,
            mode: crate::data::CopyAccelerationStructureModeKHR,
        }
    }
    impl_aggregate! {
        struct CopyMemoryToAccelerationStructureInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR,
            p_next: *const c_void,
            src: crate::data::DeviceOrHostAddressConstKHR,
            dst: crate::data::AccelerationStructureKHR,
            mode: crate::data::CopyAccelerationStructureModeKHR,
        }
    }
    impl_aggregate! {
        struct RayTracingPipelineInterfaceCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR,
            p_next: *const c_void,
            max_pipeline_ray_payload_size: u32,
            max_pipeline_ray_hit_attribute_size: u32,
        }
    }
    impl_aggregate! {
        struct PipelineLibraryCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_LIBRARY_CREATE_INFO_KHR,
            p_next: *const c_void,
            library_count: u32,
            p_libraries: *const crate::data::Pipeline,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceExtendedDynamicStateFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
            p_next: *mut c_void,
            extended_dynamic_state: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceExtendedDynamicState2FeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
            p_next: *mut c_void,
            extended_dynamic_state_2: crate::data::Bool32,
            extended_dynamic_state_2_logic_op: crate::data::Bool32,
            extended_dynamic_state_2_patch_control_points: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceExtendedDynamicState3FeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT,
            p_next: *mut c_void,
            extended_dynamic_state_3_tessellation_domain_origin: crate::data::Bool32,
            extended_dynamic_state_3_depth_clamp_enable: crate::data::Bool32,
            extended_dynamic_state_3_polygon_mode: crate::data::Bool32,
            extended_dynamic_state_3_rasterization_samples: crate::data::Bool32,
            extended_dynamic_state_3_sample_mask: crate::data::Bool32,
            extended_dynamic_state_3_alpha_to_coverage_enable: crate::data::Bool32,
            extended_dynamic_state_3_alpha_to_one_enable: crate::data::Bool32,
            extended_dynamic_state_3_logic_op_enable: crate::data::Bool32,
            extended_dynamic_state_3_color_blend_enable: crate::data::Bool32,
            extended_dynamic_state_3_color_blend_equation: crate::data::Bool32,
            extended_dynamic_state_3_color_write_mask: crate::data::Bool32,
            extended_dynamic_state_3_rasterization_stream: crate::data::Bool32,
            extended_dynamic_state_3_conservative_rasterization_mode: crate::data::Bool32,
            extended_dynamic_state_3_extra_primitive_overestimation_size: crate::data::Bool32,
            extended_dynamic_state_3_depth_clip_enable: crate::data::Bool32,
            extended_dynamic_state_3_sample_locations_enable: crate::data::Bool32,
            extended_dynamic_state_3_color_blend_advanced: crate::data::Bool32,
            extended_dynamic_state_3_provoking_vertex_mode: crate::data::Bool32,
            extended_dynamic_state_3_line_rasterization_mode: crate::data::Bool32,
            extended_dynamic_state_3_line_stipple_enable: crate::data::Bool32,
            extended_dynamic_state_3_depth_clip_negative_one_to_one: crate::data::Bool32,
            extended_dynamic_state_3_viewport_w_scaling_enable: crate::data::Bool32,
            extended_dynamic_state_3_viewport_swizzle: crate::data::Bool32,
            extended_dynamic_state_3_coverage_to_color_enable: crate::data::Bool32,
            extended_dynamic_state_3_coverage_to_color_location: crate::data::Bool32,
            extended_dynamic_state_3_coverage_modulation_mode: crate::data::Bool32,
            extended_dynamic_state_3_coverage_modulation_table_enable: crate::data::Bool32,
            extended_dynamic_state_3_coverage_modulation_table: crate::data::Bool32,
            extended_dynamic_state_3_coverage_reduction_mode: crate::data::Bool32,
            extended_dynamic_state_3_representative_fragment_test_enable: crate::data::Bool32,
            extended_dynamic_state_3_shading_rate_image_enable: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceExtendedDynamicState3PropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT,
            p_next: *mut c_void,
            dynamic_primitive_topology_unrestricted: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct ColorBlendEquationEXT {
            src_color_blend_factor: crate::data::BlendFactor,
            dst_color_blend_factor: crate::data::BlendFactor,
            color_blend_op: crate::data::BlendOp,
            src_alpha_blend_factor: crate::data::BlendFactor,
            dst_alpha_blend_factor: crate::data::BlendFactor,
            alpha_blend_op: crate::data::BlendOp,
        }
    }
    impl_aggregate! {
        struct ColorBlendAdvancedEXT {
            advanced_blend_op: crate::data::BlendOp,
            src_premultiplied: crate::data::Bool32,
            dst_premultiplied: crate::data::Bool32,
            blend_overlap: crate::data::BlendOverlapEXT,
            clamp_results: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct RenderPassTransformBeginInfoQCOM {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM,
            p_next: *mut c_void,
            transform: crate::data::SurfaceTransformFlagBitsKHR,
        }
    }
    impl_aggregate! {
        struct CopyCommandTransformInfoQCOM {
            s_type: crate::data::StructureType = crate::data::StructureType::COPY_COMMAND_TRANSFORM_INFO_QCOM,
            p_next: *const c_void,
            transform: crate::data::SurfaceTransformFlagBitsKHR,
        }
    }
    impl_aggregate! {
        struct CommandBufferInheritanceRenderPassTransformInfoQCOM {
            s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM,
            p_next: *mut c_void,
            transform: crate::data::SurfaceTransformFlagBitsKHR,
            render_area: crate::data::Rect2D,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDiagnosticsConfigFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV,
            p_next: *mut c_void,
            diagnostics_config: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct DeviceDiagnosticsConfigCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV,
            p_next: *const c_void,
            flags: crate::data::DeviceDiagnosticsConfigFlagsNV,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
            p_next: *mut c_void,
            shader_zero_initialize_workgroup_memory: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
            p_next: *mut c_void,
            shader_subgroup_uniform_control_flow: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceRobustness2FeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT,
            p_next: *mut c_void,
            robust_buffer_access_2: crate::data::Bool32,
            robust_image_access_2: crate::data::Bool32,
            null_descriptor: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceRobustness2PropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT,
            p_next: *mut c_void,
            robust_storage_buffer_access_size_alignment: crate::data::DeviceSize,
            robust_uniform_buffer_access_size_alignment: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceImageRobustnessFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
            p_next: *mut c_void,
            robust_image_access: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
            p_next: *mut c_void,
            workgroup_memory_explicit_layout: crate::data::Bool32,
            workgroup_memory_explicit_layout_scalar_block_layout: crate::data::Bool32,
            workgroup_memory_explicit_layout_8_bit_access: crate::data::Bool32,
            workgroup_memory_explicit_layout_16_bit_access: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePortabilitySubsetFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
            p_next: *mut c_void,
            constant_alpha_color_blend_factors: crate::data::Bool32,
            events: crate::data::Bool32,
            image_view_format_reinterpretation: crate::data::Bool32,
            image_view_format_swizzle: crate::data::Bool32,
            image_view_2d_on_3d_image: crate::data::Bool32,
            multisample_array_image: crate::data::Bool32,
            mutable_comparison_samplers: crate::data::Bool32,
            point_polygons: crate::data::Bool32,
            sampler_mip_lod_bias: crate::data::Bool32,
            separate_stencil_mask_ref: crate::data::Bool32,
            shader_sample_rate_interpolation_functions: crate::data::Bool32,
            tessellation_isolines: crate::data::Bool32,
            tessellation_point_mode: crate::data::Bool32,
            triangle_fans: crate::data::Bool32,
            vertex_attribute_access_beyond_stride: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePortabilitySubsetPropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR,
            p_next: *mut c_void,
            min_vertex_input_binding_stride_alignment: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDevice4444FormatsFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
            p_next: *mut c_void,
            format_a_4r_4g_4b_4: crate::data::Bool32,
            format_a_4b_4g_4r_4: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSubpassShadingFeaturesHUAWEI {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
            p_next: *mut c_void,
            subpass_shading: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct BufferCopy2 {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_COPY_2,
            p_next: *const c_void,
            src_offset: crate::data::DeviceSize,
            dst_offset: crate::data::DeviceSize,
            size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct ImageCopy2 {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_COPY_2,
            p_next: *const c_void,
            src_subresource: crate::data::ImageSubresourceLayers,
            src_offset: crate::data::Offset3D,
            dst_subresource: crate::data::ImageSubresourceLayers,
            dst_offset: crate::data::Offset3D,
            extent: crate::data::Extent3D,
        }
    }
    impl_aggregate! {
        struct ImageBlit2 {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_BLIT_2,
            p_next: *const c_void,
            src_subresource: crate::data::ImageSubresourceLayers,
            src_offsets: [crate::data::Offset3D; 2],
            dst_subresource: crate::data::ImageSubresourceLayers,
            dst_offsets: [crate::data::Offset3D; 2],
        }
    }
    impl_aggregate! {
        struct BufferImageCopy2 {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_IMAGE_COPY_2,
            p_next: *const c_void,
            buffer_offset: crate::data::DeviceSize,
            buffer_row_length: u32,
            buffer_image_height: u32,
            image_subresource: crate::data::ImageSubresourceLayers,
            image_offset: crate::data::Offset3D,
            image_extent: crate::data::Extent3D,
        }
    }
    impl_aggregate! {
        struct ImageResolve2 {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_RESOLVE_2,
            p_next: *const c_void,
            src_subresource: crate::data::ImageSubresourceLayers,
            src_offset: crate::data::Offset3D,
            dst_subresource: crate::data::ImageSubresourceLayers,
            dst_offset: crate::data::Offset3D,
            extent: crate::data::Extent3D,
        }
    }
    impl_aggregate! {
        struct CopyBufferInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::COPY_BUFFER_INFO_2,
            p_next: *const c_void,
            src_buffer: crate::data::Buffer,
            dst_buffer: crate::data::Buffer,
            region_count: u32,
            p_regions: *const crate::data::BufferCopy2,
        }
    }
    impl_aggregate! {
        struct CopyImageInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::COPY_IMAGE_INFO_2,
            p_next: *const c_void,
            src_image: crate::data::Image,
            src_image_layout: crate::data::ImageLayout,
            dst_image: crate::data::Image,
            dst_image_layout: crate::data::ImageLayout,
            region_count: u32,
            p_regions: *const crate::data::ImageCopy2,
        }
    }
    impl_aggregate! {
        struct BlitImageInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::BLIT_IMAGE_INFO_2,
            p_next: *const c_void,
            src_image: crate::data::Image,
            src_image_layout: crate::data::ImageLayout,
            dst_image: crate::data::Image,
            dst_image_layout: crate::data::ImageLayout,
            region_count: u32,
            p_regions: *const crate::data::ImageBlit2,
            filter: crate::data::Filter,
        }
    }
    impl_aggregate! {
        struct CopyBufferToImageInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::COPY_BUFFER_TO_IMAGE_INFO_2,
            p_next: *const c_void,
            src_buffer: crate::data::Buffer,
            dst_image: crate::data::Image,
            dst_image_layout: crate::data::ImageLayout,
            region_count: u32,
            p_regions: *const crate::data::BufferImageCopy2,
        }
    }
    impl_aggregate! {
        struct CopyImageToBufferInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::COPY_IMAGE_TO_BUFFER_INFO_2,
            p_next: *const c_void,
            src_image: crate::data::Image,
            src_image_layout: crate::data::ImageLayout,
            dst_buffer: crate::data::Buffer,
            region_count: u32,
            p_regions: *const crate::data::BufferImageCopy2,
        }
    }
    impl_aggregate! {
        struct ResolveImageInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::RESOLVE_IMAGE_INFO_2,
            p_next: *const c_void,
            src_image: crate::data::Image,
            src_image_layout: crate::data::ImageLayout,
            dst_image: crate::data::Image,
            dst_image_layout: crate::data::ImageLayout,
            region_count: u32,
            p_regions: *const crate::data::ImageResolve2,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
            p_next: *mut c_void,
            shader_image_int_64_atomics: crate::data::Bool32,
            sparse_image_int_64_atomics: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct FragmentShadingRateAttachmentInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            p_next: *const c_void,
            p_fragment_shading_rate_attachment: *const crate::data::AttachmentReference2,
            shading_rate_attachment_texel_size: crate::data::Extent2D,
        }
    }
    impl_aggregate! {
        struct PipelineFragmentShadingRateStateCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
            p_next: *const c_void,
            fragment_size: crate::data::Extent2D,
            combiner_ops: [crate::data::FragmentShadingRateCombinerOpKHR; 2],
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentShadingRateFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
            p_next: *mut c_void,
            pipeline_fragment_shading_rate: crate::data::Bool32,
            primitive_fragment_shading_rate: crate::data::Bool32,
            attachment_fragment_shading_rate: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentShadingRatePropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
            p_next: *mut c_void,
            min_fragment_shading_rate_attachment_texel_size: crate::data::Extent2D,
            max_fragment_shading_rate_attachment_texel_size: crate::data::Extent2D,
            max_fragment_shading_rate_attachment_texel_size_aspect_ratio: u32,
            primitive_fragment_shading_rate_with_multiple_viewports: crate::data::Bool32,
            layered_shading_rate_attachments: crate::data::Bool32,
            fragment_shading_rate_non_trivial_combiner_ops: crate::data::Bool32,
            max_fragment_size: crate::data::Extent2D,
            max_fragment_size_aspect_ratio: u32,
            max_fragment_shading_rate_coverage_samples: u32,
            max_fragment_shading_rate_rasterization_samples: crate::data::SampleCountFlagBits,
            fragment_shading_rate_with_shader_depth_stencil_writes: crate::data::Bool32,
            fragment_shading_rate_with_sample_mask: crate::data::Bool32,
            fragment_shading_rate_with_shader_sample_mask: crate::data::Bool32,
            fragment_shading_rate_with_conservative_rasterization: crate::data::Bool32,
            fragment_shading_rate_with_fragment_shader_interlock: crate::data::Bool32,
            fragment_shading_rate_with_custom_sample_locations: crate::data::Bool32,
            fragment_shading_rate_strict_multiply_combiner: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentShadingRateKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR,
            p_next: *mut c_void,
            sample_counts: crate::data::SampleCountFlags,
            fragment_size: crate::data::Extent2D,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderTerminateInvocationFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
            p_next: *mut c_void,
            shader_terminate_invocation: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV,
            p_next: *mut c_void,
            fragment_shading_rate_enums: crate::data::Bool32,
            supersample_fragment_shading_rates: crate::data::Bool32,
            no_invocation_fragment_shading_rates: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV,
            p_next: *mut c_void,
            max_fragment_shading_rate_invocation_count: crate::data::SampleCountFlagBits,
        }
    }
    impl_aggregate! {
        struct PipelineFragmentShadingRateEnumStateCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV,
            p_next: *const c_void,
            shading_rate_type: crate::data::FragmentShadingRateTypeNV,
            shading_rate: crate::data::FragmentShadingRateNV,
            combiner_ops: [crate::data::FragmentShadingRateCombinerOpKHR; 2],
        }
    }
    impl_aggregate! {
        struct AccelerationStructureBuildSizesInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
            p_next: *const c_void,
            acceleration_structure_size: crate::data::DeviceSize,
            update_scratch_size: crate::data::DeviceSize,
            build_scratch_size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceImage2DViewOf3DFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT,
            p_next: *mut c_void,
            image_2d_view_of_3d: crate::data::Bool32,
            sampler_2d_view_of_3d: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMutableDescriptorTypeFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
            p_next: *mut c_void,
            mutable_descriptor_type: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct MutableDescriptorTypeListEXT {
            descriptor_type_count: u32,
            p_descriptor_types: *const crate::data::DescriptorType,
        }
    }
    impl_aggregate! {
        struct MutableDescriptorTypeCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
            p_next: *const c_void,
            mutable_descriptor_type_list_count: u32,
            p_mutable_descriptor_type_lists: *const crate::data::MutableDescriptorTypeListEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDepthClipControlFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
            p_next: *mut c_void,
            depth_clip_control: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineViewportDepthClipControlCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT,
            p_next: *const c_void,
            negative_one_to_one: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
            p_next: *mut c_void,
            vertex_input_dynamic_state: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceExternalMemoryRDMAFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV,
            p_next: *mut c_void,
            external_memory_rdma: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct VertexInputBindingDescription2EXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT,
            p_next: *mut c_void,
            binding: u32,
            stride: u32,
            input_rate: crate::data::VertexInputRate,
            divisor: u32,
        }
    }
    impl_aggregate! {
        struct VertexInputAttributeDescription2EXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT,
            p_next: *mut c_void,
            location: u32,
            binding: u32,
            format: crate::data::Format,
            offset: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceColorWriteEnableFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
            p_next: *mut c_void,
            color_write_enable: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineColorWriteCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_COLOR_WRITE_CREATE_INFO_EXT,
            p_next: *const c_void,
            attachment_count: u32,
            p_color_write_enables: *const crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct MemoryBarrier2 {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_BARRIER_2,
            p_next: *const c_void,
            src_stage_mask: crate::data::PipelineStageFlags2,
            src_access_mask: crate::data::AccessFlags2,
            dst_stage_mask: crate::data::PipelineStageFlags2,
            dst_access_mask: crate::data::AccessFlags2,
        }
    }
    impl_aggregate! {
        struct ImageMemoryBarrier2 {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_MEMORY_BARRIER_2,
            p_next: *const c_void,
            src_stage_mask: crate::data::PipelineStageFlags2,
            src_access_mask: crate::data::AccessFlags2,
            dst_stage_mask: crate::data::PipelineStageFlags2,
            dst_access_mask: crate::data::AccessFlags2,
            old_layout: crate::data::ImageLayout,
            new_layout: crate::data::ImageLayout,
            src_queue_family_index: u32,
            dst_queue_family_index: u32,
            image: crate::data::Image,
            subresource_range: crate::data::ImageSubresourceRange,
        }
    }
    impl_aggregate! {
        struct BufferMemoryBarrier2 {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_MEMORY_BARRIER_2,
            p_next: *const c_void,
            src_stage_mask: crate::data::PipelineStageFlags2,
            src_access_mask: crate::data::AccessFlags2,
            dst_stage_mask: crate::data::PipelineStageFlags2,
            dst_access_mask: crate::data::AccessFlags2,
            src_queue_family_index: u32,
            dst_queue_family_index: u32,
            buffer: crate::data::Buffer,
            offset: crate::data::DeviceSize,
            size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct DependencyInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::DEPENDENCY_INFO,
            p_next: *const c_void,
            dependency_flags: crate::data::DependencyFlags,
            memory_barrier_count: u32,
            p_memory_barriers: *const crate::data::MemoryBarrier2,
            buffer_memory_barrier_count: u32,
            p_buffer_memory_barriers: *const crate::data::BufferMemoryBarrier2,
            image_memory_barrier_count: u32,
            p_image_memory_barriers: *const crate::data::ImageMemoryBarrier2,
        }
    }
    impl_aggregate! {
        struct SemaphoreSubmitInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::SEMAPHORE_SUBMIT_INFO,
            p_next: *const c_void,
            semaphore: crate::data::Semaphore,
            value: u64,
            stage_mask: crate::data::PipelineStageFlags2,
            device_index: u32,
        }
    }
    impl_aggregate! {
        struct CommandBufferSubmitInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_BUFFER_SUBMIT_INFO,
            p_next: *const c_void,
            command_buffer: crate::data::CommandBuffer,
            device_mask: u32,
        }
    }
    impl_aggregate! {
        struct SubmitInfo2 {
            s_type: crate::data::StructureType = crate::data::StructureType::SUBMIT_INFO_2,
            p_next: *const c_void,
            flags: crate::data::SubmitFlags,
            wait_semaphore_info_count: u32,
            p_wait_semaphore_infos: *const crate::data::SemaphoreSubmitInfo,
            command_buffer_info_count: u32,
            p_command_buffer_infos: *const crate::data::CommandBufferSubmitInfo,
            signal_semaphore_info_count: u32,
            p_signal_semaphore_infos: *const crate::data::SemaphoreSubmitInfo,
        }
    }
    impl_aggregate! {
        struct QueueFamilyCheckpointProperties2NV {
            s_type: crate::data::StructureType = crate::data::StructureType::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV,
            p_next: *mut c_void,
            checkpoint_execution_stage_mask: crate::data::PipelineStageFlags2,
        }
    }
    impl_aggregate! {
        struct CheckpointData2NV {
            s_type: crate::data::StructureType = crate::data::StructureType::CHECKPOINT_DATA_2_NV,
            p_next: *mut c_void,
            stage: crate::data::PipelineStageFlags2,
            p_checkpoint_marker: *mut c_void,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSynchronization2Features {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
            p_next: *mut c_void,
            synchronization_2: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
            p_next: *mut c_void,
            primitives_generated_query: crate::data::Bool32,
            primitives_generated_query_with_rasterizer_discard: crate::data::Bool32,
            primitives_generated_query_with_non_zero_streams: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceLegacyDitheringFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT,
            p_next: *mut c_void,
            legacy_dithering: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT,
            p_next: *mut c_void,
            multisampled_render_to_single_sampled: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct SubpassResolvePerformanceQueryEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT,
            p_next: *mut c_void,
            optimal: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct MultisampledRenderToSingleSampledInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
            p_next: *const c_void,
            multisampled_render_to_single_sampled_enable: crate::data::Bool32,
            rasterization_samples: crate::data::SampleCountFlagBits,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePipelineProtectedAccessFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT,
            p_next: *mut c_void,
            pipeline_protected_access: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct QueueFamilyVideoPropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::QUEUE_FAMILY_VIDEO_PROPERTIES_KHR,
            p_next: *mut c_void,
            video_codec_operations: crate::data::VideoCodecOperationFlagsKHR,
        }
    }
    impl_aggregate! {
        struct QueueFamilyQueryResultStatusPropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR,
            p_next: *mut c_void,
            query_result_status_support: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct VideoProfileListInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_PROFILE_LIST_INFO_KHR,
            p_next: *const c_void,
            profile_count: u32,
            p_profiles: *const crate::data::VideoProfileInfoKHR,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceVideoFormatInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR,
            p_next: *const c_void,
            image_usage: crate::data::ImageUsageFlags,
        }
    }
    impl_aggregate! {
        struct VideoFormatPropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_FORMAT_PROPERTIES_KHR,
            p_next: *mut c_void,
            format: crate::data::Format,
            component_mapping: crate::data::ComponentMapping,
            image_create_flags: crate::data::ImageCreateFlags,
            image_type: crate::data::ImageType,
            image_tiling: crate::data::ImageTiling,
            image_usage_flags: crate::data::ImageUsageFlags,
        }
    }
    impl_aggregate! {
        struct VideoProfileInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_PROFILE_INFO_KHR,
            p_next: *const c_void,
            video_codec_operation: crate::data::VideoCodecOperationFlagBitsKHR,
            chroma_subsampling: crate::data::VideoChromaSubsamplingFlagsKHR,
            luma_bit_depth: crate::data::VideoComponentBitDepthFlagsKHR,
            chroma_bit_depth: crate::data::VideoComponentBitDepthFlagsKHR,
        }
    }
    impl_aggregate! {
        struct VideoCapabilitiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_CAPABILITIES_KHR,
            p_next: *mut c_void,
            flags: crate::data::VideoCapabilityFlagsKHR,
            min_bitstream_buffer_offset_alignment: crate::data::DeviceSize,
            min_bitstream_buffer_size_alignment: crate::data::DeviceSize,
            picture_access_granularity: crate::data::Extent2D,
            min_coded_extent: crate::data::Extent2D,
            max_coded_extent: crate::data::Extent2D,
            max_dpb_slots: u32,
            max_active_reference_pictures: u32,
            std_header_version: crate::data::ExtensionProperties,
        }
    }
    impl_aggregate! {
        struct VideoSessionMemoryRequirementsKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR,
            p_next: *mut c_void,
            memory_bind_index: u32,
            memory_requirements: crate::data::MemoryRequirements,
        }
    }
    impl_aggregate! {
        struct BindVideoSessionMemoryInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::BIND_VIDEO_SESSION_MEMORY_INFO_KHR,
            p_next: *const c_void,
            memory_bind_index: u32,
            memory: crate::data::DeviceMemory,
            memory_offset: crate::data::DeviceSize,
            memory_size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct VideoPictureResourceInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_PICTURE_RESOURCE_INFO_KHR,
            p_next: *const c_void,
            coded_offset: crate::data::Offset2D,
            coded_extent: crate::data::Extent2D,
            base_array_layer: u32,
            image_view_binding: crate::data::ImageView,
        }
    }
    impl_aggregate! {
        struct VideoReferenceSlotInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_REFERENCE_SLOT_INFO_KHR,
            p_next: *const c_void,
            slot_index: i32,
            p_picture_resource: *const crate::data::VideoPictureResourceInfoKHR,
        }
    }
    impl_aggregate! {
        struct VideoDecodeCapabilitiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_DECODE_CAPABILITIES_KHR,
            p_next: *mut c_void,
            flags: crate::data::VideoDecodeCapabilityFlagsKHR,
        }
    }
    impl_aggregate! {
        struct VideoDecodeUsageInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_DECODE_USAGE_INFO_KHR,
            p_next: *const c_void,
            video_usage_hints: crate::data::VideoDecodeUsageFlagsKHR,
        }
    }
    impl_aggregate! {
        struct VideoDecodeInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_DECODE_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::VideoDecodeFlagsKHR,
            src_buffer: crate::data::Buffer,
            src_buffer_offset: crate::data::DeviceSize,
            src_buffer_range: crate::data::DeviceSize,
            dst_picture_resource: crate::data::VideoPictureResourceInfoKHR,
            p_setup_reference_slot: *const crate::data::VideoReferenceSlotInfoKHR,
            reference_slot_count: u32,
            p_reference_slots: *const crate::data::VideoReferenceSlotInfoKHR,
        }
    }
    impl_aggregate! {
        struct VideoSessionCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_SESSION_CREATE_INFO_KHR,
            p_next: *const c_void,
            queue_family_index: u32,
            flags: crate::data::VideoSessionCreateFlagsKHR,
            p_video_profile: *const crate::data::VideoProfileInfoKHR,
            picture_format: crate::data::Format,
            max_coded_extent: crate::data::Extent2D,
            reference_picture_format: crate::data::Format,
            max_dpb_slots: u32,
            max_active_reference_pictures: u32,
            p_std_header_version: *const crate::data::ExtensionProperties,
        }
    }
    impl_aggregate! {
        struct VideoSessionParametersCreateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::VideoSessionParametersCreateFlagsKHR,
            video_session_parameters_template: crate::data::VideoSessionParametersKHR,
            video_session: crate::data::VideoSessionKHR,
        }
    }
    impl_aggregate! {
        struct VideoSessionParametersUpdateInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR,
            p_next: *const c_void,
            update_sequence_count: u32,
        }
    }
    impl_aggregate! {
        struct VideoBeginCodingInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_BEGIN_CODING_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::VideoBeginCodingFlagsKHR,
            video_session: crate::data::VideoSessionKHR,
            video_session_parameters: crate::data::VideoSessionParametersKHR,
            reference_slot_count: u32,
            p_reference_slots: *const crate::data::VideoReferenceSlotInfoKHR,
        }
    }
    impl_aggregate! {
        struct VideoEndCodingInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_END_CODING_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::VideoEndCodingFlagsKHR,
        }
    }
    impl_aggregate! {
        struct VideoCodingControlInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_CODING_CONTROL_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::VideoCodingControlFlagsKHR,
        }
    }
    impl_aggregate! {
        struct VideoEncodeUsageInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_USAGE_INFO_KHR,
            p_next: *const c_void,
            video_usage_hints: crate::data::VideoEncodeUsageFlagsKHR,
            video_content_hints: crate::data::VideoEncodeContentFlagsKHR,
            tuning_mode: crate::data::VideoEncodeTuningModeKHR,
        }
    }
    impl_aggregate! {
        struct VideoEncodeInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::VideoEncodeFlagsKHR,
            quality_level: u32,
            dst_bitstream_buffer: crate::data::Buffer,
            dst_bitstream_buffer_offset: crate::data::DeviceSize,
            dst_bitstream_buffer_max_range: crate::data::DeviceSize,
            src_picture_resource: crate::data::VideoPictureResourceInfoKHR,
            p_setup_reference_slot: *const crate::data::VideoReferenceSlotInfoKHR,
            reference_slot_count: u32,
            p_reference_slots: *const crate::data::VideoReferenceSlotInfoKHR,
            preceding_externally_encoded_bytes: u32,
        }
    }
    impl_aggregate! {
        struct VideoEncodeRateControlInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
            p_next: *const c_void,
            flags: crate::data::VideoEncodeRateControlFlagsKHR,
            rate_control_mode: crate::data::VideoEncodeRateControlModeFlagBitsKHR,
            layer_count: u8,
            p_layer_configs: *const crate::data::VideoEncodeRateControlLayerInfoKHR,
        }
    }
    impl_aggregate! {
        struct VideoEncodeRateControlLayerInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR,
            p_next: *const c_void,
            average_bitrate: u32,
            max_bitrate: u32,
            frame_rate_numerator: u32,
            frame_rate_denominator: u32,
            virtual_buffer_size_in_ms: u32,
            initial_virtual_buffer_size_in_ms: u32,
        }
    }
    impl_aggregate! {
        struct VideoEncodeCapabilitiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_CAPABILITIES_KHR,
            p_next: *mut c_void,
            flags: crate::data::VideoEncodeCapabilityFlagsKHR,
            rate_control_modes: crate::data::VideoEncodeRateControlModeFlagsKHR,
            rate_control_layer_count: u8,
            quality_level_count: u8,
            input_image_data_fill_alignment: crate::data::Extent2D,
        }
    }
    impl_aggregate! {
        struct VideoEncodeH264CapabilitiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_H264_CAPABILITIES_EXT,
            p_next: *mut c_void,
            flags: crate::data::VideoEncodeH264CapabilityFlagsEXT,
            input_mode_flags: crate::data::VideoEncodeH264InputModeFlagsEXT,
            output_mode_flags: crate::data::VideoEncodeH264OutputModeFlagsEXT,
            max_p_picture_l_0_reference_count: u8,
            max_b_picture_l_0_reference_count: u8,
            max_l_1_reference_count: u8,
            motion_vectors_over_pic_boundaries_flag: crate::data::Bool32,
            max_bytes_per_pic_denom: u32,
            max_bits_per_mb_denom: u32,
            log_2_max_mv_length_horizontal: u32,
            log_2_max_mv_length_vertical: u32,
        }
    }
    impl_aggregate! {
        struct VideoEncodeH264EmitPictureParametersInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_INFO_EXT,
            p_next: *const c_void,
            sps_id: u8,
            emit_sps_enable: crate::data::Bool32,
            pps_id_entry_count: u32,
            pps_id_entries: *const u8,
        }
    }
    impl_aggregate! {
        struct VideoEncodeH264RateControlInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT,
            p_next: *const c_void,
            gop_frame_count: u32,
            idr_period: u32,
            consecutive_b_frame_count: u32,
            rate_control_structure: crate::data::VideoEncodeH264RateControlStructureEXT,
            temporal_layer_count: u8,
        }
    }
    impl_aggregate! {
        struct VideoEncodeH264QpEXT {
            qp_i: i32,
            qp_p: i32,
            qp_b: i32,
        }
    }
    impl_aggregate! {
        struct VideoEncodeH264FrameSizeEXT {
            frame_i_size: u32,
            frame_p_size: u32,
            frame_b_size: u32,
        }
    }
    impl_aggregate! {
        struct VideoEncodeH264RateControlLayerInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT,
            p_next: *const c_void,
            temporal_layer_id: u8,
            use_initial_rc_qp: crate::data::Bool32,
            initial_rc_qp: crate::data::VideoEncodeH264QpEXT,
            use_min_qp: crate::data::Bool32,
            min_qp: crate::data::VideoEncodeH264QpEXT,
            use_max_qp: crate::data::Bool32,
            max_qp: crate::data::VideoEncodeH264QpEXT,
            use_max_frame_size: crate::data::Bool32,
            max_frame_size: crate::data::VideoEncodeH264FrameSizeEXT,
        }
    }
    impl_aggregate! {
        struct VideoEncodeH265CapabilitiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_H265_CAPABILITIES_EXT,
            p_next: *mut c_void,
            flags: crate::data::VideoEncodeH265CapabilityFlagsEXT,
            input_mode_flags: crate::data::VideoEncodeH265InputModeFlagsEXT,
            output_mode_flags: crate::data::VideoEncodeH265OutputModeFlagsEXT,
            ctb_sizes: crate::data::VideoEncodeH265CtbSizeFlagsEXT,
            transform_block_sizes: crate::data::VideoEncodeH265TransformBlockSizeFlagsEXT,
            max_p_picture_l_0_reference_count: u8,
            max_b_picture_l_0_reference_count: u8,
            max_l_1_reference_count: u8,
            max_sub_layers_count: u8,
            min_log_2_min_luma_coding_block_size_minus_3: u8,
            max_log_2_min_luma_coding_block_size_minus_3: u8,
            min_log_2_min_luma_transform_block_size_minus_2: u8,
            max_log_2_min_luma_transform_block_size_minus_2: u8,
            min_max_transform_hierarchy_depth_inter: u8,
            max_max_transform_hierarchy_depth_inter: u8,
            min_max_transform_hierarchy_depth_intra: u8,
            max_max_transform_hierarchy_depth_intra: u8,
            max_diff_cu_qp_delta_depth: u8,
            min_max_num_merge_cand: u8,
            max_max_num_merge_cand: u8,
        }
    }
    impl_aggregate! {
        struct VideoEncodeH265EmitPictureParametersInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_INFO_EXT,
            p_next: *const c_void,
            vps_id: u8,
            sps_id: u8,
            emit_vps_enable: crate::data::Bool32,
            emit_sps_enable: crate::data::Bool32,
            pps_id_entry_count: u32,
            pps_id_entries: *const u8,
        }
    }
    impl_aggregate! {
        struct VideoEncodeH265RateControlInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT,
            p_next: *const c_void,
            gop_frame_count: u32,
            idr_period: u32,
            consecutive_b_frame_count: u32,
            rate_control_structure: crate::data::VideoEncodeH265RateControlStructureEXT,
            sub_layer_count: u8,
        }
    }
    impl_aggregate! {
        struct VideoEncodeH265QpEXT {
            qp_i: i32,
            qp_p: i32,
            qp_b: i32,
        }
    }
    impl_aggregate! {
        struct VideoEncodeH265FrameSizeEXT {
            frame_i_size: u32,
            frame_p_size: u32,
            frame_b_size: u32,
        }
    }
    impl_aggregate! {
        struct VideoEncodeH265RateControlLayerInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT,
            p_next: *const c_void,
            temporal_id: u8,
            use_initial_rc_qp: crate::data::Bool32,
            initial_rc_qp: crate::data::VideoEncodeH265QpEXT,
            use_min_qp: crate::data::Bool32,
            min_qp: crate::data::VideoEncodeH265QpEXT,
            use_max_qp: crate::data::Bool32,
            max_qp: crate::data::VideoEncodeH265QpEXT,
            use_max_frame_size: crate::data::Bool32,
            max_frame_size: crate::data::VideoEncodeH265FrameSizeEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceInheritedViewportScissorFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV,
            p_next: *mut c_void,
            inherited_viewport_scissor_2d: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct CommandBufferInheritanceViewportScissorInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV,
            p_next: *const c_void,
            viewport_scissor_2d: crate::data::Bool32,
            viewport_depth_count: u32,
            p_viewport_depths: *const crate::data::Viewport,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
            p_next: *mut c_void,
            ycbcr_2plane_444_formats: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceProvokingVertexFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
            p_next: *mut c_void,
            provoking_vertex_last: crate::data::Bool32,
            transform_feedback_preserves_provoking_vertex: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceProvokingVertexPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT,
            p_next: *mut c_void,
            provoking_vertex_mode_per_pipeline: crate::data::Bool32,
            transform_feedback_preserves_triangle_fan_provoking_vertex: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineRasterizationProvokingVertexStateCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT,
            p_next: *const c_void,
            provoking_vertex_mode: crate::data::ProvokingVertexModeEXT,
        }
    }
    impl_aggregate! {
        struct CuModuleCreateInfoNVX {
            s_type: crate::data::StructureType = crate::data::StructureType::CU_MODULE_CREATE_INFO_NVX,
            p_next: *const c_void,
            data_size: usize,
            p_data: *const c_void,
        }
    }
    impl_aggregate! {
        struct CuFunctionCreateInfoNVX {
            s_type: crate::data::StructureType = crate::data::StructureType::CU_FUNCTION_CREATE_INFO_NVX,
            p_next: *const c_void,
            module: crate::data::CuModuleNVX,
            p_name: *const c_char,
        }
    }
    impl_aggregate! {
        struct CuLaunchInfoNVX {
            s_type: crate::data::StructureType = crate::data::StructureType::CU_LAUNCH_INFO_NVX,
            p_next: *const c_void,
            function: crate::data::CuFunctionNVX,
            grid_dim_x: u32,
            grid_dim_y: u32,
            grid_dim_z: u32,
            block_dim_x: u32,
            block_dim_y: u32,
            block_dim_z: u32,
            shared_mem_bytes: u32,
            param_count: usize,
            p_params: *const *const c_void,
            extra_count: usize,
            p_extras: *const *const c_void,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderIntegerDotProductFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
            p_next: *mut c_void,
            shader_integer_dot_product: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderIntegerDotProductProperties {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
            p_next: *mut c_void,
            integer_dot_product_8_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_8_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_8_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_4x_8_bit_packed_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_4x_8_bit_packed_signed_accelerated: crate::data::Bool32,
            integer_dot_product_4x_8_bit_packed_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_16_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_16_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_16_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_32_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_32_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_32_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_64_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_64_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_64_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_8_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_8_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_8_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_4x_8_bit_packed_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_4x_8_bit_packed_signed_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_4x_8_bit_packed_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_16_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_16_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_16_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_32_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_32_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_32_bit_mixed_signedness_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_64_bit_unsigned_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_64_bit_signed_accelerated: crate::data::Bool32,
            integer_dot_product_accumulating_saturating_64_bit_mixed_signedness_accelerated: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDrmPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DRM_PROPERTIES_EXT,
            p_next: *mut c_void,
            has_primary: crate::data::Bool32,
            has_render: crate::data::Bool32,
            primary_major: i64,
            primary_minor: i64,
            render_major: i64,
            render_minor: i64,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
            p_next: *mut c_void,
            fragment_shader_barycentric: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR,
            p_next: *mut c_void,
            tri_strip_vertex_order_independent_of_provoking_vertex: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceRayTracingMotionBlurFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV,
            p_next: *mut c_void,
            ray_tracing_motion_blur: crate::data::Bool32,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureGeometryMotionTrianglesDataNV {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV,
            p_next: *const c_void,
            vertex_data: crate::data::DeviceOrHostAddressConstKHR,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureMotionInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_MOTION_INFO_NV,
            p_next: *const c_void,
            max_instances: u32,
            flags: crate::data::AccelerationStructureMotionInfoFlagsNV,
        }
    }
    impl_aggregate! {
        struct SRTDataNV {
            sx: c_float,
            a: c_float,
            b: c_float,
            pvx: c_float,
            sy: c_float,
            c: c_float,
            pvy: c_float,
            sz: c_float,
            pvz: c_float,
            qx: c_float,
            qy: c_float,
            qz: c_float,
            qw: c_float,
            tx: c_float,
            ty: c_float,
            tz: c_float,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureSRTMotionInstanceNV {
            transform_t_0: crate::data::SRTDataNV,
            transform_t_1: crate::data::SRTDataNV,
            instance_custom_index: u32,
            mask: u32,
            instance_shader_binding_table_record_offset: u32,
            flags: crate::data::GeometryInstanceFlagsKHR,
            acceleration_structure_reference: u64,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureMatrixMotionInstanceNV {
            transform_t_0: crate::data::TransformMatrixKHR,
            transform_t_1: crate::data::TransformMatrixKHR,
            instance_custom_index: u32,
            mask: u32,
            instance_shader_binding_table_record_offset: u32,
            flags: crate::data::GeometryInstanceFlagsKHR,
            acceleration_structure_reference: u64,
        }
    }
    impl_aggregate! {
        union AccelerationStructureMotionInstanceDataNV {
            static_instance: crate::data::AccelerationStructureInstanceKHR,
            matrix_motion_instance: crate::data::AccelerationStructureMatrixMotionInstanceNV,
            srt_motion_instance: crate::data::AccelerationStructureSRTMotionInstanceNV,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureMotionInstanceNV {
            ty: crate::data::AccelerationStructureMotionInstanceTypeNV,
            flags: crate::data::AccelerationStructureMotionInstanceFlagsNV,
            data: crate::data::AccelerationStructureMotionInstanceDataNV,
        }
    }
    impl_aggregate! {
        struct MemoryGetRemoteAddressInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_GET_REMOTE_ADDRESS_INFO_NV,
            p_next: *const c_void,
            memory: crate::data::DeviceMemory,
            handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        }
    }
    impl_aggregate! {
        struct ImportMemoryBufferCollectionFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA,
            p_next: *const c_void,
            collection: crate::data::BufferCollectionFUCHSIA,
            index: u32,
        }
    }
    impl_aggregate! {
        struct BufferCollectionImageCreateInfoFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
            p_next: *const c_void,
            collection: crate::data::BufferCollectionFUCHSIA,
            index: u32,
        }
    }
    impl_aggregate! {
        struct BufferCollectionBufferCreateInfoFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
            p_next: *const c_void,
            collection: crate::data::BufferCollectionFUCHSIA,
            index: u32,
        }
    }
    impl_aggregate! {
        struct BufferCollectionCreateInfoFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_COLLECTION_CREATE_INFO_FUCHSIA,
            p_next: *const c_void,
            collection_token: zx_handle_t,
        }
    }
    impl_aggregate! {
        struct BufferCollectionPropertiesFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_COLLECTION_PROPERTIES_FUCHSIA,
            p_next: *mut c_void,
            memory_type_bits: u32,
            buffer_count: u32,
            create_info_index: u32,
            sysmem_pixel_format: u64,
            format_features: crate::data::FormatFeatureFlags,
            sysmem_color_space_index: crate::data::SysmemColorSpaceFUCHSIA,
            sampler_ycbcr_conversion_components: crate::data::ComponentMapping,
            suggested_ycbcr_model: crate::data::SamplerYcbcrModelConversion,
            suggested_ycbcr_range: crate::data::SamplerYcbcrRange,
            suggested_x_chroma_offset: crate::data::ChromaLocation,
            suggested_y_chroma_offset: crate::data::ChromaLocation,
        }
    }
    impl_aggregate! {
        struct BufferConstraintsInfoFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_CONSTRAINTS_INFO_FUCHSIA,
            p_next: *const c_void,
            create_info: crate::data::BufferCreateInfo,
            required_format_features: crate::data::FormatFeatureFlags,
            buffer_collection_constraints: crate::data::BufferCollectionConstraintsInfoFUCHSIA,
        }
    }
    impl_aggregate! {
        struct SysmemColorSpaceFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::SYSMEM_COLOR_SPACE_FUCHSIA,
            p_next: *const c_void,
            color_space: u32,
        }
    }
    impl_aggregate! {
        struct ImageFormatConstraintsInfoFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA,
            p_next: *const c_void,
            image_create_info: crate::data::ImageCreateInfo,
            required_format_features: crate::data::FormatFeatureFlags,
            flags: crate::data::ImageFormatConstraintsFlagsFUCHSIA,
            sysmem_pixel_format: u64,
            color_space_count: u32,
            p_color_spaces: *const crate::data::SysmemColorSpaceFUCHSIA,
        }
    }
    impl_aggregate! {
        struct ImageConstraintsInfoFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_CONSTRAINTS_INFO_FUCHSIA,
            p_next: *const c_void,
            format_constraints_count: u32,
            p_format_constraints: *const crate::data::ImageFormatConstraintsInfoFUCHSIA,
            buffer_collection_constraints: crate::data::BufferCollectionConstraintsInfoFUCHSIA,
            flags: crate::data::ImageConstraintsInfoFlagsFUCHSIA,
        }
    }
    impl_aggregate! {
        struct BufferCollectionConstraintsInfoFUCHSIA {
            s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA,
            p_next: *const c_void,
            min_buffer_count: u32,
            max_buffer_count: u32,
            min_buffer_count_for_camping: u32,
            min_buffer_count_for_dedicated_slack: u32,
            min_buffer_count_for_shared_slack: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
            p_next: *mut c_void,
            format_rgba_10x_6_without_y_cb_cr_sampler: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct FormatProperties3 {
            s_type: crate::data::StructureType = crate::data::StructureType::FORMAT_PROPERTIES_3,
            p_next: *mut c_void,
            linear_tiling_features: crate::data::FormatFeatureFlags2,
            optimal_tiling_features: crate::data::FormatFeatureFlags2,
            buffer_features: crate::data::FormatFeatureFlags2,
        }
    }
    impl_aggregate! {
        struct DrmFormatModifierPropertiesList2EXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT,
            p_next: *mut c_void,
            drm_format_modifier_count: u32,
            p_drm_format_modifier_properties: *mut crate::data::DrmFormatModifierProperties2EXT,
        }
    }
    impl_aggregate! {
        struct DrmFormatModifierProperties2EXT {
            drm_format_modifier: u64,
            drm_format_modifier_plane_count: u32,
            drm_format_modifier_tiling_features: crate::data::FormatFeatureFlags2,
        }
    }
    impl_aggregate! {
        struct AndroidHardwareBufferFormatProperties2ANDROID {
            s_type: crate::data::StructureType = crate::data::StructureType::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID,
            p_next: *mut c_void,
            format: crate::data::Format,
            external_format: u64,
            format_features: crate::data::FormatFeatureFlags2,
            sampler_ycbcr_conversion_components: crate::data::ComponentMapping,
            suggested_ycbcr_model: crate::data::SamplerYcbcrModelConversion,
            suggested_ycbcr_range: crate::data::SamplerYcbcrRange,
            suggested_x_chroma_offset: crate::data::ChromaLocation,
            suggested_y_chroma_offset: crate::data::ChromaLocation,
        }
    }
    impl_aggregate! {
        struct PipelineRenderingCreateInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RENDERING_CREATE_INFO,
            p_next: *const c_void,
            view_mask: u32,
            color_attachment_count: u32,
            p_color_attachment_formats: *const crate::data::Format,
            depth_attachment_format: crate::data::Format,
            stencil_attachment_format: crate::data::Format,
        }
    }
    impl_aggregate! {
        struct RenderingInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDERING_INFO,
            p_next: *const c_void,
            flags: crate::data::RenderingFlags,
            render_area: crate::data::Rect2D,
            layer_count: u32,
            view_mask: u32,
            color_attachment_count: u32,
            p_color_attachments: *const crate::data::RenderingAttachmentInfo,
            p_depth_attachment: *const crate::data::RenderingAttachmentInfo,
            p_stencil_attachment: *const crate::data::RenderingAttachmentInfo,
        }
    }
    impl_aggregate! {
        struct RenderingAttachmentInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDERING_ATTACHMENT_INFO,
            p_next: *const c_void,
            image_view: crate::data::ImageView,
            image_layout: crate::data::ImageLayout,
            resolve_mode: crate::data::ResolveModeFlagBits,
            resolve_image_view: crate::data::ImageView,
            resolve_image_layout: crate::data::ImageLayout,
            load_op: crate::data::AttachmentLoadOp,
            store_op: crate::data::AttachmentStoreOp,
            clear_value: crate::data::ClearValue,
        }
    }
    impl_aggregate! {
        struct RenderingFragmentShadingRateAttachmentInfoKHR {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            p_next: *const c_void,
            image_view: crate::data::ImageView,
            image_layout: crate::data::ImageLayout,
            shading_rate_attachment_texel_size: crate::data::Extent2D,
        }
    }
    impl_aggregate! {
        struct RenderingFragmentDensityMapAttachmentInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
            p_next: *const c_void,
            image_view: crate::data::ImageView,
            image_layout: crate::data::ImageLayout,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDynamicRenderingFeatures {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
            p_next: *mut c_void,
            dynamic_rendering: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct CommandBufferInheritanceRenderingInfo {
            s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
            p_next: *const c_void,
            flags: crate::data::RenderingFlags,
            view_mask: u32,
            color_attachment_count: u32,
            p_color_attachment_formats: *const crate::data::Format,
            depth_attachment_format: crate::data::Format,
            stencil_attachment_format: crate::data::Format,
            rasterization_samples: crate::data::SampleCountFlagBits,
        }
    }
    impl_aggregate! {
        struct AttachmentSampleCountInfoAMD {
            s_type: crate::data::StructureType = crate::data::StructureType::ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
            p_next: *const c_void,
            color_attachment_count: u32,
            p_color_attachment_samples: *const crate::data::SampleCountFlagBits,
            depth_stencil_attachment_samples: crate::data::SampleCountFlagBits,
        }
    }
    impl_aggregate! {
        struct MultiviewPerViewAttributesInfoNVX {
            s_type: crate::data::StructureType = crate::data::StructureType::MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
            p_next: *const c_void,
            per_view_attributes: crate::data::Bool32,
            per_view_attributes_position_x_only: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceImageViewMinLodFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
            p_next: *mut c_void,
            min_lod: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct ImageViewMinLodCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT,
            p_next: *const c_void,
            min_lod: c_float,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
            p_next: *mut c_void,
            rasterization_order_color_attachment_access: crate::data::Bool32,
            rasterization_order_depth_attachment_access: crate::data::Bool32,
            rasterization_order_stencil_attachment_access: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceLinearColorAttachmentFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV,
            p_next: *mut c_void,
            linear_color_attachment: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
            p_next: *mut c_void,
            graphics_pipeline_library: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT,
            p_next: *mut c_void,
            graphics_pipeline_library_fast_linking: crate::data::Bool32,
            graphics_pipeline_library_independent_interpolation_decoration: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct GraphicsPipelineLibraryCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT,
            p_next: *mut c_void,
            flags: crate::data::GraphicsPipelineLibraryFlagsEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
            p_next: *mut c_void,
            descriptor_set_host_mapping: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct DescriptorSetBindingReferenceVALVE {
            s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_BINDING_REFERENCE_VALVE,
            p_next: *const c_void,
            descriptor_set_layout: crate::data::DescriptorSetLayout,
            binding: u32,
        }
    }
    impl_aggregate! {
        struct DescriptorSetLayoutHostMappingInfoVALVE {
            s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE,
            p_next: *mut c_void,
            descriptor_offset: usize,
            descriptor_size: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderModuleIdentifierFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT,
            p_next: *mut c_void,
            shader_module_identifier: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderModuleIdentifierPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT,
            p_next: *mut c_void,
            shader_module_identifier_algorithm_uuid: [u8; 16],
        }
    }
    impl_aggregate! {
        struct PipelineShaderStageModuleIdentifierCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
            p_next: *const c_void,
            identifier_size: u32,
            p_identifier: *const u8,
        }
    }
    impl_aggregate! {
        struct ShaderModuleIdentifierEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::SHADER_MODULE_IDENTIFIER_EXT,
            p_next: *mut c_void,
            identifier_size: u32,
            identifier: [u8; 32],
        }
    }
    impl_aggregate! {
        struct ImageCompressionControlEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_COMPRESSION_CONTROL_EXT,
            p_next: *const c_void,
            flags: crate::data::ImageCompressionFlagsEXT,
            compression_control_plane_count: u32,
            p_fixed_rate_flags: *mut crate::data::ImageCompressionFixedRateFlagsEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceImageCompressionControlFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
            p_next: *mut c_void,
            image_compression_control: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct ImageCompressionPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_COMPRESSION_PROPERTIES_EXT,
            p_next: *mut c_void,
            image_compression_flags: crate::data::ImageCompressionFlagsEXT,
            image_compression_fixed_rate_flags: crate::data::ImageCompressionFixedRateFlagsEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
            p_next: *mut c_void,
            image_compression_control_swapchain: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct ImageSubresource2EXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_SUBRESOURCE_2_EXT,
            p_next: *mut c_void,
            image_subresource: crate::data::ImageSubresource,
        }
    }
    impl_aggregate! {
        struct SubresourceLayout2EXT {
            s_type: crate::data::StructureType = crate::data::StructureType::SUBRESOURCE_LAYOUT_2_EXT,
            p_next: *mut c_void,
            subresource_layout: crate::data::SubresourceLayout,
        }
    }
    impl_aggregate! {
        struct RenderPassCreationControlEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_CREATION_CONTROL_EXT,
            p_next: *const c_void,
            disallow_merging: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct RenderPassCreationFeedbackInfoEXT {
            post_merge_subpass_count: u32,
        }
    }
    impl_aggregate! {
        struct RenderPassCreationFeedbackCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
            p_next: *const c_void,
            p_render_pass_feedback: *mut crate::data::RenderPassCreationFeedbackInfoEXT,
        }
    }
    impl_aggregate! {
        struct RenderPassSubpassFeedbackInfoEXT {
            subpass_merge_status: crate::data::SubpassMergeStatusEXT,
            description: [c_char; 256],
            post_merge_index: u32,
        }
    }
    impl_aggregate! {
        struct RenderPassSubpassFeedbackCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT,
            p_next: *const c_void,
            p_subpass_feedback: *mut crate::data::RenderPassSubpassFeedbackInfoEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
            p_next: *mut c_void,
            subpass_merge_feedback: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct MicromapBuildInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::MICROMAP_BUILD_INFO_EXT,
            p_next: *const c_void,
            ty: crate::data::MicromapTypeEXT,
            flags: crate::data::BuildMicromapFlagsEXT,
            mode: crate::data::BuildMicromapModeEXT,
            dst_micromap: crate::data::MicromapEXT,
            usage_counts_count: u32,
            p_usage_counts: *const crate::data::MicromapUsageEXT,
            pp_usage_counts: *const *const crate::data::MicromapUsageEXT,
            data: crate::data::DeviceOrHostAddressConstKHR,
            scratch_data: crate::data::DeviceOrHostAddressKHR,
            triangle_array: crate::data::DeviceOrHostAddressConstKHR,
            triangle_array_stride: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct MicromapCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::MICROMAP_CREATE_INFO_EXT,
            p_next: *const c_void,
            create_flags: crate::data::MicromapCreateFlagsEXT,
            buffer: crate::data::Buffer,
            offset: crate::data::DeviceSize,
            size: crate::data::DeviceSize,
            ty: crate::data::MicromapTypeEXT,
            device_address: crate::data::DeviceAddress,
        }
    }
    impl_aggregate! {
        struct MicromapVersionInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::MICROMAP_VERSION_INFO_EXT,
            p_next: *const c_void,
            p_version_data: *const u8,
        }
    }
    impl_aggregate! {
        struct CopyMicromapInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::COPY_MICROMAP_INFO_EXT,
            p_next: *const c_void,
            src: crate::data::MicromapEXT,
            dst: crate::data::MicromapEXT,
            mode: crate::data::CopyMicromapModeEXT,
        }
    }
    impl_aggregate! {
        struct CopyMicromapToMemoryInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::COPY_MICROMAP_TO_MEMORY_INFO_EXT,
            p_next: *const c_void,
            src: crate::data::MicromapEXT,
            dst: crate::data::DeviceOrHostAddressKHR,
            mode: crate::data::CopyMicromapModeEXT,
        }
    }
    impl_aggregate! {
        struct CopyMemoryToMicromapInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::COPY_MEMORY_TO_MICROMAP_INFO_EXT,
            p_next: *const c_void,
            src: crate::data::DeviceOrHostAddressConstKHR,
            dst: crate::data::MicromapEXT,
            mode: crate::data::CopyMicromapModeEXT,
        }
    }
    impl_aggregate! {
        struct MicromapBuildSizesInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::MICROMAP_BUILD_SIZES_INFO_EXT,
            p_next: *const c_void,
            micromap_size: crate::data::DeviceSize,
            build_scratch_size: crate::data::DeviceSize,
            discardable: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct MicromapUsageEXT {
            count: u32,
            subdivision_level: u32,
            format: u32,
        }
    }
    impl_aggregate! {
        struct MicromapTriangleEXT {
            data_offset: u32,
            subdivision_level: u16,
            format: u16,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceOpacityMicromapFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT,
            p_next: *mut c_void,
            micromap: crate::data::Bool32,
            micromap_capture_replay: crate::data::Bool32,
            micromap_host_commands: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceOpacityMicromapPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT,
            p_next: *mut c_void,
            max_opacity_2_state_subdivision_level: u32,
            max_opacity_4_state_subdivision_level: u32,
        }
    }
    impl_aggregate! {
        struct AccelerationStructureTrianglesOpacityMicromapEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT,
            p_next: *mut c_void,
            index_type: crate::data::IndexType,
            index_buffer: crate::data::DeviceOrHostAddressConstKHR,
            index_stride: crate::data::DeviceSize,
            base_triangle: u32,
            usage_counts_count: u32,
            p_usage_counts: *const crate::data::MicromapUsageEXT,
            pp_usage_counts: *const *const crate::data::MicromapUsageEXT,
            micromap: crate::data::MicromapEXT,
        }
    }
    impl_aggregate! {
        struct PipelinePropertiesIdentifierEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_PROPERTIES_IDENTIFIER_EXT,
            p_next: *mut c_void,
            pipeline_identifier: [u8; 16],
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePipelinePropertiesFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
            p_next: *mut c_void,
            pipeline_properties_identifier: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD,
            p_next: *mut c_void,
            shader_early_and_late_fragment_tests: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct ExportMetalObjectCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            p_next: *const c_void,
            export_object_type: crate::data::ExportMetalObjectTypeFlagBitsEXT,
        }
    }
    impl_aggregate! {
        struct ExportMetalObjectsInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_METAL_OBJECTS_INFO_EXT,
            p_next: *const c_void,
        }
    }
    impl_aggregate! {
        struct ExportMetalDeviceInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_METAL_DEVICE_INFO_EXT,
            p_next: *const c_void,
            mtl_device: MTLDevice_id,
        }
    }
    impl_aggregate! {
        struct ExportMetalCommandQueueInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_METAL_COMMAND_QUEUE_INFO_EXT,
            p_next: *const c_void,
            queue: crate::data::Queue,
            mtl_command_queue: MTLCommandQueue_id,
        }
    }
    impl_aggregate! {
        struct ExportMetalBufferInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_METAL_BUFFER_INFO_EXT,
            p_next: *const c_void,
            memory: crate::data::DeviceMemory,
            mtl_buffer: MTLBuffer_id,
        }
    }
    impl_aggregate! {
        struct ImportMetalBufferInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_METAL_BUFFER_INFO_EXT,
            p_next: *const c_void,
            mtl_buffer: MTLBuffer_id,
        }
    }
    impl_aggregate! {
        struct ExportMetalTextureInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_METAL_TEXTURE_INFO_EXT,
            p_next: *const c_void,
            image: crate::data::Image,
            image_view: crate::data::ImageView,
            buffer_view: crate::data::BufferView,
            plane: crate::data::ImageAspectFlagBits,
            mtl_texture: MTLTexture_id,
        }
    }
    impl_aggregate! {
        struct ImportMetalTextureInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_METAL_TEXTURE_INFO_EXT,
            p_next: *const c_void,
            plane: crate::data::ImageAspectFlagBits,
            mtl_texture: MTLTexture_id,
        }
    }
    impl_aggregate! {
        struct ExportMetalIOSurfaceInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_METAL_IO_SURFACE_INFO_EXT,
            p_next: *const c_void,
            image: crate::data::Image,
            io_surface: IOSurfaceRef,
        }
    }
    impl_aggregate! {
        struct ImportMetalIOSurfaceInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_METAL_IO_SURFACE_INFO_EXT,
            p_next: *const c_void,
            io_surface: IOSurfaceRef,
        }
    }
    impl_aggregate! {
        struct ExportMetalSharedEventInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_METAL_SHARED_EVENT_INFO_EXT,
            p_next: *const c_void,
            semaphore: crate::data::Semaphore,
            event: crate::data::Event,
            mtl_shared_event: MTLSharedEvent_id,
        }
    }
    impl_aggregate! {
        struct ImportMetalSharedEventInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_METAL_SHARED_EVENT_INFO_EXT,
            p_next: *const c_void,
            mtl_shared_event: MTLSharedEvent_id,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
            p_next: *mut c_void,
            non_seamless_cube_map: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePipelineRobustnessFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT,
            p_next: *mut c_void,
            pipeline_robustness: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PipelineRobustnessCreateInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_ROBUSTNESS_CREATE_INFO_EXT,
            p_next: *const c_void,
            storage_buffers: crate::data::PipelineRobustnessBufferBehaviorEXT,
            uniform_buffers: crate::data::PipelineRobustnessBufferBehaviorEXT,
            vertex_inputs: crate::data::PipelineRobustnessBufferBehaviorEXT,
            images: crate::data::PipelineRobustnessImageBehaviorEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDevicePipelineRobustnessPropertiesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT,
            p_next: *mut c_void,
            default_robustness_storage_buffers: crate::data::PipelineRobustnessBufferBehaviorEXT,
            default_robustness_uniform_buffers: crate::data::PipelineRobustnessBufferBehaviorEXT,
            default_robustness_vertex_inputs: crate::data::PipelineRobustnessBufferBehaviorEXT,
            default_robustness_images: crate::data::PipelineRobustnessImageBehaviorEXT,
        }
    }
    impl_aggregate! {
        struct ImageViewSampleWeightCreateInfoQCOM {
            s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM,
            p_next: *const c_void,
            filter_center: crate::data::Offset2D,
            filter_size: crate::data::Extent2D,
            num_phases: u32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceImageProcessingFeaturesQCOM {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM,
            p_next: *mut c_void,
            texture_sample_weighted: crate::data::Bool32,
            texture_box_filter: crate::data::Bool32,
            texture_block_match: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceImageProcessingPropertiesQCOM {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM,
            p_next: *mut c_void,
            max_weight_filter_phases: u32,
            max_weight_filter_dimension: crate::data::Extent2D,
            max_block_match_region: crate::data::Extent2D,
            max_box_filter_block_size: crate::data::Extent2D,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceTilePropertiesFeaturesQCOM {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM,
            p_next: *mut c_void,
            tile_properties: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct TilePropertiesQCOM {
            s_type: crate::data::StructureType = crate::data::StructureType::TILE_PROPERTIES_QCOM,
            p_next: *mut c_void,
            tile_size: crate::data::Extent3D,
            apron_size: crate::data::Extent2D,
            origin: crate::data::Offset2D,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceAmigoProfilingFeaturesSEC {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC,
            p_next: *mut c_void,
            amigo_profiling: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct AmigoProfilingSubmitInfoSEC {
            s_type: crate::data::StructureType = crate::data::StructureType::AMIGO_PROFILING_SUBMIT_INFO_SEC,
            p_next: *const c_void,
            first_draw_timestamp: u64,
            swap_buffer_timestamp: u64,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,
            p_next: *mut c_void,
            attachment_feedback_loop_layout: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceDepthClampZeroOneFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT,
            p_next: *mut c_void,
            depth_clamp_zero_one: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceAddressBindingReportFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT,
            p_next: *mut c_void,
            report_address_binding: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct DeviceAddressBindingCallbackDataEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT,
            p_next: *mut c_void,
            flags: crate::data::DeviceAddressBindingFlagsEXT,
            base_address: crate::data::DeviceAddress,
            size: crate::data::DeviceSize,
            binding_type: crate::data::DeviceAddressBindingTypeEXT,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceOpticalFlowFeaturesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV,
            p_next: *mut c_void,
            optical_flow: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceOpticalFlowPropertiesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV,
            p_next: *mut c_void,
            supported_output_grid_sizes: crate::data::OpticalFlowGridSizeFlagsNV,
            supported_hint_grid_sizes: crate::data::OpticalFlowGridSizeFlagsNV,
            hint_supported: crate::data::Bool32,
            cost_supported: crate::data::Bool32,
            bidirectional_flow_supported: crate::data::Bool32,
            global_flow_supported: crate::data::Bool32,
            min_width: u32,
            min_height: u32,
            max_width: u32,
            max_height: u32,
            max_num_regions_of_interest: u32,
        }
    }
    impl_aggregate! {
        struct OpticalFlowImageFormatInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
            p_next: *const c_void,
            usage: crate::data::OpticalFlowUsageFlagsNV,
        }
    }
    impl_aggregate! {
        struct OpticalFlowImageFormatPropertiesNV {
            s_type: crate::data::StructureType = crate::data::StructureType::OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV,
            p_next: *const c_void,
            format: crate::data::Format,
        }
    }
    impl_aggregate! {
        struct OpticalFlowSessionCreateInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::OPTICAL_FLOW_SESSION_CREATE_INFO_NV,
            p_next: *mut c_void,
            width: u32,
            height: u32,
            image_format: crate::data::Format,
            flow_vector_format: crate::data::Format,
            cost_format: crate::data::Format,
            output_grid_size: crate::data::OpticalFlowGridSizeFlagsNV,
            hint_grid_size: crate::data::OpticalFlowGridSizeFlagsNV,
            performance_level: crate::data::OpticalFlowPerformanceLevelNV,
            flags: crate::data::OpticalFlowSessionCreateFlagsNV,
        }
    }
    impl_aggregate! {
        struct OpticalFlowSessionCreatePrivateDataInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV,
            p_next: *mut c_void,
            id: u32,
            size: u32,
            p_private_data: *const c_void,
        }
    }
    impl_aggregate! {
        struct OpticalFlowExecuteInfoNV {
            s_type: crate::data::StructureType = crate::data::StructureType::OPTICAL_FLOW_EXECUTE_INFO_NV,
            p_next: *mut c_void,
            flags: crate::data::OpticalFlowExecuteFlagsNV,
            region_count: u32,
            p_regions: *const crate::data::Rect2D,
        }
    }
    impl_aggregate! {
        struct PhysicalDeviceFaultFeaturesEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
            p_next: *mut c_void,
            device_fault: crate::data::Bool32,
            device_fault_vendor_binary: crate::data::Bool32,
        }
    }
    impl_aggregate! {
        struct DeviceFaultAddressInfoEXT {
            address_type: crate::data::DeviceFaultAddressTypeEXT,
            reported_address: crate::data::DeviceAddress,
            address_precision: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct DeviceFaultVendorInfoEXT {
            description: [c_char; 256],
            vendor_fault_code: u64,
            vendor_fault_data: u64,
        }
    }
    impl_aggregate! {
        struct DeviceFaultCountsEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_FAULT_COUNTS_EXT,
            p_next: *mut c_void,
            address_info_count: u32,
            vendor_info_count: u32,
            vendor_binary_size: crate::data::DeviceSize,
        }
    }
    impl_aggregate! {
        struct DeviceFaultInfoEXT {
            s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_FAULT_INFO_EXT,
            p_next: *mut c_void,
            description: [c_char; 256],
            p_address_infos: *mut crate::data::DeviceFaultAddressInfoEXT,
            p_vendor_infos: *mut crate::data::DeviceFaultVendorInfoEXT,
            p_vendor_binary_data: *mut c_void,
        }
    }
    impl_aggregate! {
        struct DeviceFaultVendorBinaryHeaderVersionOneEXT {
            header_size: u32,
            header_version: crate::data::DeviceFaultVendorBinaryHeaderVersionEXT,
            vendor_id: u32,
            device_id: u32,
            driver_version: u32,
            pipeline_cache_uuid: [u8; 16],
            application_name_offset: u32,
            application_version: u32,
            engine_name_offset: u32,
        }
    }
}

impl_commands! {
    CreateInstance(
        p_create_info: *const crate::data::InstanceCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_instance: *mut crate::data::Instance,
    ) -> crate::data::Result;
    DestroyInstance(
        instance: crate::data::Instance,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    EnumeratePhysicalDevices(
        instance: crate::data::Instance,
        p_physical_device_count: *mut u32,
        p_physical_devices: *mut crate::data::PhysicalDevice,
    ) -> crate::data::Result;
    GetDeviceProcAddr(
        device: crate::data::Device,
        p_name: *const c_char,
    ) -> crate::pfn::VoidFunction;
    GetInstanceProcAddr(
        instance: crate::data::Instance,
        p_name: *const c_char,
    ) -> crate::pfn::VoidFunction;
    GetPhysicalDeviceProperties(
        physical_device: crate::data::PhysicalDevice,
        p_properties: *mut crate::data::PhysicalDeviceProperties,
    );
    GetPhysicalDeviceQueueFamilyProperties(
        physical_device: crate::data::PhysicalDevice,
        p_queue_family_property_count: *mut u32,
        p_queue_family_properties: *mut crate::data::QueueFamilyProperties,
    );
    GetPhysicalDeviceMemoryProperties(
        physical_device: crate::data::PhysicalDevice,
        p_memory_properties: *mut crate::data::PhysicalDeviceMemoryProperties,
    );
    GetPhysicalDeviceFeatures(
        physical_device: crate::data::PhysicalDevice,
        p_features: *mut crate::data::PhysicalDeviceFeatures,
    );
    GetPhysicalDeviceFormatProperties(
        physical_device: crate::data::PhysicalDevice,
        format: crate::data::Format,
        p_format_properties: *mut crate::data::FormatProperties,
    );
    GetPhysicalDeviceImageFormatProperties(
        physical_device: crate::data::PhysicalDevice,
        format: crate::data::Format,
        ty: crate::data::ImageType,
        tiling: crate::data::ImageTiling,
        usage: crate::data::ImageUsageFlags,
        flags: crate::data::ImageCreateFlags,
        p_image_format_properties: *mut crate::data::ImageFormatProperties,
    ) -> crate::data::Result;
    CreateDevice(
        physical_device: crate::data::PhysicalDevice,
        p_create_info: *const crate::data::DeviceCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_device: *mut crate::data::Device,
    ) -> crate::data::Result;
    DestroyDevice(
        device: crate::data::Device,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    EnumerateInstanceVersion(
        p_api_version: *mut u32,
    ) -> crate::data::Result;
    EnumerateInstanceLayerProperties(
        p_property_count: *mut u32,
        p_properties: *mut crate::data::LayerProperties,
    ) -> crate::data::Result;
    EnumerateInstanceExtensionProperties(
        p_layer_name: *const c_char,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::ExtensionProperties,
    ) -> crate::data::Result;
    EnumerateDeviceLayerProperties(
        physical_device: crate::data::PhysicalDevice,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::LayerProperties,
    ) -> crate::data::Result;
    EnumerateDeviceExtensionProperties(
        physical_device: crate::data::PhysicalDevice,
        p_layer_name: *const c_char,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::ExtensionProperties,
    ) -> crate::data::Result;
    GetDeviceQueue(
        device: crate::data::Device,
        queue_family_index: u32,
        queue_index: u32,
        p_queue: *mut crate::data::Queue,
    );
    QueueSubmit(
        queue: crate::data::Queue,
        submit_count: u32,
        p_submits: *const crate::data::SubmitInfo,
        fence: crate::data::Fence,
    ) -> crate::data::Result;
    QueueWaitIdle(
        queue: crate::data::Queue,
    ) -> crate::data::Result;
    DeviceWaitIdle(
        device: crate::data::Device,
    ) -> crate::data::Result;
    AllocateMemory(
        device: crate::data::Device,
        p_allocate_info: *const crate::data::MemoryAllocateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_memory: *mut crate::data::DeviceMemory,
    ) -> crate::data::Result;
    FreeMemory(
        device: crate::data::Device,
        memory: crate::data::DeviceMemory,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    MapMemory(
        device: crate::data::Device,
        memory: crate::data::DeviceMemory,
        offset: crate::data::DeviceSize,
        size: crate::data::DeviceSize,
        flags: crate::data::MemoryMapFlags,
        pp_data: *mut *mut c_void,
    ) -> crate::data::Result;
    UnmapMemory(
        device: crate::data::Device,
        memory: crate::data::DeviceMemory,
    );
    FlushMappedMemoryRanges(
        device: crate::data::Device,
        memory_range_count: u32,
        p_memory_ranges: *const crate::data::MappedMemoryRange,
    ) -> crate::data::Result;
    InvalidateMappedMemoryRanges(
        device: crate::data::Device,
        memory_range_count: u32,
        p_memory_ranges: *const crate::data::MappedMemoryRange,
    ) -> crate::data::Result;
    GetDeviceMemoryCommitment(
        device: crate::data::Device,
        memory: crate::data::DeviceMemory,
        p_committed_memory_in_bytes: *mut crate::data::DeviceSize,
    );
    GetBufferMemoryRequirements(
        device: crate::data::Device,
        buffer: crate::data::Buffer,
        p_memory_requirements: *mut crate::data::MemoryRequirements,
    );
    BindBufferMemory(
        device: crate::data::Device,
        buffer: crate::data::Buffer,
        memory: crate::data::DeviceMemory,
        memory_offset: crate::data::DeviceSize,
    ) -> crate::data::Result;
    GetImageMemoryRequirements(
        device: crate::data::Device,
        image: crate::data::Image,
        p_memory_requirements: *mut crate::data::MemoryRequirements,
    );
    BindImageMemory(
        device: crate::data::Device,
        image: crate::data::Image,
        memory: crate::data::DeviceMemory,
        memory_offset: crate::data::DeviceSize,
    ) -> crate::data::Result;
    GetImageSparseMemoryRequirements(
        device: crate::data::Device,
        image: crate::data::Image,
        p_sparse_memory_requirement_count: *mut u32,
        p_sparse_memory_requirements: *mut crate::data::SparseImageMemoryRequirements,
    );
    GetPhysicalDeviceSparseImageFormatProperties(
        physical_device: crate::data::PhysicalDevice,
        format: crate::data::Format,
        ty: crate::data::ImageType,
        samples: crate::data::SampleCountFlagBits,
        usage: crate::data::ImageUsageFlags,
        tiling: crate::data::ImageTiling,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::SparseImageFormatProperties,
    );
    QueueBindSparse(
        queue: crate::data::Queue,
        bind_info_count: u32,
        p_bind_info: *const crate::data::BindSparseInfo,
        fence: crate::data::Fence,
    ) -> crate::data::Result;
    CreateFence(
        device: crate::data::Device,
        p_create_info: *const crate::data::FenceCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_fence: *mut crate::data::Fence,
    ) -> crate::data::Result;
    DestroyFence(
        device: crate::data::Device,
        fence: crate::data::Fence,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    ResetFences(
        device: crate::data::Device,
        fence_count: u32,
        p_fences: *const crate::data::Fence,
    ) -> crate::data::Result;
    GetFenceStatus(
        device: crate::data::Device,
        fence: crate::data::Fence,
    ) -> crate::data::Result;
    WaitForFences(
        device: crate::data::Device,
        fence_count: u32,
        p_fences: *const crate::data::Fence,
        wait_all: crate::data::Bool32,
        timeout: u64,
    ) -> crate::data::Result;
    CreateSemaphore(
        device: crate::data::Device,
        p_create_info: *const crate::data::SemaphoreCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_semaphore: *mut crate::data::Semaphore,
    ) -> crate::data::Result;
    DestroySemaphore(
        device: crate::data::Device,
        semaphore: crate::data::Semaphore,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateEvent(
        device: crate::data::Device,
        p_create_info: *const crate::data::EventCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_event: *mut crate::data::Event,
    ) -> crate::data::Result;
    DestroyEvent(
        device: crate::data::Device,
        event: crate::data::Event,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetEventStatus(
        device: crate::data::Device,
        event: crate::data::Event,
    ) -> crate::data::Result;
    SetEvent(
        device: crate::data::Device,
        event: crate::data::Event,
    ) -> crate::data::Result;
    ResetEvent(
        device: crate::data::Device,
        event: crate::data::Event,
    ) -> crate::data::Result;
    CreateQueryPool(
        device: crate::data::Device,
        p_create_info: *const crate::data::QueryPoolCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_query_pool: *mut crate::data::QueryPool,
    ) -> crate::data::Result;
    DestroyQueryPool(
        device: crate::data::Device,
        query_pool: crate::data::QueryPool,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetQueryPoolResults(
        device: crate::data::Device,
        query_pool: crate::data::QueryPool,
        first_query: u32,
        query_count: u32,
        data_size: usize,
        p_data: *mut c_void,
        stride: crate::data::DeviceSize,
        flags: crate::data::QueryResultFlags,
    ) -> crate::data::Result;
    ResetQueryPool(
        device: crate::data::Device,
        query_pool: crate::data::QueryPool,
        first_query: u32,
        query_count: u32,
    );
    CreateBuffer(
        device: crate::data::Device,
        p_create_info: *const crate::data::BufferCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_buffer: *mut crate::data::Buffer,
    ) -> crate::data::Result;
    DestroyBuffer(
        device: crate::data::Device,
        buffer: crate::data::Buffer,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateBufferView(
        device: crate::data::Device,
        p_create_info: *const crate::data::BufferViewCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_view: *mut crate::data::BufferView,
    ) -> crate::data::Result;
    DestroyBufferView(
        device: crate::data::Device,
        buffer_view: crate::data::BufferView,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateImage(
        device: crate::data::Device,
        p_create_info: *const crate::data::ImageCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_image: *mut crate::data::Image,
    ) -> crate::data::Result;
    DestroyImage(
        device: crate::data::Device,
        image: crate::data::Image,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetImageSubresourceLayout(
        device: crate::data::Device,
        image: crate::data::Image,
        p_subresource: *const crate::data::ImageSubresource,
        p_layout: *mut crate::data::SubresourceLayout,
    );
    CreateImageView(
        device: crate::data::Device,
        p_create_info: *const crate::data::ImageViewCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_view: *mut crate::data::ImageView,
    ) -> crate::data::Result;
    DestroyImageView(
        device: crate::data::Device,
        image_view: crate::data::ImageView,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateShaderModule(
        device: crate::data::Device,
        p_create_info: *const crate::data::ShaderModuleCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_shader_module: *mut crate::data::ShaderModule,
    ) -> crate::data::Result;
    DestroyShaderModule(
        device: crate::data::Device,
        shader_module: crate::data::ShaderModule,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreatePipelineCache(
        device: crate::data::Device,
        p_create_info: *const crate::data::PipelineCacheCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_pipeline_cache: *mut crate::data::PipelineCache,
    ) -> crate::data::Result;
    DestroyPipelineCache(
        device: crate::data::Device,
        pipeline_cache: crate::data::PipelineCache,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetPipelineCacheData(
        device: crate::data::Device,
        pipeline_cache: crate::data::PipelineCache,
        p_data_size: *mut usize,
        p_data: *mut c_void,
    ) -> crate::data::Result;
    MergePipelineCaches(
        device: crate::data::Device,
        dst_cache: crate::data::PipelineCache,
        src_cache_count: u32,
        p_src_caches: *const crate::data::PipelineCache,
    ) -> crate::data::Result;
    CreateGraphicsPipelines(
        device: crate::data::Device,
        pipeline_cache: crate::data::PipelineCache,
        create_info_count: u32,
        p_create_infos: *const crate::data::GraphicsPipelineCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_pipelines: *mut crate::data::Pipeline,
    ) -> crate::data::Result;
    CreateComputePipelines(
        device: crate::data::Device,
        pipeline_cache: crate::data::PipelineCache,
        create_info_count: u32,
        p_create_infos: *const crate::data::ComputePipelineCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_pipelines: *mut crate::data::Pipeline,
    ) -> crate::data::Result;
    GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(
        device: crate::data::Device,
        renderpass: crate::data::RenderPass,
        p_max_workgroup_size: *mut crate::data::Extent2D,
    ) -> crate::data::Result;
    DestroyPipeline(
        device: crate::data::Device,
        pipeline: crate::data::Pipeline,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreatePipelineLayout(
        device: crate::data::Device,
        p_create_info: *const crate::data::PipelineLayoutCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_pipeline_layout: *mut crate::data::PipelineLayout,
    ) -> crate::data::Result;
    DestroyPipelineLayout(
        device: crate::data::Device,
        pipeline_layout: crate::data::PipelineLayout,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateSampler(
        device: crate::data::Device,
        p_create_info: *const crate::data::SamplerCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_sampler: *mut crate::data::Sampler,
    ) -> crate::data::Result;
    DestroySampler(
        device: crate::data::Device,
        sampler: crate::data::Sampler,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateDescriptorSetLayout(
        device: crate::data::Device,
        p_create_info: *const crate::data::DescriptorSetLayoutCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_set_layout: *mut crate::data::DescriptorSetLayout,
    ) -> crate::data::Result;
    DestroyDescriptorSetLayout(
        device: crate::data::Device,
        descriptor_set_layout: crate::data::DescriptorSetLayout,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateDescriptorPool(
        device: crate::data::Device,
        p_create_info: *const crate::data::DescriptorPoolCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_descriptor_pool: *mut crate::data::DescriptorPool,
    ) -> crate::data::Result;
    DestroyDescriptorPool(
        device: crate::data::Device,
        descriptor_pool: crate::data::DescriptorPool,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    ResetDescriptorPool(
        device: crate::data::Device,
        descriptor_pool: crate::data::DescriptorPool,
        flags: crate::data::DescriptorPoolResetFlags,
    ) -> crate::data::Result;
    AllocateDescriptorSets(
        device: crate::data::Device,
        p_allocate_info: *const crate::data::DescriptorSetAllocateInfo,
        p_descriptor_sets: *mut crate::data::DescriptorSet,
    ) -> crate::data::Result;
    FreeDescriptorSets(
        device: crate::data::Device,
        descriptor_pool: crate::data::DescriptorPool,
        descriptor_set_count: u32,
        p_descriptor_sets: *const crate::data::DescriptorSet,
    ) -> crate::data::Result;
    UpdateDescriptorSets(
        device: crate::data::Device,
        descriptor_write_count: u32,
        p_descriptor_writes: *const crate::data::WriteDescriptorSet,
        descriptor_copy_count: u32,
        p_descriptor_copies: *const crate::data::CopyDescriptorSet,
    );
    CreateFramebuffer(
        device: crate::data::Device,
        p_create_info: *const crate::data::FramebufferCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_framebuffer: *mut crate::data::Framebuffer,
    ) -> crate::data::Result;
    DestroyFramebuffer(
        device: crate::data::Device,
        framebuffer: crate::data::Framebuffer,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateRenderPass(
        device: crate::data::Device,
        p_create_info: *const crate::data::RenderPassCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_render_pass: *mut crate::data::RenderPass,
    ) -> crate::data::Result;
    DestroyRenderPass(
        device: crate::data::Device,
        render_pass: crate::data::RenderPass,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetRenderAreaGranularity(
        device: crate::data::Device,
        render_pass: crate::data::RenderPass,
        p_granularity: *mut crate::data::Extent2D,
    );
    CreateCommandPool(
        device: crate::data::Device,
        p_create_info: *const crate::data::CommandPoolCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_command_pool: *mut crate::data::CommandPool,
    ) -> crate::data::Result;
    DestroyCommandPool(
        device: crate::data::Device,
        command_pool: crate::data::CommandPool,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    ResetCommandPool(
        device: crate::data::Device,
        command_pool: crate::data::CommandPool,
        flags: crate::data::CommandPoolResetFlags,
    ) -> crate::data::Result;
    AllocateCommandBuffers(
        device: crate::data::Device,
        p_allocate_info: *const crate::data::CommandBufferAllocateInfo,
        p_command_buffers: *mut crate::data::CommandBuffer,
    ) -> crate::data::Result;
    FreeCommandBuffers(
        device: crate::data::Device,
        command_pool: crate::data::CommandPool,
        command_buffer_count: u32,
        p_command_buffers: *const crate::data::CommandBuffer,
    );
    BeginCommandBuffer(
        command_buffer: crate::data::CommandBuffer,
        p_begin_info: *const crate::data::CommandBufferBeginInfo,
    ) -> crate::data::Result;
    EndCommandBuffer(
        command_buffer: crate::data::CommandBuffer,
    ) -> crate::data::Result;
    ResetCommandBuffer(
        command_buffer: crate::data::CommandBuffer,
        flags: crate::data::CommandBufferResetFlags,
    ) -> crate::data::Result;
    CmdBindPipeline(
        command_buffer: crate::data::CommandBuffer,
        pipeline_bind_point: crate::data::PipelineBindPoint,
        pipeline: crate::data::Pipeline,
    );
    CmdSetViewport(
        command_buffer: crate::data::CommandBuffer,
        first_viewport: u32,
        viewport_count: u32,
        p_viewports: *const crate::data::Viewport,
    );
    CmdSetScissor(
        command_buffer: crate::data::CommandBuffer,
        first_scissor: u32,
        scissor_count: u32,
        p_scissors: *const crate::data::Rect2D,
    );
    CmdSetLineWidth(
        command_buffer: crate::data::CommandBuffer,
        line_width: c_float,
    );
    CmdSetDepthBias(
        command_buffer: crate::data::CommandBuffer,
        depth_bias_constant_factor: c_float,
        depth_bias_clamp: c_float,
        depth_bias_slope_factor: c_float,
    );
    CmdSetBlendConstants(
        command_buffer: crate::data::CommandBuffer,
        blend_constants: [c_float; 4],
    );
    CmdSetDepthBounds(
        command_buffer: crate::data::CommandBuffer,
        min_depth_bounds: c_float,
        max_depth_bounds: c_float,
    );
    CmdSetStencilCompareMask(
        command_buffer: crate::data::CommandBuffer,
        face_mask: crate::data::StencilFaceFlags,
        compare_mask: u32,
    );
    CmdSetStencilWriteMask(
        command_buffer: crate::data::CommandBuffer,
        face_mask: crate::data::StencilFaceFlags,
        write_mask: u32,
    );
    CmdSetStencilReference(
        command_buffer: crate::data::CommandBuffer,
        face_mask: crate::data::StencilFaceFlags,
        reference: u32,
    );
    CmdBindDescriptorSets(
        command_buffer: crate::data::CommandBuffer,
        pipeline_bind_point: crate::data::PipelineBindPoint,
        layout: crate::data::PipelineLayout,
        first_set: u32,
        descriptor_set_count: u32,
        p_descriptor_sets: *const crate::data::DescriptorSet,
        dynamic_offset_count: u32,
        p_dynamic_offsets: *const u32,
    );
    CmdBindIndexBuffer(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        index_type: crate::data::IndexType,
    );
    CmdBindVertexBuffers(
        command_buffer: crate::data::CommandBuffer,
        first_binding: u32,
        binding_count: u32,
        p_buffers: *const crate::data::Buffer,
        p_offsets: *const crate::data::DeviceSize,
    );
    CmdDraw(
        command_buffer: crate::data::CommandBuffer,
        vertex_count: u32,
        instance_count: u32,
        first_vertex: u32,
        first_instance: u32,
    );
    CmdDrawIndexed(
        command_buffer: crate::data::CommandBuffer,
        index_count: u32,
        instance_count: u32,
        first_index: u32,
        vertex_offset: i32,
        first_instance: u32,
    );
    CmdDrawMultiEXT(
        command_buffer: crate::data::CommandBuffer,
        draw_count: u32,
        p_vertex_info: *const crate::data::MultiDrawInfoEXT,
        instance_count: u32,
        first_instance: u32,
        stride: u32,
    );
    CmdDrawMultiIndexedEXT(
        command_buffer: crate::data::CommandBuffer,
        draw_count: u32,
        p_index_info: *const crate::data::MultiDrawIndexedInfoEXT,
        instance_count: u32,
        first_instance: u32,
        stride: u32,
        p_vertex_offset: *const i32,
    );
    CmdDrawIndirect(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        draw_count: u32,
        stride: u32,
    );
    CmdDrawIndexedIndirect(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        draw_count: u32,
        stride: u32,
    );
    CmdDispatch(
        command_buffer: crate::data::CommandBuffer,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    );
    CmdDispatchIndirect(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
    );
    CmdSubpassShadingHUAWEI(
        command_buffer: crate::data::CommandBuffer,
    );
    CmdCopyBuffer(
        command_buffer: crate::data::CommandBuffer,
        src_buffer: crate::data::Buffer,
        dst_buffer: crate::data::Buffer,
        region_count: u32,
        p_regions: *const crate::data::BufferCopy,
    );
    CmdCopyImage(
        command_buffer: crate::data::CommandBuffer,
        src_image: crate::data::Image,
        src_image_layout: crate::data::ImageLayout,
        dst_image: crate::data::Image,
        dst_image_layout: crate::data::ImageLayout,
        region_count: u32,
        p_regions: *const crate::data::ImageCopy,
    );
    CmdBlitImage(
        command_buffer: crate::data::CommandBuffer,
        src_image: crate::data::Image,
        src_image_layout: crate::data::ImageLayout,
        dst_image: crate::data::Image,
        dst_image_layout: crate::data::ImageLayout,
        region_count: u32,
        p_regions: *const crate::data::ImageBlit,
        filter: crate::data::Filter,
    );
    CmdCopyBufferToImage(
        command_buffer: crate::data::CommandBuffer,
        src_buffer: crate::data::Buffer,
        dst_image: crate::data::Image,
        dst_image_layout: crate::data::ImageLayout,
        region_count: u32,
        p_regions: *const crate::data::BufferImageCopy,
    );
    CmdCopyImageToBuffer(
        command_buffer: crate::data::CommandBuffer,
        src_image: crate::data::Image,
        src_image_layout: crate::data::ImageLayout,
        dst_buffer: crate::data::Buffer,
        region_count: u32,
        p_regions: *const crate::data::BufferImageCopy,
    );
    CmdUpdateBuffer(
        command_buffer: crate::data::CommandBuffer,
        dst_buffer: crate::data::Buffer,
        dst_offset: crate::data::DeviceSize,
        data_size: crate::data::DeviceSize,
        p_data: *const c_void,
    );
    CmdFillBuffer(
        command_buffer: crate::data::CommandBuffer,
        dst_buffer: crate::data::Buffer,
        dst_offset: crate::data::DeviceSize,
        size: crate::data::DeviceSize,
        data: u32,
    );
    CmdClearColorImage(
        command_buffer: crate::data::CommandBuffer,
        image: crate::data::Image,
        image_layout: crate::data::ImageLayout,
        p_color: *const crate::data::ClearColorValue,
        range_count: u32,
        p_ranges: *const crate::data::ImageSubresourceRange,
    );
    CmdClearDepthStencilImage(
        command_buffer: crate::data::CommandBuffer,
        image: crate::data::Image,
        image_layout: crate::data::ImageLayout,
        p_depth_stencil: *const crate::data::ClearDepthStencilValue,
        range_count: u32,
        p_ranges: *const crate::data::ImageSubresourceRange,
    );
    CmdClearAttachments(
        command_buffer: crate::data::CommandBuffer,
        attachment_count: u32,
        p_attachments: *const crate::data::ClearAttachment,
        rect_count: u32,
        p_rects: *const crate::data::ClearRect,
    );
    CmdResolveImage(
        command_buffer: crate::data::CommandBuffer,
        src_image: crate::data::Image,
        src_image_layout: crate::data::ImageLayout,
        dst_image: crate::data::Image,
        dst_image_layout: crate::data::ImageLayout,
        region_count: u32,
        p_regions: *const crate::data::ImageResolve,
    );
    CmdSetEvent(
        command_buffer: crate::data::CommandBuffer,
        event: crate::data::Event,
        stage_mask: crate::data::PipelineStageFlags,
    );
    CmdResetEvent(
        command_buffer: crate::data::CommandBuffer,
        event: crate::data::Event,
        stage_mask: crate::data::PipelineStageFlags,
    );
    CmdWaitEvents(
        command_buffer: crate::data::CommandBuffer,
        event_count: u32,
        p_events: *const crate::data::Event,
        src_stage_mask: crate::data::PipelineStageFlags,
        dst_stage_mask: crate::data::PipelineStageFlags,
        memory_barrier_count: u32,
        p_memory_barriers: *const crate::data::MemoryBarrier,
        buffer_memory_barrier_count: u32,
        p_buffer_memory_barriers: *const crate::data::BufferMemoryBarrier,
        image_memory_barrier_count: u32,
        p_image_memory_barriers: *const crate::data::ImageMemoryBarrier,
    );
    CmdPipelineBarrier(
        command_buffer: crate::data::CommandBuffer,
        src_stage_mask: crate::data::PipelineStageFlags,
        dst_stage_mask: crate::data::PipelineStageFlags,
        dependency_flags: crate::data::DependencyFlags,
        memory_barrier_count: u32,
        p_memory_barriers: *const crate::data::MemoryBarrier,
        buffer_memory_barrier_count: u32,
        p_buffer_memory_barriers: *const crate::data::BufferMemoryBarrier,
        image_memory_barrier_count: u32,
        p_image_memory_barriers: *const crate::data::ImageMemoryBarrier,
    );
    CmdBeginQuery(
        command_buffer: crate::data::CommandBuffer,
        query_pool: crate::data::QueryPool,
        query: u32,
        flags: crate::data::QueryControlFlags,
    );
    CmdEndQuery(
        command_buffer: crate::data::CommandBuffer,
        query_pool: crate::data::QueryPool,
        query: u32,
    );
    CmdBeginConditionalRenderingEXT(
        command_buffer: crate::data::CommandBuffer,
        p_conditional_rendering_begin: *const crate::data::ConditionalRenderingBeginInfoEXT,
    );
    CmdEndConditionalRenderingEXT(
        command_buffer: crate::data::CommandBuffer,
    );
    CmdResetQueryPool(
        command_buffer: crate::data::CommandBuffer,
        query_pool: crate::data::QueryPool,
        first_query: u32,
        query_count: u32,
    );
    CmdWriteTimestamp(
        command_buffer: crate::data::CommandBuffer,
        pipeline_stage: crate::data::PipelineStageFlagBits,
        query_pool: crate::data::QueryPool,
        query: u32,
    );
    CmdCopyQueryPoolResults(
        command_buffer: crate::data::CommandBuffer,
        query_pool: crate::data::QueryPool,
        first_query: u32,
        query_count: u32,
        dst_buffer: crate::data::Buffer,
        dst_offset: crate::data::DeviceSize,
        stride: crate::data::DeviceSize,
        flags: crate::data::QueryResultFlags,
    );
    CmdPushConstants(
        command_buffer: crate::data::CommandBuffer,
        layout: crate::data::PipelineLayout,
        stage_flags: crate::data::ShaderStageFlags,
        offset: u32,
        size: u32,
        p_values: *const c_void,
    );
    CmdBeginRenderPass(
        command_buffer: crate::data::CommandBuffer,
        p_render_pass_begin: *const crate::data::RenderPassBeginInfo,
        contents: crate::data::SubpassContents,
    );
    CmdNextSubpass(
        command_buffer: crate::data::CommandBuffer,
        contents: crate::data::SubpassContents,
    );
    CmdEndRenderPass(
        command_buffer: crate::data::CommandBuffer,
    );
    CmdExecuteCommands(
        command_buffer: crate::data::CommandBuffer,
        command_buffer_count: u32,
        p_command_buffers: *const crate::data::CommandBuffer,
    );
    CreateAndroidSurfaceKHR(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::AndroidSurfaceCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceDisplayPropertiesKHR(
        physical_device: crate::data::PhysicalDevice,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::DisplayPropertiesKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceDisplayPlanePropertiesKHR(
        physical_device: crate::data::PhysicalDevice,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::DisplayPlanePropertiesKHR,
    ) -> crate::data::Result;
    GetDisplayPlaneSupportedDisplaysKHR(
        physical_device: crate::data::PhysicalDevice,
        plane_index: u32,
        p_display_count: *mut u32,
        p_displays: *mut crate::data::DisplayKHR,
    ) -> crate::data::Result;
    GetDisplayModePropertiesKHR(
        physical_device: crate::data::PhysicalDevice,
        display: crate::data::DisplayKHR,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::DisplayModePropertiesKHR,
    ) -> crate::data::Result;
    CreateDisplayModeKHR(
        physical_device: crate::data::PhysicalDevice,
        display: crate::data::DisplayKHR,
        p_create_info: *const crate::data::DisplayModeCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_mode: *mut crate::data::DisplayModeKHR,
    ) -> crate::data::Result;
    GetDisplayPlaneCapabilitiesKHR(
        physical_device: crate::data::PhysicalDevice,
        mode: crate::data::DisplayModeKHR,
        plane_index: u32,
        p_capabilities: *mut crate::data::DisplayPlaneCapabilitiesKHR,
    ) -> crate::data::Result;
    CreateDisplayPlaneSurfaceKHR(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::DisplaySurfaceCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    CreateSharedSwapchainsKHR(
        device: crate::data::Device,
        swapchain_count: u32,
        p_create_infos: *const crate::data::SwapchainCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_swapchains: *mut crate::data::SwapchainKHR,
    ) -> crate::data::Result;
    DestroySurfaceKHR(
        instance: crate::data::Instance,
        surface: crate::data::SurfaceKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetPhysicalDeviceSurfaceSupportKHR(
        physical_device: crate::data::PhysicalDevice,
        queue_family_index: u32,
        surface: crate::data::SurfaceKHR,
        p_supported: *mut crate::data::Bool32,
    ) -> crate::data::Result;
    GetPhysicalDeviceSurfaceCapabilitiesKHR(
        physical_device: crate::data::PhysicalDevice,
        surface: crate::data::SurfaceKHR,
        p_surface_capabilities: *mut crate::data::SurfaceCapabilitiesKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceSurfaceFormatsKHR(
        physical_device: crate::data::PhysicalDevice,
        surface: crate::data::SurfaceKHR,
        p_surface_format_count: *mut u32,
        p_surface_formats: *mut crate::data::SurfaceFormatKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceSurfacePresentModesKHR(
        physical_device: crate::data::PhysicalDevice,
        surface: crate::data::SurfaceKHR,
        p_present_mode_count: *mut u32,
        p_present_modes: *mut crate::data::PresentModeKHR,
    ) -> crate::data::Result;
    CreateSwapchainKHR(
        device: crate::data::Device,
        p_create_info: *const crate::data::SwapchainCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_swapchain: *mut crate::data::SwapchainKHR,
    ) -> crate::data::Result;
    DestroySwapchainKHR(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetSwapchainImagesKHR(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        p_swapchain_image_count: *mut u32,
        p_swapchain_images: *mut crate::data::Image,
    ) -> crate::data::Result;
    AcquireNextImageKHR(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        timeout: u64,
        semaphore: crate::data::Semaphore,
        fence: crate::data::Fence,
        p_image_index: *mut u32,
    ) -> crate::data::Result;
    QueuePresentKHR(
        queue: crate::data::Queue,
        p_present_info: *const crate::data::PresentInfoKHR,
    ) -> crate::data::Result;
    CreateViSurfaceNN(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::ViSurfaceCreateInfoNN,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    CreateWaylandSurfaceKHR(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::WaylandSurfaceCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceWaylandPresentationSupportKHR(
        physical_device: crate::data::PhysicalDevice,
        queue_family_index: u32,
        display: *mut wl_display,
    ) -> crate::data::Bool32;
    CreateWin32SurfaceKHR(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::Win32SurfaceCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceWin32PresentationSupportKHR(
        physical_device: crate::data::PhysicalDevice,
        queue_family_index: u32,
    ) -> crate::data::Bool32;
    CreateXlibSurfaceKHR(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::XlibSurfaceCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceXlibPresentationSupportKHR(
        physical_device: crate::data::PhysicalDevice,
        queue_family_index: u32,
        dpy: *mut Display,
        visual_id: VisualID,
    ) -> crate::data::Bool32;
    CreateXcbSurfaceKHR(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::XcbSurfaceCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceXcbPresentationSupportKHR(
        physical_device: crate::data::PhysicalDevice,
        queue_family_index: u32,
        connection: *mut xcb_connection_t,
        visual_id: xcb_visualid_t,
    ) -> crate::data::Bool32;
    CreateDirectFBSurfaceEXT(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::DirectFBSurfaceCreateInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceDirectFBPresentationSupportEXT(
        physical_device: crate::data::PhysicalDevice,
        queue_family_index: u32,
        dfb: *mut IDirectFB,
    ) -> crate::data::Bool32;
    CreateImagePipeSurfaceFUCHSIA(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::ImagePipeSurfaceCreateInfoFUCHSIA,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    CreateStreamDescriptorSurfaceGGP(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::StreamDescriptorSurfaceCreateInfoGGP,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    CreateScreenSurfaceQNX(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::ScreenSurfaceCreateInfoQNX,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceScreenPresentationSupportQNX(
        physical_device: crate::data::PhysicalDevice,
        queue_family_index: u32,
        window: *mut _screen_window,
    ) -> crate::data::Bool32;
    CreateDebugReportCallbackEXT(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::DebugReportCallbackCreateInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_callback: *mut crate::data::DebugReportCallbackEXT,
    ) -> crate::data::Result;
    DestroyDebugReportCallbackEXT(
        instance: crate::data::Instance,
        callback: crate::data::DebugReportCallbackEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    DebugReportMessageEXT(
        instance: crate::data::Instance,
        flags: crate::data::DebugReportFlagsEXT,
        object_type: crate::data::DebugReportObjectTypeEXT,
        object: u64,
        location: usize,
        message_code: i32,
        p_layer_prefix: *const c_char,
        p_message: *const c_char,
    );
    DebugMarkerSetObjectNameEXT(
        device: crate::data::Device,
        p_name_info: *const crate::data::DebugMarkerObjectNameInfoEXT,
    ) -> crate::data::Result;
    DebugMarkerSetObjectTagEXT(
        device: crate::data::Device,
        p_tag_info: *const crate::data::DebugMarkerObjectTagInfoEXT,
    ) -> crate::data::Result;
    CmdDebugMarkerBeginEXT(
        command_buffer: crate::data::CommandBuffer,
        p_marker_info: *const crate::data::DebugMarkerMarkerInfoEXT,
    );
    CmdDebugMarkerEndEXT(
        command_buffer: crate::data::CommandBuffer,
    );
    CmdDebugMarkerInsertEXT(
        command_buffer: crate::data::CommandBuffer,
        p_marker_info: *const crate::data::DebugMarkerMarkerInfoEXT,
    );
    GetPhysicalDeviceExternalImageFormatPropertiesNV(
        physical_device: crate::data::PhysicalDevice,
        format: crate::data::Format,
        ty: crate::data::ImageType,
        tiling: crate::data::ImageTiling,
        usage: crate::data::ImageUsageFlags,
        flags: crate::data::ImageCreateFlags,
        external_handle_type: crate::data::ExternalMemoryHandleTypeFlagsNV,
        p_external_image_format_properties: *mut crate::data::ExternalImageFormatPropertiesNV,
    ) -> crate::data::Result;
    GetMemoryWin32HandleNV(
        device: crate::data::Device,
        memory: crate::data::DeviceMemory,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagsNV,
        p_handle: *mut HANDLE,
    ) -> crate::data::Result;
    CmdExecuteGeneratedCommandsNV(
        command_buffer: crate::data::CommandBuffer,
        is_preprocessed: crate::data::Bool32,
        p_generated_commands_info: *const crate::data::GeneratedCommandsInfoNV,
    );
    CmdPreprocessGeneratedCommandsNV(
        command_buffer: crate::data::CommandBuffer,
        p_generated_commands_info: *const crate::data::GeneratedCommandsInfoNV,
    );
    CmdBindPipelineShaderGroupNV(
        command_buffer: crate::data::CommandBuffer,
        pipeline_bind_point: crate::data::PipelineBindPoint,
        pipeline: crate::data::Pipeline,
        group_index: u32,
    );
    GetGeneratedCommandsMemoryRequirementsNV(
        device: crate::data::Device,
        p_info: *const crate::data::GeneratedCommandsMemoryRequirementsInfoNV,
        p_memory_requirements: *mut crate::data::MemoryRequirements2,
    );
    CreateIndirectCommandsLayoutNV(
        device: crate::data::Device,
        p_create_info: *const crate::data::IndirectCommandsLayoutCreateInfoNV,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_indirect_commands_layout: *mut crate::data::IndirectCommandsLayoutNV,
    ) -> crate::data::Result;
    DestroyIndirectCommandsLayoutNV(
        device: crate::data::Device,
        indirect_commands_layout: crate::data::IndirectCommandsLayoutNV,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetPhysicalDeviceFeatures2(
        physical_device: crate::data::PhysicalDevice,
        p_features: *mut crate::data::PhysicalDeviceFeatures2,
    );
    GetPhysicalDeviceProperties2(
        physical_device: crate::data::PhysicalDevice,
        p_properties: *mut crate::data::PhysicalDeviceProperties2,
    );
    GetPhysicalDeviceFormatProperties2(
        physical_device: crate::data::PhysicalDevice,
        format: crate::data::Format,
        p_format_properties: *mut crate::data::FormatProperties2,
    );
    GetPhysicalDeviceImageFormatProperties2(
        physical_device: crate::data::PhysicalDevice,
        p_image_format_info: *const crate::data::PhysicalDeviceImageFormatInfo2,
        p_image_format_properties: *mut crate::data::ImageFormatProperties2,
    ) -> crate::data::Result;
    GetPhysicalDeviceQueueFamilyProperties2(
        physical_device: crate::data::PhysicalDevice,
        p_queue_family_property_count: *mut u32,
        p_queue_family_properties: *mut crate::data::QueueFamilyProperties2,
    );
    GetPhysicalDeviceMemoryProperties2(
        physical_device: crate::data::PhysicalDevice,
        p_memory_properties: *mut crate::data::PhysicalDeviceMemoryProperties2,
    );
    GetPhysicalDeviceSparseImageFormatProperties2(
        physical_device: crate::data::PhysicalDevice,
        p_format_info: *const crate::data::PhysicalDeviceSparseImageFormatInfo2,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::SparseImageFormatProperties2,
    );
    CmdPushDescriptorSetKHR(
        command_buffer: crate::data::CommandBuffer,
        pipeline_bind_point: crate::data::PipelineBindPoint,
        layout: crate::data::PipelineLayout,
        set: u32,
        descriptor_write_count: u32,
        p_descriptor_writes: *const crate::data::WriteDescriptorSet,
    );
    TrimCommandPool(
        device: crate::data::Device,
        command_pool: crate::data::CommandPool,
        flags: crate::data::CommandPoolTrimFlags,
    );
    GetPhysicalDeviceExternalBufferProperties(
        physical_device: crate::data::PhysicalDevice,
        p_external_buffer_info: *const crate::data::PhysicalDeviceExternalBufferInfo,
        p_external_buffer_properties: *mut crate::data::ExternalBufferProperties,
    );
    GetMemoryWin32HandleKHR(
        device: crate::data::Device,
        p_get_win_32_handle_info: *const crate::data::MemoryGetWin32HandleInfoKHR,
        p_handle: *mut HANDLE,
    ) -> crate::data::Result;
    GetMemoryWin32HandlePropertiesKHR(
        device: crate::data::Device,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        handle: HANDLE,
        p_memory_win_32_handle_properties: *mut crate::data::MemoryWin32HandlePropertiesKHR,
    ) -> crate::data::Result;
    GetMemoryFdKHR(
        device: crate::data::Device,
        p_get_fd_info: *const crate::data::MemoryGetFdInfoKHR,
        p_fd: *mut c_int,
    ) -> crate::data::Result;
    GetMemoryFdPropertiesKHR(
        device: crate::data::Device,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        fd: c_int,
        p_memory_fd_properties: *mut crate::data::MemoryFdPropertiesKHR,
    ) -> crate::data::Result;
    GetMemoryZirconHandleFUCHSIA(
        device: crate::data::Device,
        p_get_zircon_handle_info: *const crate::data::MemoryGetZirconHandleInfoFUCHSIA,
        p_zircon_handle: *mut zx_handle_t,
    ) -> crate::data::Result;
    GetMemoryZirconHandlePropertiesFUCHSIA(
        device: crate::data::Device,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        zircon_handle: zx_handle_t,
        p_memory_zircon_handle_properties: *mut crate::data::MemoryZirconHandlePropertiesFUCHSIA,
    ) -> crate::data::Result;
    GetMemoryRemoteAddressNV(
        device: crate::data::Device,
        p_memory_get_remote_address_info: *const crate::data::MemoryGetRemoteAddressInfoNV,
        p_address: *mut crate::data::RemoteAddressNV,
    ) -> crate::data::Result;
    GetPhysicalDeviceExternalSemaphoreProperties(
        physical_device: crate::data::PhysicalDevice,
        p_external_semaphore_info: *const crate::data::PhysicalDeviceExternalSemaphoreInfo,
        p_external_semaphore_properties: *mut crate::data::ExternalSemaphoreProperties,
    );
    GetSemaphoreWin32HandleKHR(
        device: crate::data::Device,
        p_get_win_32_handle_info: *const crate::data::SemaphoreGetWin32HandleInfoKHR,
        p_handle: *mut HANDLE,
    ) -> crate::data::Result;
    ImportSemaphoreWin32HandleKHR(
        device: crate::data::Device,
        p_import_semaphore_win_32_handle_info: *const crate::data::ImportSemaphoreWin32HandleInfoKHR,
    ) -> crate::data::Result;
    GetSemaphoreFdKHR(
        device: crate::data::Device,
        p_get_fd_info: *const crate::data::SemaphoreGetFdInfoKHR,
        p_fd: *mut c_int,
    ) -> crate::data::Result;
    ImportSemaphoreFdKHR(
        device: crate::data::Device,
        p_import_semaphore_fd_info: *const crate::data::ImportSemaphoreFdInfoKHR,
    ) -> crate::data::Result;
    GetSemaphoreZirconHandleFUCHSIA(
        device: crate::data::Device,
        p_get_zircon_handle_info: *const crate::data::SemaphoreGetZirconHandleInfoFUCHSIA,
        p_zircon_handle: *mut zx_handle_t,
    ) -> crate::data::Result;
    ImportSemaphoreZirconHandleFUCHSIA(
        device: crate::data::Device,
        p_import_semaphore_zircon_handle_info: *const crate::data::ImportSemaphoreZirconHandleInfoFUCHSIA,
    ) -> crate::data::Result;
    GetPhysicalDeviceExternalFenceProperties(
        physical_device: crate::data::PhysicalDevice,
        p_external_fence_info: *const crate::data::PhysicalDeviceExternalFenceInfo,
        p_external_fence_properties: *mut crate::data::ExternalFenceProperties,
    );
    GetFenceWin32HandleKHR(
        device: crate::data::Device,
        p_get_win_32_handle_info: *const crate::data::FenceGetWin32HandleInfoKHR,
        p_handle: *mut HANDLE,
    ) -> crate::data::Result;
    ImportFenceWin32HandleKHR(
        device: crate::data::Device,
        p_import_fence_win_32_handle_info: *const crate::data::ImportFenceWin32HandleInfoKHR,
    ) -> crate::data::Result;
    GetFenceFdKHR(
        device: crate::data::Device,
        p_get_fd_info: *const crate::data::FenceGetFdInfoKHR,
        p_fd: *mut c_int,
    ) -> crate::data::Result;
    ImportFenceFdKHR(
        device: crate::data::Device,
        p_import_fence_fd_info: *const crate::data::ImportFenceFdInfoKHR,
    ) -> crate::data::Result;
    ReleaseDisplayEXT(
        physical_device: crate::data::PhysicalDevice,
        display: crate::data::DisplayKHR,
    ) -> crate::data::Result;
    AcquireXlibDisplayEXT(
        physical_device: crate::data::PhysicalDevice,
        dpy: *mut Display,
        display: crate::data::DisplayKHR,
    ) -> crate::data::Result;
    GetRandROutputDisplayEXT(
        physical_device: crate::data::PhysicalDevice,
        dpy: *mut Display,
        rr_output: RROutput,
        p_display: *mut crate::data::DisplayKHR,
    ) -> crate::data::Result;
    AcquireWinrtDisplayNV(
        physical_device: crate::data::PhysicalDevice,
        display: crate::data::DisplayKHR,
    ) -> crate::data::Result;
    GetWinrtDisplayNV(
        physical_device: crate::data::PhysicalDevice,
        device_relative_id: u32,
        p_display: *mut crate::data::DisplayKHR,
    ) -> crate::data::Result;
    DisplayPowerControlEXT(
        device: crate::data::Device,
        display: crate::data::DisplayKHR,
        p_display_power_info: *const crate::data::DisplayPowerInfoEXT,
    ) -> crate::data::Result;
    RegisterDeviceEventEXT(
        device: crate::data::Device,
        p_device_event_info: *const crate::data::DeviceEventInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_fence: *mut crate::data::Fence,
    ) -> crate::data::Result;
    RegisterDisplayEventEXT(
        device: crate::data::Device,
        display: crate::data::DisplayKHR,
        p_display_event_info: *const crate::data::DisplayEventInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_fence: *mut crate::data::Fence,
    ) -> crate::data::Result;
    GetSwapchainCounterEXT(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        counter: crate::data::SurfaceCounterFlagBitsEXT,
        p_counter_value: *mut u64,
    ) -> crate::data::Result;
    GetPhysicalDeviceSurfaceCapabilities2EXT(
        physical_device: crate::data::PhysicalDevice,
        surface: crate::data::SurfaceKHR,
        p_surface_capabilities: *mut crate::data::SurfaceCapabilities2EXT,
    ) -> crate::data::Result;
    EnumeratePhysicalDeviceGroups(
        instance: crate::data::Instance,
        p_physical_device_group_count: *mut u32,
        p_physical_device_group_properties: *mut crate::data::PhysicalDeviceGroupProperties,
    ) -> crate::data::Result;
    GetDeviceGroupPeerMemoryFeatures(
        device: crate::data::Device,
        heap_index: u32,
        local_device_index: u32,
        remote_device_index: u32,
        p_peer_memory_features: *mut crate::data::PeerMemoryFeatureFlags,
    );
    BindBufferMemory2(
        device: crate::data::Device,
        bind_info_count: u32,
        p_bind_infos: *const crate::data::BindBufferMemoryInfo,
    ) -> crate::data::Result;
    BindImageMemory2(
        device: crate::data::Device,
        bind_info_count: u32,
        p_bind_infos: *const crate::data::BindImageMemoryInfo,
    ) -> crate::data::Result;
    CmdSetDeviceMask(
        command_buffer: crate::data::CommandBuffer,
        device_mask: u32,
    );
    GetDeviceGroupPresentCapabilitiesKHR(
        device: crate::data::Device,
        p_device_group_present_capabilities: *mut crate::data::DeviceGroupPresentCapabilitiesKHR,
    ) -> crate::data::Result;
    GetDeviceGroupSurfacePresentModesKHR(
        device: crate::data::Device,
        surface: crate::data::SurfaceKHR,
        p_modes: *mut crate::data::DeviceGroupPresentModeFlagsKHR,
    ) -> crate::data::Result;
    AcquireNextImage2KHR(
        device: crate::data::Device,
        p_acquire_info: *const crate::data::AcquireNextImageInfoKHR,
        p_image_index: *mut u32,
    ) -> crate::data::Result;
    CmdDispatchBase(
        command_buffer: crate::data::CommandBuffer,
        base_group_x: u32,
        base_group_y: u32,
        base_group_z: u32,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    );
    GetPhysicalDevicePresentRectanglesKHR(
        physical_device: crate::data::PhysicalDevice,
        surface: crate::data::SurfaceKHR,
        p_rect_count: *mut u32,
        p_rects: *mut crate::data::Rect2D,
    ) -> crate::data::Result;
    CreateDescriptorUpdateTemplate(
        device: crate::data::Device,
        p_create_info: *const crate::data::DescriptorUpdateTemplateCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_descriptor_update_template: *mut crate::data::DescriptorUpdateTemplate,
    ) -> crate::data::Result;
    DestroyDescriptorUpdateTemplate(
        device: crate::data::Device,
        descriptor_update_template: crate::data::DescriptorUpdateTemplate,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    UpdateDescriptorSetWithTemplate(
        device: crate::data::Device,
        descriptor_set: crate::data::DescriptorSet,
        descriptor_update_template: crate::data::DescriptorUpdateTemplate,
        p_data: *const c_void,
    );
    CmdPushDescriptorSetWithTemplateKHR(
        command_buffer: crate::data::CommandBuffer,
        descriptor_update_template: crate::data::DescriptorUpdateTemplate,
        layout: crate::data::PipelineLayout,
        set: u32,
        p_data: *const c_void,
    );
    SetHdrMetadataEXT(
        device: crate::data::Device,
        swapchain_count: u32,
        p_swapchains: *const crate::data::SwapchainKHR,
        p_metadata: *const crate::data::HdrMetadataEXT,
    );
    GetSwapchainStatusKHR(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
    ) -> crate::data::Result;
    GetRefreshCycleDurationGOOGLE(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        p_display_timing_properties: *mut crate::data::RefreshCycleDurationGOOGLE,
    ) -> crate::data::Result;
    GetPastPresentationTimingGOOGLE(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        p_presentation_timing_count: *mut u32,
        p_presentation_timings: *mut crate::data::PastPresentationTimingGOOGLE,
    ) -> crate::data::Result;
    CreateIOSSurfaceMVK(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::IOSSurfaceCreateInfoMVK,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    CreateMacOSSurfaceMVK(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::MacOSSurfaceCreateInfoMVK,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    CreateMetalSurfaceEXT(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::MetalSurfaceCreateInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    CmdSetViewportWScalingNV(
        command_buffer: crate::data::CommandBuffer,
        first_viewport: u32,
        viewport_count: u32,
        p_viewport_w_scalings: *const crate::data::ViewportWScalingNV,
    );
    CmdSetDiscardRectangleEXT(
        command_buffer: crate::data::CommandBuffer,
        first_discard_rectangle: u32,
        discard_rectangle_count: u32,
        p_discard_rectangles: *const crate::data::Rect2D,
    );
    CmdSetSampleLocationsEXT(
        command_buffer: crate::data::CommandBuffer,
        p_sample_locations_info: *const crate::data::SampleLocationsInfoEXT,
    );
    GetPhysicalDeviceMultisamplePropertiesEXT(
        physical_device: crate::data::PhysicalDevice,
        samples: crate::data::SampleCountFlagBits,
        p_multisample_properties: *mut crate::data::MultisamplePropertiesEXT,
    );
    GetPhysicalDeviceSurfaceCapabilities2KHR(
        physical_device: crate::data::PhysicalDevice,
        p_surface_info: *const crate::data::PhysicalDeviceSurfaceInfo2KHR,
        p_surface_capabilities: *mut crate::data::SurfaceCapabilities2KHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceSurfaceFormats2KHR(
        physical_device: crate::data::PhysicalDevice,
        p_surface_info: *const crate::data::PhysicalDeviceSurfaceInfo2KHR,
        p_surface_format_count: *mut u32,
        p_surface_formats: *mut crate::data::SurfaceFormat2KHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceDisplayProperties2KHR(
        physical_device: crate::data::PhysicalDevice,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::DisplayProperties2KHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceDisplayPlaneProperties2KHR(
        physical_device: crate::data::PhysicalDevice,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::DisplayPlaneProperties2KHR,
    ) -> crate::data::Result;
    GetDisplayModeProperties2KHR(
        physical_device: crate::data::PhysicalDevice,
        display: crate::data::DisplayKHR,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::DisplayModeProperties2KHR,
    ) -> crate::data::Result;
    GetDisplayPlaneCapabilities2KHR(
        physical_device: crate::data::PhysicalDevice,
        p_display_plane_info: *const crate::data::DisplayPlaneInfo2KHR,
        p_capabilities: *mut crate::data::DisplayPlaneCapabilities2KHR,
    ) -> crate::data::Result;
    GetBufferMemoryRequirements2(
        device: crate::data::Device,
        p_info: *const crate::data::BufferMemoryRequirementsInfo2,
        p_memory_requirements: *mut crate::data::MemoryRequirements2,
    );
    GetImageMemoryRequirements2(
        device: crate::data::Device,
        p_info: *const crate::data::ImageMemoryRequirementsInfo2,
        p_memory_requirements: *mut crate::data::MemoryRequirements2,
    );
    GetImageSparseMemoryRequirements2(
        device: crate::data::Device,
        p_info: *const crate::data::ImageSparseMemoryRequirementsInfo2,
        p_sparse_memory_requirement_count: *mut u32,
        p_sparse_memory_requirements: *mut crate::data::SparseImageMemoryRequirements2,
    );
    GetDeviceBufferMemoryRequirements(
        device: crate::data::Device,
        p_info: *const crate::data::DeviceBufferMemoryRequirements,
        p_memory_requirements: *mut crate::data::MemoryRequirements2,
    );
    GetDeviceImageMemoryRequirements(
        device: crate::data::Device,
        p_info: *const crate::data::DeviceImageMemoryRequirements,
        p_memory_requirements: *mut crate::data::MemoryRequirements2,
    );
    GetDeviceImageSparseMemoryRequirements(
        device: crate::data::Device,
        p_info: *const crate::data::DeviceImageMemoryRequirements,
        p_sparse_memory_requirement_count: *mut u32,
        p_sparse_memory_requirements: *mut crate::data::SparseImageMemoryRequirements2,
    );
    CreateSamplerYcbcrConversion(
        device: crate::data::Device,
        p_create_info: *const crate::data::SamplerYcbcrConversionCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_ycbcr_conversion: *mut crate::data::SamplerYcbcrConversion,
    ) -> crate::data::Result;
    DestroySamplerYcbcrConversion(
        device: crate::data::Device,
        ycbcr_conversion: crate::data::SamplerYcbcrConversion,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetDeviceQueue2(
        device: crate::data::Device,
        p_queue_info: *const crate::data::DeviceQueueInfo2,
        p_queue: *mut crate::data::Queue,
    );
    CreateValidationCacheEXT(
        device: crate::data::Device,
        p_create_info: *const crate::data::ValidationCacheCreateInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_validation_cache: *mut crate::data::ValidationCacheEXT,
    ) -> crate::data::Result;
    DestroyValidationCacheEXT(
        device: crate::data::Device,
        validation_cache: crate::data::ValidationCacheEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetValidationCacheDataEXT(
        device: crate::data::Device,
        validation_cache: crate::data::ValidationCacheEXT,
        p_data_size: *mut usize,
        p_data: *mut c_void,
    ) -> crate::data::Result;
    MergeValidationCachesEXT(
        device: crate::data::Device,
        dst_cache: crate::data::ValidationCacheEXT,
        src_cache_count: u32,
        p_src_caches: *const crate::data::ValidationCacheEXT,
    ) -> crate::data::Result;
    GetDescriptorSetLayoutSupport(
        device: crate::data::Device,
        p_create_info: *const crate::data::DescriptorSetLayoutCreateInfo,
        p_support: *mut crate::data::DescriptorSetLayoutSupport,
    );
    GetSwapchainGrallocUsageANDROID(
        device: crate::data::Device,
        format: crate::data::Format,
        image_usage: crate::data::ImageUsageFlags,
        gralloc_usage: *mut c_int,
    ) -> crate::data::Result;
    GetSwapchainGrallocUsage2ANDROID(
        device: crate::data::Device,
        format: crate::data::Format,
        image_usage: crate::data::ImageUsageFlags,
        swapchain_image_usage: crate::data::SwapchainImageUsageFlagsANDROID,
        gralloc_consumer_usage: *mut u64,
        gralloc_producer_usage: *mut u64,
    ) -> crate::data::Result;
    AcquireImageANDROID(
        device: crate::data::Device,
        image: crate::data::Image,
        native_fence_fd: c_int,
        semaphore: crate::data::Semaphore,
        fence: crate::data::Fence,
    ) -> crate::data::Result;
    QueueSignalReleaseImageANDROID(
        queue: crate::data::Queue,
        wait_semaphore_count: u32,
        p_wait_semaphores: *const crate::data::Semaphore,
        image: crate::data::Image,
        p_native_fence_fd: *mut c_int,
    ) -> crate::data::Result;
    GetShaderInfoAMD(
        device: crate::data::Device,
        pipeline: crate::data::Pipeline,
        shader_stage: crate::data::ShaderStageFlagBits,
        info_type: crate::data::ShaderInfoTypeAMD,
        p_info_size: *mut usize,
        p_info: *mut c_void,
    ) -> crate::data::Result;
    SetLocalDimmingAMD(
        device: crate::data::Device,
        swap_chain: crate::data::SwapchainKHR,
        local_dimming_enable: crate::data::Bool32,
    );
    GetPhysicalDeviceCalibrateableTimeDomainsEXT(
        physical_device: crate::data::PhysicalDevice,
        p_time_domain_count: *mut u32,
        p_time_domains: *mut crate::data::TimeDomainEXT,
    ) -> crate::data::Result;
    GetCalibratedTimestampsEXT(
        device: crate::data::Device,
        timestamp_count: u32,
        p_timestamp_infos: *const crate::data::CalibratedTimestampInfoEXT,
        p_timestamps: *mut u64,
        p_max_deviation: *mut u64,
    ) -> crate::data::Result;
    SetDebugUtilsObjectNameEXT(
        device: crate::data::Device,
        p_name_info: *const crate::data::DebugUtilsObjectNameInfoEXT,
    ) -> crate::data::Result;
    SetDebugUtilsObjectTagEXT(
        device: crate::data::Device,
        p_tag_info: *const crate::data::DebugUtilsObjectTagInfoEXT,
    ) -> crate::data::Result;
    QueueBeginDebugUtilsLabelEXT(
        queue: crate::data::Queue,
        p_label_info: *const crate::data::DebugUtilsLabelEXT,
    );
    QueueEndDebugUtilsLabelEXT(
        queue: crate::data::Queue,
    );
    QueueInsertDebugUtilsLabelEXT(
        queue: crate::data::Queue,
        p_label_info: *const crate::data::DebugUtilsLabelEXT,
    );
    CmdBeginDebugUtilsLabelEXT(
        command_buffer: crate::data::CommandBuffer,
        p_label_info: *const crate::data::DebugUtilsLabelEXT,
    );
    CmdEndDebugUtilsLabelEXT(
        command_buffer: crate::data::CommandBuffer,
    );
    CmdInsertDebugUtilsLabelEXT(
        command_buffer: crate::data::CommandBuffer,
        p_label_info: *const crate::data::DebugUtilsLabelEXT,
    );
    CreateDebugUtilsMessengerEXT(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::DebugUtilsMessengerCreateInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_messenger: *mut crate::data::DebugUtilsMessengerEXT,
    ) -> crate::data::Result;
    DestroyDebugUtilsMessengerEXT(
        instance: crate::data::Instance,
        messenger: crate::data::DebugUtilsMessengerEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    SubmitDebugUtilsMessageEXT(
        instance: crate::data::Instance,
        message_severity: crate::data::DebugUtilsMessageSeverityFlagBitsEXT,
        message_types: crate::data::DebugUtilsMessageTypeFlagsEXT,
        p_callback_data: *const crate::data::DebugUtilsMessengerCallbackDataEXT,
    );
    GetMemoryHostPointerPropertiesEXT(
        device: crate::data::Device,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        p_host_pointer: *const c_void,
        p_memory_host_pointer_properties: *mut crate::data::MemoryHostPointerPropertiesEXT,
    ) -> crate::data::Result;
    CmdWriteBufferMarkerAMD(
        command_buffer: crate::data::CommandBuffer,
        pipeline_stage: crate::data::PipelineStageFlagBits,
        dst_buffer: crate::data::Buffer,
        dst_offset: crate::data::DeviceSize,
        marker: u32,
    );
    CreateRenderPass2(
        device: crate::data::Device,
        p_create_info: *const crate::data::RenderPassCreateInfo2,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_render_pass: *mut crate::data::RenderPass,
    ) -> crate::data::Result;
    CmdBeginRenderPass2(
        command_buffer: crate::data::CommandBuffer,
        p_render_pass_begin: *const crate::data::RenderPassBeginInfo,
        p_subpass_begin_info: *const crate::data::SubpassBeginInfo,
    );
    CmdNextSubpass2(
        command_buffer: crate::data::CommandBuffer,
        p_subpass_begin_info: *const crate::data::SubpassBeginInfo,
        p_subpass_end_info: *const crate::data::SubpassEndInfo,
    );
    CmdEndRenderPass2(
        command_buffer: crate::data::CommandBuffer,
        p_subpass_end_info: *const crate::data::SubpassEndInfo,
    );
    GetSemaphoreCounterValue(
        device: crate::data::Device,
        semaphore: crate::data::Semaphore,
        p_value: *mut u64,
    ) -> crate::data::Result;
    WaitSemaphores(
        device: crate::data::Device,
        p_wait_info: *const crate::data::SemaphoreWaitInfo,
        timeout: u64,
    ) -> crate::data::Result;
    SignalSemaphore(
        device: crate::data::Device,
        p_signal_info: *const crate::data::SemaphoreSignalInfo,
    ) -> crate::data::Result;
    GetAndroidHardwareBufferPropertiesANDROID(
        device: crate::data::Device,
        buffer: *const AHardwareBuffer,
        p_properties: *mut crate::data::AndroidHardwareBufferPropertiesANDROID,
    ) -> crate::data::Result;
    GetMemoryAndroidHardwareBufferANDROID(
        device: crate::data::Device,
        p_info: *const crate::data::MemoryGetAndroidHardwareBufferInfoANDROID,
        p_buffer: *mut *mut AHardwareBuffer,
    ) -> crate::data::Result;
    CmdDrawIndirectCount(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        count_buffer: crate::data::Buffer,
        count_buffer_offset: crate::data::DeviceSize,
        max_draw_count: u32,
        stride: u32,
    );
    CmdDrawIndexedIndirectCount(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        count_buffer: crate::data::Buffer,
        count_buffer_offset: crate::data::DeviceSize,
        max_draw_count: u32,
        stride: u32,
    );
    CmdSetCheckpointNV(
        command_buffer: crate::data::CommandBuffer,
        p_checkpoint_marker: *const c_void,
    );
    GetQueueCheckpointDataNV(
        queue: crate::data::Queue,
        p_checkpoint_data_count: *mut u32,
        p_checkpoint_data: *mut crate::data::CheckpointDataNV,
    );
    CmdBindTransformFeedbackBuffersEXT(
        command_buffer: crate::data::CommandBuffer,
        first_binding: u32,
        binding_count: u32,
        p_buffers: *const crate::data::Buffer,
        p_offsets: *const crate::data::DeviceSize,
        p_sizes: *const crate::data::DeviceSize,
    );
    CmdBeginTransformFeedbackEXT(
        command_buffer: crate::data::CommandBuffer,
        first_counter_buffer: u32,
        counter_buffer_count: u32,
        p_counter_buffers: *const crate::data::Buffer,
        p_counter_buffer_offsets: *const crate::data::DeviceSize,
    );
    CmdEndTransformFeedbackEXT(
        command_buffer: crate::data::CommandBuffer,
        first_counter_buffer: u32,
        counter_buffer_count: u32,
        p_counter_buffers: *const crate::data::Buffer,
        p_counter_buffer_offsets: *const crate::data::DeviceSize,
    );
    CmdBeginQueryIndexedEXT(
        command_buffer: crate::data::CommandBuffer,
        query_pool: crate::data::QueryPool,
        query: u32,
        flags: crate::data::QueryControlFlags,
        index: u32,
    );
    CmdEndQueryIndexedEXT(
        command_buffer: crate::data::CommandBuffer,
        query_pool: crate::data::QueryPool,
        query: u32,
        index: u32,
    );
    CmdDrawIndirectByteCountEXT(
        command_buffer: crate::data::CommandBuffer,
        instance_count: u32,
        first_instance: u32,
        counter_buffer: crate::data::Buffer,
        counter_buffer_offset: crate::data::DeviceSize,
        counter_offset: u32,
        vertex_stride: u32,
    );
    CmdSetExclusiveScissorNV(
        command_buffer: crate::data::CommandBuffer,
        first_exclusive_scissor: u32,
        exclusive_scissor_count: u32,
        p_exclusive_scissors: *const crate::data::Rect2D,
    );
    CmdBindShadingRateImageNV(
        command_buffer: crate::data::CommandBuffer,
        image_view: crate::data::ImageView,
        image_layout: crate::data::ImageLayout,
    );
    CmdSetViewportShadingRatePaletteNV(
        command_buffer: crate::data::CommandBuffer,
        first_viewport: u32,
        viewport_count: u32,
        p_shading_rate_palettes: *const crate::data::ShadingRatePaletteNV,
    );
    CmdSetCoarseSampleOrderNV(
        command_buffer: crate::data::CommandBuffer,
        sample_order_type: crate::data::CoarseSampleOrderTypeNV,
        custom_sample_order_count: u32,
        p_custom_sample_orders: *const crate::data::CoarseSampleOrderCustomNV,
    );
    CmdDrawMeshTasksNV(
        command_buffer: crate::data::CommandBuffer,
        task_count: u32,
        first_task: u32,
    );
    CmdDrawMeshTasksIndirectNV(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        draw_count: u32,
        stride: u32,
    );
    CmdDrawMeshTasksIndirectCountNV(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        count_buffer: crate::data::Buffer,
        count_buffer_offset: crate::data::DeviceSize,
        max_draw_count: u32,
        stride: u32,
    );
    CmdDrawMeshTasksEXT(
        command_buffer: crate::data::CommandBuffer,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    );
    CmdDrawMeshTasksIndirectEXT(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        draw_count: u32,
        stride: u32,
    );
    CmdDrawMeshTasksIndirectCountEXT(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        count_buffer: crate::data::Buffer,
        count_buffer_offset: crate::data::DeviceSize,
        max_draw_count: u32,
        stride: u32,
    );
    CompileDeferredNV(
        device: crate::data::Device,
        pipeline: crate::data::Pipeline,
        shader: u32,
    ) -> crate::data::Result;
    CreateAccelerationStructureNV(
        device: crate::data::Device,
        p_create_info: *const crate::data::AccelerationStructureCreateInfoNV,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_acceleration_structure: *mut crate::data::AccelerationStructureNV,
    ) -> crate::data::Result;
    CmdBindInvocationMaskHUAWEI(
        command_buffer: crate::data::CommandBuffer,
        image_view: crate::data::ImageView,
        image_layout: crate::data::ImageLayout,
    );
    DestroyAccelerationStructureKHR(
        device: crate::data::Device,
        acceleration_structure: crate::data::AccelerationStructureKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    DestroyAccelerationStructureNV(
        device: crate::data::Device,
        acceleration_structure: crate::data::AccelerationStructureNV,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetAccelerationStructureMemoryRequirementsNV(
        device: crate::data::Device,
        p_info: *const crate::data::AccelerationStructureMemoryRequirementsInfoNV,
        p_memory_requirements: *mut crate::data::MemoryRequirements2KHR,
    );
    BindAccelerationStructureMemoryNV(
        device: crate::data::Device,
        bind_info_count: u32,
        p_bind_infos: *const crate::data::BindAccelerationStructureMemoryInfoNV,
    ) -> crate::data::Result;
    CmdCopyAccelerationStructureNV(
        command_buffer: crate::data::CommandBuffer,
        dst: crate::data::AccelerationStructureNV,
        src: crate::data::AccelerationStructureNV,
        mode: crate::data::CopyAccelerationStructureModeKHR,
    );
    CmdCopyAccelerationStructureKHR(
        command_buffer: crate::data::CommandBuffer,
        p_info: *const crate::data::CopyAccelerationStructureInfoKHR,
    );
    CopyAccelerationStructureKHR(
        device: crate::data::Device,
        deferred_operation: crate::data::DeferredOperationKHR,
        p_info: *const crate::data::CopyAccelerationStructureInfoKHR,
    ) -> crate::data::Result;
    CmdCopyAccelerationStructureToMemoryKHR(
        command_buffer: crate::data::CommandBuffer,
        p_info: *const crate::data::CopyAccelerationStructureToMemoryInfoKHR,
    );
    CopyAccelerationStructureToMemoryKHR(
        device: crate::data::Device,
        deferred_operation: crate::data::DeferredOperationKHR,
        p_info: *const crate::data::CopyAccelerationStructureToMemoryInfoKHR,
    ) -> crate::data::Result;
    CmdCopyMemoryToAccelerationStructureKHR(
        command_buffer: crate::data::CommandBuffer,
        p_info: *const crate::data::CopyMemoryToAccelerationStructureInfoKHR,
    );
    CopyMemoryToAccelerationStructureKHR(
        device: crate::data::Device,
        deferred_operation: crate::data::DeferredOperationKHR,
        p_info: *const crate::data::CopyMemoryToAccelerationStructureInfoKHR,
    ) -> crate::data::Result;
    CmdWriteAccelerationStructuresPropertiesKHR(
        command_buffer: crate::data::CommandBuffer,
        acceleration_structure_count: u32,
        p_acceleration_structures: *const crate::data::AccelerationStructureKHR,
        query_type: crate::data::QueryType,
        query_pool: crate::data::QueryPool,
        first_query: u32,
    );
    CmdWriteAccelerationStructuresPropertiesNV(
        command_buffer: crate::data::CommandBuffer,
        acceleration_structure_count: u32,
        p_acceleration_structures: *const crate::data::AccelerationStructureNV,
        query_type: crate::data::QueryType,
        query_pool: crate::data::QueryPool,
        first_query: u32,
    );
    CmdBuildAccelerationStructureNV(
        command_buffer: crate::data::CommandBuffer,
        p_info: *const crate::data::AccelerationStructureInfoNV,
        instance_data: crate::data::Buffer,
        instance_offset: crate::data::DeviceSize,
        update: crate::data::Bool32,
        dst: crate::data::AccelerationStructureNV,
        src: crate::data::AccelerationStructureNV,
        scratch: crate::data::Buffer,
        scratch_offset: crate::data::DeviceSize,
    );
    WriteAccelerationStructuresPropertiesKHR(
        device: crate::data::Device,
        acceleration_structure_count: u32,
        p_acceleration_structures: *const crate::data::AccelerationStructureKHR,
        query_type: crate::data::QueryType,
        data_size: usize,
        p_data: *mut c_void,
        stride: usize,
    ) -> crate::data::Result;
    CmdTraceRaysKHR(
        command_buffer: crate::data::CommandBuffer,
        p_raygen_shader_binding_table: *const crate::data::StridedDeviceAddressRegionKHR,
        p_miss_shader_binding_table: *const crate::data::StridedDeviceAddressRegionKHR,
        p_hit_shader_binding_table: *const crate::data::StridedDeviceAddressRegionKHR,
        p_callable_shader_binding_table: *const crate::data::StridedDeviceAddressRegionKHR,
        width: u32,
        height: u32,
        depth: u32,
    );
    CmdTraceRaysNV(
        command_buffer: crate::data::CommandBuffer,
        raygen_shader_binding_table_buffer: crate::data::Buffer,
        raygen_shader_binding_offset: crate::data::DeviceSize,
        miss_shader_binding_table_buffer: crate::data::Buffer,
        miss_shader_binding_offset: crate::data::DeviceSize,
        miss_shader_binding_stride: crate::data::DeviceSize,
        hit_shader_binding_table_buffer: crate::data::Buffer,
        hit_shader_binding_offset: crate::data::DeviceSize,
        hit_shader_binding_stride: crate::data::DeviceSize,
        callable_shader_binding_table_buffer: crate::data::Buffer,
        callable_shader_binding_offset: crate::data::DeviceSize,
        callable_shader_binding_stride: crate::data::DeviceSize,
        width: u32,
        height: u32,
        depth: u32,
    );
    GetRayTracingShaderGroupHandlesKHR(
        device: crate::data::Device,
        pipeline: crate::data::Pipeline,
        first_group: u32,
        group_count: u32,
        data_size: usize,
        p_data: *mut c_void,
    ) -> crate::data::Result;
    GetRayTracingCaptureReplayShaderGroupHandlesKHR(
        device: crate::data::Device,
        pipeline: crate::data::Pipeline,
        first_group: u32,
        group_count: u32,
        data_size: usize,
        p_data: *mut c_void,
    ) -> crate::data::Result;
    GetAccelerationStructureHandleNV(
        device: crate::data::Device,
        acceleration_structure: crate::data::AccelerationStructureNV,
        data_size: usize,
        p_data: *mut c_void,
    ) -> crate::data::Result;
    CreateRayTracingPipelinesNV(
        device: crate::data::Device,
        pipeline_cache: crate::data::PipelineCache,
        create_info_count: u32,
        p_create_infos: *const crate::data::RayTracingPipelineCreateInfoNV,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_pipelines: *mut crate::data::Pipeline,
    ) -> crate::data::Result;
    CreateRayTracingPipelinesKHR(
        device: crate::data::Device,
        deferred_operation: crate::data::DeferredOperationKHR,
        pipeline_cache: crate::data::PipelineCache,
        create_info_count: u32,
        p_create_infos: *const crate::data::RayTracingPipelineCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_pipelines: *mut crate::data::Pipeline,
    ) -> crate::data::Result;
    GetPhysicalDeviceCooperativeMatrixPropertiesNV(
        physical_device: crate::data::PhysicalDevice,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::CooperativeMatrixPropertiesNV,
    ) -> crate::data::Result;
    CmdTraceRaysIndirectKHR(
        command_buffer: crate::data::CommandBuffer,
        p_raygen_shader_binding_table: *const crate::data::StridedDeviceAddressRegionKHR,
        p_miss_shader_binding_table: *const crate::data::StridedDeviceAddressRegionKHR,
        p_hit_shader_binding_table: *const crate::data::StridedDeviceAddressRegionKHR,
        p_callable_shader_binding_table: *const crate::data::StridedDeviceAddressRegionKHR,
        indirect_device_address: crate::data::DeviceAddress,
    );
    CmdTraceRaysIndirect2KHR(
        command_buffer: crate::data::CommandBuffer,
        indirect_device_address: crate::data::DeviceAddress,
    );
    GetDeviceAccelerationStructureCompatibilityKHR(
        device: crate::data::Device,
        p_version_info: *const crate::data::AccelerationStructureVersionInfoKHR,
        p_compatibility: *mut crate::data::AccelerationStructureCompatibilityKHR,
    );
    GetRayTracingShaderGroupStackSizeKHR(
        device: crate::data::Device,
        pipeline: crate::data::Pipeline,
        group: u32,
        group_shader: crate::data::ShaderGroupShaderKHR,
    ) -> crate::data::DeviceSize;
    CmdSetRayTracingPipelineStackSizeKHR(
        command_buffer: crate::data::CommandBuffer,
        pipeline_stack_size: u32,
    );
    GetImageViewHandleNVX(
        device: crate::data::Device,
        p_info: *const crate::data::ImageViewHandleInfoNVX,
    ) -> u32;
    GetImageViewAddressNVX(
        device: crate::data::Device,
        image_view: crate::data::ImageView,
        p_properties: *mut crate::data::ImageViewAddressPropertiesNVX,
    ) -> crate::data::Result;
    GetPhysicalDeviceSurfacePresentModes2EXT(
        physical_device: crate::data::PhysicalDevice,
        p_surface_info: *const crate::data::PhysicalDeviceSurfaceInfo2KHR,
        p_present_mode_count: *mut u32,
        p_present_modes: *mut crate::data::PresentModeKHR,
    ) -> crate::data::Result;
    GetDeviceGroupSurfacePresentModes2EXT(
        device: crate::data::Device,
        p_surface_info: *const crate::data::PhysicalDeviceSurfaceInfo2KHR,
        p_modes: *mut crate::data::DeviceGroupPresentModeFlagsKHR,
    ) -> crate::data::Result;
    AcquireFullScreenExclusiveModeEXT(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
    ) -> crate::data::Result;
    ReleaseFullScreenExclusiveModeEXT(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
    ) -> crate::data::Result;
    EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
        physical_device: crate::data::PhysicalDevice,
        queue_family_index: u32,
        p_counter_count: *mut u32,
        p_counters: *mut crate::data::PerformanceCounterKHR,
        p_counter_descriptions: *mut crate::data::PerformanceCounterDescriptionKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
        physical_device: crate::data::PhysicalDevice,
        p_performance_query_create_info: *const crate::data::QueryPoolPerformanceCreateInfoKHR,
        p_num_passes: *mut u32,
    );
    AcquireProfilingLockKHR(
        device: crate::data::Device,
        p_info: *const crate::data::AcquireProfilingLockInfoKHR,
    ) -> crate::data::Result;
    ReleaseProfilingLockKHR(
        device: crate::data::Device,
    );
    GetImageDrmFormatModifierPropertiesEXT(
        device: crate::data::Device,
        image: crate::data::Image,
        p_properties: *mut crate::data::ImageDrmFormatModifierPropertiesEXT,
    ) -> crate::data::Result;
    GetBufferOpaqueCaptureAddress(
        device: crate::data::Device,
        p_info: *const crate::data::BufferDeviceAddressInfo,
    ) -> u64;
    GetBufferDeviceAddress(
        device: crate::data::Device,
        p_info: *const crate::data::BufferDeviceAddressInfo,
    ) -> crate::data::DeviceAddress;
    CreateHeadlessSurfaceEXT(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::HeadlessSurfaceCreateInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
        physical_device: crate::data::PhysicalDevice,
        p_combination_count: *mut u32,
        p_combinations: *mut crate::data::FramebufferMixedSamplesCombinationNV,
    ) -> crate::data::Result;
    InitializePerformanceApiINTEL(
        device: crate::data::Device,
        p_initialize_info: *const crate::data::InitializePerformanceApiInfoINTEL,
    ) -> crate::data::Result;
    UninitializePerformanceApiINTEL(
        device: crate::data::Device,
    );
    CmdSetPerformanceMarkerINTEL(
        command_buffer: crate::data::CommandBuffer,
        p_marker_info: *const crate::data::PerformanceMarkerInfoINTEL,
    ) -> crate::data::Result;
    CmdSetPerformanceStreamMarkerINTEL(
        command_buffer: crate::data::CommandBuffer,
        p_marker_info: *const crate::data::PerformanceStreamMarkerInfoINTEL,
    ) -> crate::data::Result;
    CmdSetPerformanceOverrideINTEL(
        command_buffer: crate::data::CommandBuffer,
        p_override_info: *const crate::data::PerformanceOverrideInfoINTEL,
    ) -> crate::data::Result;
    AcquirePerformanceConfigurationINTEL(
        device: crate::data::Device,
        p_acquire_info: *const crate::data::PerformanceConfigurationAcquireInfoINTEL,
        p_configuration: *mut crate::data::PerformanceConfigurationINTEL,
    ) -> crate::data::Result;
    ReleasePerformanceConfigurationINTEL(
        device: crate::data::Device,
        configuration: crate::data::PerformanceConfigurationINTEL,
    ) -> crate::data::Result;
    QueueSetPerformanceConfigurationINTEL(
        queue: crate::data::Queue,
        configuration: crate::data::PerformanceConfigurationINTEL,
    ) -> crate::data::Result;
    GetPerformanceParameterINTEL(
        device: crate::data::Device,
        parameter: crate::data::PerformanceParameterTypeINTEL,
        p_value: *mut crate::data::PerformanceValueINTEL,
    ) -> crate::data::Result;
    GetDeviceMemoryOpaqueCaptureAddress(
        device: crate::data::Device,
        p_info: *const crate::data::DeviceMemoryOpaqueCaptureAddressInfo,
    ) -> u64;
    GetPipelineExecutablePropertiesKHR(
        device: crate::data::Device,
        p_pipeline_info: *const crate::data::PipelineInfoKHR,
        p_executable_count: *mut u32,
        p_properties: *mut crate::data::PipelineExecutablePropertiesKHR,
    ) -> crate::data::Result;
    GetPipelineExecutableStatisticsKHR(
        device: crate::data::Device,
        p_executable_info: *const crate::data::PipelineExecutableInfoKHR,
        p_statistic_count: *mut u32,
        p_statistics: *mut crate::data::PipelineExecutableStatisticKHR,
    ) -> crate::data::Result;
    GetPipelineExecutableInternalRepresentationsKHR(
        device: crate::data::Device,
        p_executable_info: *const crate::data::PipelineExecutableInfoKHR,
        p_internal_representation_count: *mut u32,
        p_internal_representations: *mut crate::data::PipelineExecutableInternalRepresentationKHR,
    ) -> crate::data::Result;
    CmdSetLineStippleEXT(
        command_buffer: crate::data::CommandBuffer,
        line_stipple_factor: u32,
        line_stipple_pattern: u16,
    );
    GetPhysicalDeviceToolProperties(
        physical_device: crate::data::PhysicalDevice,
        p_tool_count: *mut u32,
        p_tool_properties: *mut crate::data::PhysicalDeviceToolProperties,
    ) -> crate::data::Result;
    CreateAccelerationStructureKHR(
        device: crate::data::Device,
        p_create_info: *const crate::data::AccelerationStructureCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_acceleration_structure: *mut crate::data::AccelerationStructureKHR,
    ) -> crate::data::Result;
    CmdBuildAccelerationStructuresKHR(
        command_buffer: crate::data::CommandBuffer,
        info_count: u32,
        p_infos: *const crate::data::AccelerationStructureBuildGeometryInfoKHR,
        pp_build_range_infos: *const *const crate::data::AccelerationStructureBuildRangeInfoKHR,
    );
    CmdBuildAccelerationStructuresIndirectKHR(
        command_buffer: crate::data::CommandBuffer,
        info_count: u32,
        p_infos: *const crate::data::AccelerationStructureBuildGeometryInfoKHR,
        p_indirect_device_addresses: *const crate::data::DeviceAddress,
        p_indirect_strides: *const u32,
        pp_max_primitive_counts: *const *const u32,
    );
    BuildAccelerationStructuresKHR(
        device: crate::data::Device,
        deferred_operation: crate::data::DeferredOperationKHR,
        info_count: u32,
        p_infos: *const crate::data::AccelerationStructureBuildGeometryInfoKHR,
        pp_build_range_infos: *const *const crate::data::AccelerationStructureBuildRangeInfoKHR,
    ) -> crate::data::Result;
    GetAccelerationStructureDeviceAddressKHR(
        device: crate::data::Device,
        p_info: *const crate::data::AccelerationStructureDeviceAddressInfoKHR,
    ) -> crate::data::DeviceAddress;
    CreateDeferredOperationKHR(
        device: crate::data::Device,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_deferred_operation: *mut crate::data::DeferredOperationKHR,
    ) -> crate::data::Result;
    DestroyDeferredOperationKHR(
        device: crate::data::Device,
        operation: crate::data::DeferredOperationKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetDeferredOperationMaxConcurrencyKHR(
        device: crate::data::Device,
        operation: crate::data::DeferredOperationKHR,
    ) -> u32;
    GetDeferredOperationResultKHR(
        device: crate::data::Device,
        operation: crate::data::DeferredOperationKHR,
    ) -> crate::data::Result;
    DeferredOperationJoinKHR(
        device: crate::data::Device,
        operation: crate::data::DeferredOperationKHR,
    ) -> crate::data::Result;
    CmdSetCullMode(
        command_buffer: crate::data::CommandBuffer,
        cull_mode: crate::data::CullModeFlags,
    );
    CmdSetFrontFace(
        command_buffer: crate::data::CommandBuffer,
        front_face: crate::data::FrontFace,
    );
    CmdSetPrimitiveTopology(
        command_buffer: crate::data::CommandBuffer,
        primitive_topology: crate::data::PrimitiveTopology,
    );
    CmdSetViewportWithCount(
        command_buffer: crate::data::CommandBuffer,
        viewport_count: u32,
        p_viewports: *const crate::data::Viewport,
    );
    CmdSetScissorWithCount(
        command_buffer: crate::data::CommandBuffer,
        scissor_count: u32,
        p_scissors: *const crate::data::Rect2D,
    );
    CmdBindVertexBuffers2(
        command_buffer: crate::data::CommandBuffer,
        first_binding: u32,
        binding_count: u32,
        p_buffers: *const crate::data::Buffer,
        p_offsets: *const crate::data::DeviceSize,
        p_sizes: *const crate::data::DeviceSize,
        p_strides: *const crate::data::DeviceSize,
    );
    CmdSetDepthTestEnable(
        command_buffer: crate::data::CommandBuffer,
        depth_test_enable: crate::data::Bool32,
    );
    CmdSetDepthWriteEnable(
        command_buffer: crate::data::CommandBuffer,
        depth_write_enable: crate::data::Bool32,
    );
    CmdSetDepthCompareOp(
        command_buffer: crate::data::CommandBuffer,
        depth_compare_op: crate::data::CompareOp,
    );
    CmdSetDepthBoundsTestEnable(
        command_buffer: crate::data::CommandBuffer,
        depth_bounds_test_enable: crate::data::Bool32,
    );
    CmdSetStencilTestEnable(
        command_buffer: crate::data::CommandBuffer,
        stencil_test_enable: crate::data::Bool32,
    );
    CmdSetStencilOp(
        command_buffer: crate::data::CommandBuffer,
        face_mask: crate::data::StencilFaceFlags,
        fail_op: crate::data::StencilOp,
        pass_op: crate::data::StencilOp,
        depth_fail_op: crate::data::StencilOp,
        compare_op: crate::data::CompareOp,
    );
    CmdSetPatchControlPointsEXT(
        command_buffer: crate::data::CommandBuffer,
        patch_control_points: u32,
    );
    CmdSetRasterizerDiscardEnable(
        command_buffer: crate::data::CommandBuffer,
        rasterizer_discard_enable: crate::data::Bool32,
    );
    CmdSetDepthBiasEnable(
        command_buffer: crate::data::CommandBuffer,
        depth_bias_enable: crate::data::Bool32,
    );
    CmdSetLogicOpEXT(
        command_buffer: crate::data::CommandBuffer,
        logic_op: crate::data::LogicOp,
    );
    CmdSetPrimitiveRestartEnable(
        command_buffer: crate::data::CommandBuffer,
        primitive_restart_enable: crate::data::Bool32,
    );
    CreatePrivateDataSlot(
        device: crate::data::Device,
        p_create_info: *const crate::data::PrivateDataSlotCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_private_data_slot: *mut crate::data::PrivateDataSlot,
    ) -> crate::data::Result;
    CmdSetTessellationDomainOriginEXT(
        command_buffer: crate::data::CommandBuffer,
        domain_origin: crate::data::TessellationDomainOrigin,
    );
    CmdSetDepthClampEnableEXT(
        command_buffer: crate::data::CommandBuffer,
        depth_clamp_enable: crate::data::Bool32,
    );
    CmdSetPolygonModeEXT(
        command_buffer: crate::data::CommandBuffer,
        polygon_mode: crate::data::PolygonMode,
    );
    CmdSetRasterizationSamplesEXT(
        command_buffer: crate::data::CommandBuffer,
        rasterization_samples: crate::data::SampleCountFlagBits,
    );
    CmdSetSampleMaskEXT(
        command_buffer: crate::data::CommandBuffer,
        samples: crate::data::SampleCountFlagBits,
        p_sample_mask: *const crate::data::SampleMask,
    );
    CmdSetAlphaToCoverageEnableEXT(
        command_buffer: crate::data::CommandBuffer,
        alpha_to_coverage_enable: crate::data::Bool32,
    );
    CmdSetAlphaToOneEnableEXT(
        command_buffer: crate::data::CommandBuffer,
        alpha_to_one_enable: crate::data::Bool32,
    );
    CmdSetLogicOpEnableEXT(
        command_buffer: crate::data::CommandBuffer,
        logic_op_enable: crate::data::Bool32,
    );
    CmdSetColorBlendEnableEXT(
        command_buffer: crate::data::CommandBuffer,
        first_attachment: u32,
        attachment_count: u32,
        p_color_blend_enables: *const crate::data::Bool32,
    );
    CmdSetColorBlendEquationEXT(
        command_buffer: crate::data::CommandBuffer,
        first_attachment: u32,
        attachment_count: u32,
        p_color_blend_equations: *const crate::data::ColorBlendEquationEXT,
    );
    CmdSetColorWriteMaskEXT(
        command_buffer: crate::data::CommandBuffer,
        first_attachment: u32,
        attachment_count: u32,
        p_color_write_masks: *const crate::data::ColorComponentFlags,
    );
    CmdSetRasterizationStreamEXT(
        command_buffer: crate::data::CommandBuffer,
        rasterization_stream: u32,
    );
    CmdSetConservativeRasterizationModeEXT(
        command_buffer: crate::data::CommandBuffer,
        conservative_rasterization_mode: crate::data::ConservativeRasterizationModeEXT,
    );
    CmdSetExtraPrimitiveOverestimationSizeEXT(
        command_buffer: crate::data::CommandBuffer,
        extra_primitive_overestimation_size: c_float,
    );
    CmdSetDepthClipEnableEXT(
        command_buffer: crate::data::CommandBuffer,
        depth_clip_enable: crate::data::Bool32,
    );
    CmdSetSampleLocationsEnableEXT(
        command_buffer: crate::data::CommandBuffer,
        sample_locations_enable: crate::data::Bool32,
    );
    CmdSetColorBlendAdvancedEXT(
        command_buffer: crate::data::CommandBuffer,
        first_attachment: u32,
        attachment_count: u32,
        p_color_blend_advanced: *const crate::data::ColorBlendAdvancedEXT,
    );
    CmdSetProvokingVertexModeEXT(
        command_buffer: crate::data::CommandBuffer,
        provoking_vertex_mode: crate::data::ProvokingVertexModeEXT,
    );
    CmdSetLineRasterizationModeEXT(
        command_buffer: crate::data::CommandBuffer,
        line_rasterization_mode: crate::data::LineRasterizationModeEXT,
    );
    CmdSetLineStippleEnableEXT(
        command_buffer: crate::data::CommandBuffer,
        stippled_line_enable: crate::data::Bool32,
    );
    CmdSetDepthClipNegativeOneToOneEXT(
        command_buffer: crate::data::CommandBuffer,
        negative_one_to_one: crate::data::Bool32,
    );
    CmdSetViewportWScalingEnableNV(
        command_buffer: crate::data::CommandBuffer,
        viewport_w_scaling_enable: crate::data::Bool32,
    );
    CmdSetViewportSwizzleNV(
        command_buffer: crate::data::CommandBuffer,
        first_viewport: u32,
        viewport_count: u32,
        p_viewport_swizzles: *const crate::data::ViewportSwizzleNV,
    );
    CmdSetCoverageToColorEnableNV(
        command_buffer: crate::data::CommandBuffer,
        coverage_to_color_enable: crate::data::Bool32,
    );
    CmdSetCoverageToColorLocationNV(
        command_buffer: crate::data::CommandBuffer,
        coverage_to_color_location: u32,
    );
    CmdSetCoverageModulationModeNV(
        command_buffer: crate::data::CommandBuffer,
        coverage_modulation_mode: crate::data::CoverageModulationModeNV,
    );
    CmdSetCoverageModulationTableEnableNV(
        command_buffer: crate::data::CommandBuffer,
        coverage_modulation_table_enable: crate::data::Bool32,
    );
    CmdSetCoverageModulationTableNV(
        command_buffer: crate::data::CommandBuffer,
        coverage_modulation_table_count: u32,
        p_coverage_modulation_table: *const c_float,
    );
    CmdSetShadingRateImageEnableNV(
        command_buffer: crate::data::CommandBuffer,
        shading_rate_image_enable: crate::data::Bool32,
    );
    CmdSetCoverageReductionModeNV(
        command_buffer: crate::data::CommandBuffer,
        coverage_reduction_mode: crate::data::CoverageReductionModeNV,
    );
    CmdSetRepresentativeFragmentTestEnableNV(
        command_buffer: crate::data::CommandBuffer,
        representative_fragment_test_enable: crate::data::Bool32,
    );
    DestroyPrivateDataSlot(
        device: crate::data::Device,
        private_data_slot: crate::data::PrivateDataSlot,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    SetPrivateData(
        device: crate::data::Device,
        object_type: crate::data::ObjectType,
        object_handle: u64,
        private_data_slot: crate::data::PrivateDataSlot,
        data: u64,
    ) -> crate::data::Result;
    GetPrivateData(
        device: crate::data::Device,
        object_type: crate::data::ObjectType,
        object_handle: u64,
        private_data_slot: crate::data::PrivateDataSlot,
        p_data: *mut u64,
    );
    CmdCopyBuffer2(
        command_buffer: crate::data::CommandBuffer,
        p_copy_buffer_info: *const crate::data::CopyBufferInfo2,
    );
    CmdCopyImage2(
        command_buffer: crate::data::CommandBuffer,
        p_copy_image_info: *const crate::data::CopyImageInfo2,
    );
    CmdBlitImage2(
        command_buffer: crate::data::CommandBuffer,
        p_blit_image_info: *const crate::data::BlitImageInfo2,
    );
    CmdCopyBufferToImage2(
        command_buffer: crate::data::CommandBuffer,
        p_copy_buffer_to_image_info: *const crate::data::CopyBufferToImageInfo2,
    );
    CmdCopyImageToBuffer2(
        command_buffer: crate::data::CommandBuffer,
        p_copy_image_to_buffer_info: *const crate::data::CopyImageToBufferInfo2,
    );
    CmdResolveImage2(
        command_buffer: crate::data::CommandBuffer,
        p_resolve_image_info: *const crate::data::ResolveImageInfo2,
    );
    CmdSetFragmentShadingRateKHR(
        command_buffer: crate::data::CommandBuffer,
        p_fragment_size: *const crate::data::Extent2D,
        combiner_ops: [crate::data::FragmentShadingRateCombinerOpKHR; 2],
    );
    GetPhysicalDeviceFragmentShadingRatesKHR(
        physical_device: crate::data::PhysicalDevice,
        p_fragment_shading_rate_count: *mut u32,
        p_fragment_shading_rates: *mut crate::data::PhysicalDeviceFragmentShadingRateKHR,
    ) -> crate::data::Result;
    CmdSetFragmentShadingRateEnumNV(
        command_buffer: crate::data::CommandBuffer,
        shading_rate: crate::data::FragmentShadingRateNV,
        combiner_ops: [crate::data::FragmentShadingRateCombinerOpKHR; 2],
    );
    GetAccelerationStructureBuildSizesKHR(
        device: crate::data::Device,
        build_type: crate::data::AccelerationStructureBuildTypeKHR,
        p_build_info: *const crate::data::AccelerationStructureBuildGeometryInfoKHR,
        p_max_primitive_counts: *const u32,
        p_size_info: *mut crate::data::AccelerationStructureBuildSizesInfoKHR,
    );
    CmdSetVertexInputEXT(
        command_buffer: crate::data::CommandBuffer,
        vertex_binding_description_count: u32,
        p_vertex_binding_descriptions: *const crate::data::VertexInputBindingDescription2EXT,
        vertex_attribute_description_count: u32,
        p_vertex_attribute_descriptions: *const crate::data::VertexInputAttributeDescription2EXT,
    );
    CmdSetColorWriteEnableEXT(
        command_buffer: crate::data::CommandBuffer,
        attachment_count: u32,
        p_color_write_enables: *const crate::data::Bool32,
    );
    CmdSetEvent2(
        command_buffer: crate::data::CommandBuffer,
        event: crate::data::Event,
        p_dependency_info: *const crate::data::DependencyInfo,
    );
    CmdResetEvent2(
        command_buffer: crate::data::CommandBuffer,
        event: crate::data::Event,
        stage_mask: crate::data::PipelineStageFlags2,
    );
    CmdWaitEvents2(
        command_buffer: crate::data::CommandBuffer,
        event_count: u32,
        p_events: *const crate::data::Event,
        p_dependency_infos: *const crate::data::DependencyInfo,
    );
    CmdPipelineBarrier2(
        command_buffer: crate::data::CommandBuffer,
        p_dependency_info: *const crate::data::DependencyInfo,
    );
    QueueSubmit2(
        queue: crate::data::Queue,
        submit_count: u32,
        p_submits: *const crate::data::SubmitInfo2,
        fence: crate::data::Fence,
    ) -> crate::data::Result;
    CmdWriteTimestamp2(
        command_buffer: crate::data::CommandBuffer,
        stage: crate::data::PipelineStageFlags2,
        query_pool: crate::data::QueryPool,
        query: u32,
    );
    CmdWriteBufferMarker2AMD(
        command_buffer: crate::data::CommandBuffer,
        stage: crate::data::PipelineStageFlags2,
        dst_buffer: crate::data::Buffer,
        dst_offset: crate::data::DeviceSize,
        marker: u32,
    );
    GetQueueCheckpointData2NV(
        queue: crate::data::Queue,
        p_checkpoint_data_count: *mut u32,
        p_checkpoint_data: *mut crate::data::CheckpointData2NV,
    );
    GetPhysicalDeviceVideoCapabilitiesKHR(
        physical_device: crate::data::PhysicalDevice,
        p_video_profile: *const crate::data::VideoProfileInfoKHR,
        p_capabilities: *mut crate::data::VideoCapabilitiesKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceVideoFormatPropertiesKHR(
        physical_device: crate::data::PhysicalDevice,
        p_video_format_info: *const crate::data::PhysicalDeviceVideoFormatInfoKHR,
        p_video_format_property_count: *mut u32,
        p_video_format_properties: *mut crate::data::VideoFormatPropertiesKHR,
    ) -> crate::data::Result;
    CreateVideoSessionKHR(
        device: crate::data::Device,
        p_create_info: *const crate::data::VideoSessionCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_video_session: *mut crate::data::VideoSessionKHR,
    ) -> crate::data::Result;
    DestroyVideoSessionKHR(
        device: crate::data::Device,
        video_session: crate::data::VideoSessionKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateVideoSessionParametersKHR(
        device: crate::data::Device,
        p_create_info: *const crate::data::VideoSessionParametersCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_video_session_parameters: *mut crate::data::VideoSessionParametersKHR,
    ) -> crate::data::Result;
    UpdateVideoSessionParametersKHR(
        device: crate::data::Device,
        video_session_parameters: crate::data::VideoSessionParametersKHR,
        p_update_info: *const crate::data::VideoSessionParametersUpdateInfoKHR,
    ) -> crate::data::Result;
    DestroyVideoSessionParametersKHR(
        device: crate::data::Device,
        video_session_parameters: crate::data::VideoSessionParametersKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetVideoSessionMemoryRequirementsKHR(
        device: crate::data::Device,
        video_session: crate::data::VideoSessionKHR,
        p_memory_requirements_count: *mut u32,
        p_memory_requirements: *mut crate::data::VideoSessionMemoryRequirementsKHR,
    ) -> crate::data::Result;
    BindVideoSessionMemoryKHR(
        device: crate::data::Device,
        video_session: crate::data::VideoSessionKHR,
        bind_session_memory_info_count: u32,
        p_bind_session_memory_infos: *const crate::data::BindVideoSessionMemoryInfoKHR,
    ) -> crate::data::Result;
    CmdDecodeVideoKHR(
        command_buffer: crate::data::CommandBuffer,
        p_decode_info: *const crate::data::VideoDecodeInfoKHR,
    );
    CmdBeginVideoCodingKHR(
        command_buffer: crate::data::CommandBuffer,
        p_begin_info: *const crate::data::VideoBeginCodingInfoKHR,
    );
    CmdControlVideoCodingKHR(
        command_buffer: crate::data::CommandBuffer,
        p_coding_control_info: *const crate::data::VideoCodingControlInfoKHR,
    );
    CmdEndVideoCodingKHR(
        command_buffer: crate::data::CommandBuffer,
        p_end_coding_info: *const crate::data::VideoEndCodingInfoKHR,
    );
    CmdEncodeVideoKHR(
        command_buffer: crate::data::CommandBuffer,
        p_encode_info: *const crate::data::VideoEncodeInfoKHR,
    );
    CreateCuModuleNVX(
        device: crate::data::Device,
        p_create_info: *const crate::data::CuModuleCreateInfoNVX,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_module: *mut crate::data::CuModuleNVX,
    ) -> crate::data::Result;
    CreateCuFunctionNVX(
        device: crate::data::Device,
        p_create_info: *const crate::data::CuFunctionCreateInfoNVX,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_function: *mut crate::data::CuFunctionNVX,
    ) -> crate::data::Result;
    DestroyCuModuleNVX(
        device: crate::data::Device,
        module: crate::data::CuModuleNVX,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    DestroyCuFunctionNVX(
        device: crate::data::Device,
        function: crate::data::CuFunctionNVX,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CmdCuLaunchKernelNVX(
        command_buffer: crate::data::CommandBuffer,
        p_launch_info: *const crate::data::CuLaunchInfoNVX,
    );
    SetDeviceMemoryPriorityEXT(
        device: crate::data::Device,
        memory: crate::data::DeviceMemory,
        priority: c_float,
    );
    AcquireDrmDisplayEXT(
        physical_device: crate::data::PhysicalDevice,
        drm_fd: i32,
        display: crate::data::DisplayKHR,
    ) -> crate::data::Result;
    GetDrmDisplayEXT(
        physical_device: crate::data::PhysicalDevice,
        drm_fd: i32,
        connector_id: u32,
        display: *mut crate::data::DisplayKHR,
    ) -> crate::data::Result;
    WaitForPresentKHR(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        present_id: u64,
        timeout: u64,
    ) -> crate::data::Result;
    CreateBufferCollectionFUCHSIA(
        device: crate::data::Device,
        p_create_info: *const crate::data::BufferCollectionCreateInfoFUCHSIA,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_collection: *mut crate::data::BufferCollectionFUCHSIA,
    ) -> crate::data::Result;
    SetBufferCollectionBufferConstraintsFUCHSIA(
        device: crate::data::Device,
        collection: crate::data::BufferCollectionFUCHSIA,
        p_buffer_constraints_info: *const crate::data::BufferConstraintsInfoFUCHSIA,
    ) -> crate::data::Result;
    SetBufferCollectionImageConstraintsFUCHSIA(
        device: crate::data::Device,
        collection: crate::data::BufferCollectionFUCHSIA,
        p_image_constraints_info: *const crate::data::ImageConstraintsInfoFUCHSIA,
    ) -> crate::data::Result;
    DestroyBufferCollectionFUCHSIA(
        device: crate::data::Device,
        collection: crate::data::BufferCollectionFUCHSIA,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetBufferCollectionPropertiesFUCHSIA(
        device: crate::data::Device,
        collection: crate::data::BufferCollectionFUCHSIA,
        p_properties: *mut crate::data::BufferCollectionPropertiesFUCHSIA,
    ) -> crate::data::Result;
    CmdBeginRendering(
        command_buffer: crate::data::CommandBuffer,
        p_rendering_info: *const crate::data::RenderingInfo,
    );
    CmdEndRendering(
        command_buffer: crate::data::CommandBuffer,
    );
    GetDescriptorSetLayoutHostMappingInfoVALVE(
        device: crate::data::Device,
        p_binding_reference: *const crate::data::DescriptorSetBindingReferenceVALVE,
        p_host_mapping: *mut crate::data::DescriptorSetLayoutHostMappingInfoVALVE,
    );
    GetDescriptorSetHostMappingVALVE(
        device: crate::data::Device,
        descriptor_set: crate::data::DescriptorSet,
        pp_data: *mut *mut c_void,
    );
    CreateMicromapEXT(
        device: crate::data::Device,
        p_create_info: *const crate::data::MicromapCreateInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_micromap: *mut crate::data::MicromapEXT,
    ) -> crate::data::Result;
    CmdBuildMicromapsEXT(
        command_buffer: crate::data::CommandBuffer,
        info_count: u32,
        p_infos: *const crate::data::MicromapBuildInfoEXT,
    );
    BuildMicromapsEXT(
        device: crate::data::Device,
        deferred_operation: crate::data::DeferredOperationKHR,
        info_count: u32,
        p_infos: *const crate::data::MicromapBuildInfoEXT,
    ) -> crate::data::Result;
    DestroyMicromapEXT(
        device: crate::data::Device,
        micromap: crate::data::MicromapEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CmdCopyMicromapEXT(
        command_buffer: crate::data::CommandBuffer,
        p_info: *const crate::data::CopyMicromapInfoEXT,
    );
    CopyMicromapEXT(
        device: crate::data::Device,
        deferred_operation: crate::data::DeferredOperationKHR,
        p_info: *const crate::data::CopyMicromapInfoEXT,
    ) -> crate::data::Result;
    CmdCopyMicromapToMemoryEXT(
        command_buffer: crate::data::CommandBuffer,
        p_info: *const crate::data::CopyMicromapToMemoryInfoEXT,
    );
    CopyMicromapToMemoryEXT(
        device: crate::data::Device,
        deferred_operation: crate::data::DeferredOperationKHR,
        p_info: *const crate::data::CopyMicromapToMemoryInfoEXT,
    ) -> crate::data::Result;
    CmdCopyMemoryToMicromapEXT(
        command_buffer: crate::data::CommandBuffer,
        p_info: *const crate::data::CopyMemoryToMicromapInfoEXT,
    );
    CopyMemoryToMicromapEXT(
        device: crate::data::Device,
        deferred_operation: crate::data::DeferredOperationKHR,
        p_info: *const crate::data::CopyMemoryToMicromapInfoEXT,
    ) -> crate::data::Result;
    CmdWriteMicromapsPropertiesEXT(
        command_buffer: crate::data::CommandBuffer,
        micromap_count: u32,
        p_micromaps: *const crate::data::MicromapEXT,
        query_type: crate::data::QueryType,
        query_pool: crate::data::QueryPool,
        first_query: u32,
    );
    WriteMicromapsPropertiesEXT(
        device: crate::data::Device,
        micromap_count: u32,
        p_micromaps: *const crate::data::MicromapEXT,
        query_type: crate::data::QueryType,
        data_size: usize,
        p_data: *mut c_void,
        stride: usize,
    ) -> crate::data::Result;
    GetDeviceMicromapCompatibilityEXT(
        device: crate::data::Device,
        p_version_info: *const crate::data::MicromapVersionInfoEXT,
        p_compatibility: *mut crate::data::AccelerationStructureCompatibilityKHR,
    );
    GetMicromapBuildSizesEXT(
        device: crate::data::Device,
        build_type: crate::data::AccelerationStructureBuildTypeKHR,
        p_build_info: *const crate::data::MicromapBuildInfoEXT,
        p_size_info: *mut crate::data::MicromapBuildSizesInfoEXT,
    );
    GetShaderModuleIdentifierEXT(
        device: crate::data::Device,
        shader_module: crate::data::ShaderModule,
        p_identifier: *mut crate::data::ShaderModuleIdentifierEXT,
    );
    GetShaderModuleCreateInfoIdentifierEXT(
        device: crate::data::Device,
        p_create_info: *const crate::data::ShaderModuleCreateInfo,
        p_identifier: *mut crate::data::ShaderModuleIdentifierEXT,
    );
    GetImageSubresourceLayout2EXT(
        device: crate::data::Device,
        image: crate::data::Image,
        p_subresource: *const crate::data::ImageSubresource2EXT,
        p_layout: *mut crate::data::SubresourceLayout2EXT,
    );
    GetPipelinePropertiesEXT(
        device: crate::data::Device,
        p_pipeline_info: *const crate::data::PipelineInfoEXT,
        p_pipeline_properties: *mut crate::data::BaseOutStructure,
    ) -> crate::data::Result;
    ExportMetalObjectsEXT(
        device: crate::data::Device,
        p_metal_objects_info: *mut crate::data::ExportMetalObjectsInfoEXT,
    );
    GetFramebufferTilePropertiesQCOM(
        device: crate::data::Device,
        framebuffer: crate::data::Framebuffer,
        p_properties_count: *mut u32,
        p_properties: *mut crate::data::TilePropertiesQCOM,
    ) -> crate::data::Result;
    GetDynamicRenderingTilePropertiesQCOM(
        device: crate::data::Device,
        p_rendering_info: *const crate::data::RenderingInfo,
        p_properties: *mut crate::data::TilePropertiesQCOM,
    ) -> crate::data::Result;
    GetPhysicalDeviceOpticalFlowImageFormatsNV(
        physical_device: crate::data::PhysicalDevice,
        p_optical_flow_image_format_info: *const crate::data::OpticalFlowImageFormatInfoNV,
        p_format_count: *mut u32,
        p_image_format_properties: *mut crate::data::OpticalFlowImageFormatPropertiesNV,
    ) -> crate::data::Result;
    CreateOpticalFlowSessionNV(
        device: crate::data::Device,
        p_create_info: *const crate::data::OpticalFlowSessionCreateInfoNV,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_session: *mut crate::data::OpticalFlowSessionNV,
    ) -> crate::data::Result;
    DestroyOpticalFlowSessionNV(
        device: crate::data::Device,
        session: crate::data::OpticalFlowSessionNV,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    BindOpticalFlowSessionImageNV(
        device: crate::data::Device,
        session: crate::data::OpticalFlowSessionNV,
        binding_point: crate::data::OpticalFlowSessionBindingPointNV,
        view: crate::data::ImageView,
        layout: crate::data::ImageLayout,
    ) -> crate::data::Result;
    CmdOpticalFlowExecuteNV(
        command_buffer: crate::data::CommandBuffer,
        session: crate::data::OpticalFlowSessionNV,
        p_execute_info: *const crate::data::OpticalFlowExecuteInfoNV,
    );
    GetDeviceFaultInfoEXT(
        device: crate::data::Device,
        p_fault_counts: *mut crate::data::DeviceFaultCountsEXT,
        p_fault_info: *mut crate::data::DeviceFaultInfoEXT,
    ) -> crate::data::Result;
}

impl_extensions! {
    KHR_SURFACE_EXTENSION_NAME = VK_KHR_surface;
    KHR_SWAPCHAIN_EXTENSION_NAME = VK_KHR_swapchain;
    KHR_DISPLAY_EXTENSION_NAME = VK_KHR_display;
    KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = VK_KHR_display_swapchain;
    KHR_XLIB_SURFACE_EXTENSION_NAME = VK_KHR_xlib_surface;
    KHR_XCB_SURFACE_EXTENSION_NAME = VK_KHR_xcb_surface;
    KHR_WAYLAND_SURFACE_EXTENSION_NAME = VK_KHR_wayland_surface;
    KHR_ANDROID_SURFACE_EXTENSION_NAME = VK_KHR_android_surface;
    KHR_WIN32_SURFACE_EXTENSION_NAME = VK_KHR_win32_surface;
    EXT_DEBUG_REPORT_EXTENSION_NAME = VK_EXT_debug_report;
    NV_GLSL_SHADER_EXTENSION_NAME = VK_NV_glsl_shader;
    EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME = VK_EXT_depth_range_unrestricted;
    KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME = VK_KHR_sampler_mirror_clamp_to_edge;
    IMG_FILTER_CUBIC_EXTENSION_NAME = VK_IMG_filter_cubic;
    AMD_RASTERIZATION_ORDER_EXTENSION_NAME = VK_AMD_rasterization_order;
    AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME = VK_AMD_shader_trinary_minmax;
    AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME = VK_AMD_shader_explicit_vertex_parameter;
    EXT_DEBUG_MARKER_EXTENSION_NAME = VK_EXT_debug_marker;
    KHR_VIDEO_QUEUE_EXTENSION_NAME = VK_KHR_video_queue;
    KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME = VK_KHR_video_decode_queue;
    AMD_GCN_SHADER_EXTENSION_NAME = VK_AMD_gcn_shader;
    NV_DEDICATED_ALLOCATION_EXTENSION_NAME = VK_NV_dedicated_allocation;
    EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME = VK_EXT_transform_feedback;
    NVX_BINARY_IMPORT_EXTENSION_NAME = VK_NVX_binary_import;
    NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME = VK_NVX_image_view_handle;
    AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME = VK_AMD_draw_indirect_count;
    AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME = VK_AMD_negative_viewport_height;
    AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME = VK_AMD_gpu_shader_half_float;
    AMD_SHADER_BALLOT_EXTENSION_NAME = VK_AMD_shader_ballot;
    EXT_VIDEO_ENCODE_H264_EXTENSION_NAME = VK_EXT_video_encode_h264;
    EXT_VIDEO_ENCODE_H265_EXTENSION_NAME = VK_EXT_video_encode_h265;
    EXT_VIDEO_DECODE_H264_EXTENSION_NAME = VK_EXT_video_decode_h264;
    AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME = VK_AMD_texture_gather_bias_lod;
    AMD_SHADER_INFO_EXTENSION_NAME = VK_AMD_shader_info;
    KHR_DYNAMIC_RENDERING_EXTENSION_NAME = VK_KHR_dynamic_rendering;
    AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME = VK_AMD_shader_image_load_store_lod;
    GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME = VK_GGP_stream_descriptor_surface;
    NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME = VK_NV_corner_sampled_image;
    KHR_MULTIVIEW_EXTENSION_NAME = VK_KHR_multiview;
    IMG_FORMAT_PVRTC_EXTENSION_NAME = VK_IMG_format_pvrtc;
    NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = VK_NV_external_memory_capabilities;
    NV_EXTERNAL_MEMORY_EXTENSION_NAME = VK_NV_external_memory;
    NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME = VK_NV_external_memory_win32;
    NV_WIN32_KEYED_MUTEX_EXTENSION_NAME = VK_NV_win32_keyed_mutex;
    KHR_GET_PHYSICAL_DEVICE_PROPERTIES2_EXTENSION_NAME = VK_KHR_get_physical_device_properties2;
    KHR_DEVICE_GROUP_EXTENSION_NAME = VK_KHR_device_group;
    EXT_VALIDATION_FLAGS_EXTENSION_NAME = VK_EXT_validation_flags;
    NN_VI_SURFACE_EXTENSION_NAME = VK_NN_vi_surface;
    KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME = VK_KHR_shader_draw_parameters;
    EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME = VK_EXT_shader_subgroup_ballot;
    EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME = VK_EXT_shader_subgroup_vote;
    EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME = VK_EXT_texture_compression_astc_hdr;
    EXT_ASTC_DECODE_MODE_EXTENSION_NAME = VK_EXT_astc_decode_mode;
    EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME = VK_EXT_pipeline_robustness;
    KHR_MAINTENANCE1_EXTENSION_NAME = VK_KHR_maintenance1;
    KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME = VK_KHR_device_group_creation;
    KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = VK_KHR_external_memory_capabilities;
    KHR_EXTERNAL_MEMORY_EXTENSION_NAME = VK_KHR_external_memory;
    KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME = VK_KHR_external_memory_win32;
    KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME = VK_KHR_external_memory_fd;
    KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME = VK_KHR_win32_keyed_mutex;
    KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME = VK_KHR_external_semaphore_capabilities;
    KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME = VK_KHR_external_semaphore;
    KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME = VK_KHR_external_semaphore_win32;
    KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME = VK_KHR_external_semaphore_fd;
    KHR_PUSH_DESCRIPTOR_EXTENSION_NAME = VK_KHR_push_descriptor;
    EXT_CONDITIONAL_RENDERING_EXTENSION_NAME = VK_EXT_conditional_rendering;
    KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME = VK_KHR_shader_float16_int8;
    KHR_16BIT_STORAGE_EXTENSION_NAME = VK_KHR_16bit_storage;
    KHR_INCREMENTAL_PRESENT_EXTENSION_NAME = VK_KHR_incremental_present;
    KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME = VK_KHR_descriptor_update_template;
    NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME = VK_NV_clip_space_w_scaling;
    EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME = VK_EXT_direct_mode_display;
    EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME = VK_EXT_acquire_xlib_display;
    EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME = VK_EXT_display_surface_counter;
    EXT_DISPLAY_CONTROL_EXTENSION_NAME = VK_EXT_display_control;
    GOOGLE_DISPLAY_TIMING_EXTENSION_NAME = VK_GOOGLE_display_timing;
    NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME = VK_NV_sample_mask_override_coverage;
    NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME = VK_NV_geometry_shader_passthrough;
    NV_VIEWPORT_ARRAY2_EXTENSION_NAME = VK_NV_viewport_array2;
    NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME = VK_NVX_multiview_per_view_attributes;
    NV_VIEWPORT_SWIZZLE_EXTENSION_NAME = VK_NV_viewport_swizzle;
    EXT_DISCARD_RECTANGLES_EXTENSION_NAME = VK_EXT_discard_rectangles;
    EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME = VK_EXT_conservative_rasterization;
    EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME = VK_EXT_depth_clip_enable;
    EXT_SWAPCHAIN_COLORSPACE_EXTENSION_NAME = VK_EXT_swapchain_colorspace;
    EXT_HDR_METADATA_EXTENSION_NAME = VK_EXT_hdr_metadata;
    KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME = VK_KHR_imageless_framebuffer;
    KHR_CREATE_RENDERPASS2_EXTENSION_NAME = VK_KHR_create_renderpass2;
    KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME = VK_KHR_shared_presentable_image;
    KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME = VK_KHR_external_fence_capabilities;
    KHR_EXTERNAL_FENCE_EXTENSION_NAME = VK_KHR_external_fence;
    KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME = VK_KHR_external_fence_win32;
    KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME = VK_KHR_external_fence_fd;
    KHR_PERFORMANCE_QUERY_EXTENSION_NAME = VK_KHR_performance_query;
    KHR_MAINTENANCE2_EXTENSION_NAME = VK_KHR_maintenance2;
    KHR_GET_SURFACE_CAPABILITIES2_EXTENSION_NAME = VK_KHR_get_surface_capabilities2;
    KHR_VARIABLE_POINTERS_EXTENSION_NAME = VK_KHR_variable_pointers;
    KHR_GET_DISPLAY_PROPERTIES2_EXTENSION_NAME = VK_KHR_get_display_properties2;
    MVK_IOS_SURFACE_EXTENSION_NAME = VK_MVK_ios_surface;
    MVK_MACOS_SURFACE_EXTENSION_NAME = VK_MVK_macos_surface;
    EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME = VK_EXT_external_memory_dma_buf;
    EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME = VK_EXT_queue_family_foreign;
    KHR_DEDICATED_ALLOCATION_EXTENSION_NAME = VK_KHR_dedicated_allocation;
    EXT_DEBUG_UTILS_EXTENSION_NAME = VK_EXT_debug_utils;
    ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME = VK_ANDROID_external_memory_android_hardware_buffer;
    EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME = VK_EXT_sampler_filter_minmax;
    KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME = VK_KHR_storage_buffer_storage_class;
    AMD_GPU_SHADER_INT16_EXTENSION_NAME = VK_AMD_gpu_shader_int16;
    AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME = VK_AMD_mixed_attachment_samples;
    AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME = VK_AMD_shader_fragment_mask;
    EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME = VK_EXT_inline_uniform_block;
    EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME = VK_EXT_shader_stencil_export;
    EXT_SAMPLE_LOCATIONS_EXTENSION_NAME = VK_EXT_sample_locations;
    KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME = VK_KHR_relaxed_block_layout;
    KHR_GET_MEMORY_REQUIREMENTS2_EXTENSION_NAME = VK_KHR_get_memory_requirements2;
    KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME = VK_KHR_image_format_list;
    EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME = VK_EXT_blend_operation_advanced;
    NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME = VK_NV_fragment_coverage_to_color;
    KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME = VK_KHR_acceleration_structure;
    KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME = VK_KHR_ray_tracing_pipeline;
    KHR_RAY_QUERY_EXTENSION_NAME = VK_KHR_ray_query;
    NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME = VK_NV_framebuffer_mixed_samples;
    NV_FILL_RECTANGLE_EXTENSION_NAME = VK_NV_fill_rectangle;
    NV_SHADER_SM_BUILTINS_EXTENSION_NAME = VK_NV_shader_sm_builtins;
    EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME = VK_EXT_post_depth_coverage;
    KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME = VK_KHR_sampler_ycbcr_conversion;
    KHR_BIND_MEMORY2_EXTENSION_NAME = VK_KHR_bind_memory2;
    EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME = VK_EXT_image_drm_format_modifier;
    EXT_VALIDATION_CACHE_EXTENSION_NAME = VK_EXT_validation_cache;
    EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME = VK_EXT_descriptor_indexing;
    EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME = VK_EXT_shader_viewport_index_layer;
    KHR_PORTABILITY_SUBSET_EXTENSION_NAME = VK_KHR_portability_subset;
    NV_SHADING_RATE_IMAGE_EXTENSION_NAME = VK_NV_shading_rate_image;
    NV_RAY_TRACING_EXTENSION_NAME = VK_NV_ray_tracing;
    NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME = VK_NV_representative_fragment_test;
    KHR_MAINTENANCE3_EXTENSION_NAME = VK_KHR_maintenance3;
    KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME = VK_KHR_draw_indirect_count;
    EXT_FILTER_CUBIC_EXTENSION_NAME = VK_EXT_filter_cubic;
    QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME = VK_QCOM_render_pass_shader_resolve;
    EXT_GLOBAL_PRIORITY_EXTENSION_NAME = VK_EXT_global_priority;
    KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME = VK_KHR_shader_subgroup_extended_types;
    KHR_8BIT_STORAGE_EXTENSION_NAME = VK_KHR_8bit_storage;
    EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME = VK_EXT_external_memory_host;
    AMD_BUFFER_MARKER_EXTENSION_NAME = VK_AMD_buffer_marker;
    KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME = VK_KHR_shader_atomic_int64;
    KHR_SHADER_CLOCK_EXTENSION_NAME = VK_KHR_shader_clock;
    AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME = VK_AMD_pipeline_compiler_control;
    EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME = VK_EXT_calibrated_timestamps;
    AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME = VK_AMD_shader_core_properties;
    EXT_VIDEO_DECODE_H265_EXTENSION_NAME = VK_EXT_video_decode_h265;
    KHR_GLOBAL_PRIORITY_EXTENSION_NAME = VK_KHR_global_priority;
    AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME = VK_AMD_memory_overallocation_behavior;
    EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = VK_EXT_vertex_attribute_divisor;
    GGP_FRAME_TOKEN_EXTENSION_NAME = VK_GGP_frame_token;
    EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME = VK_EXT_pipeline_creation_feedback;
    KHR_DRIVER_PROPERTIES_EXTENSION_NAME = VK_KHR_driver_properties;
    KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME = VK_KHR_shader_float_controls;
    NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME = VK_NV_shader_subgroup_partitioned;
    KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME = VK_KHR_depth_stencil_resolve;
    KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME = VK_KHR_swapchain_mutable_format;
    NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME = VK_NV_compute_shader_derivatives;
    NV_MESH_SHADER_EXTENSION_NAME = VK_NV_mesh_shader;
    NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = VK_NV_fragment_shader_barycentric;
    NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME = VK_NV_shader_image_footprint;
    NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME = VK_NV_scissor_exclusive;
    NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME = VK_NV_device_diagnostic_checkpoints;
    KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME = VK_KHR_timeline_semaphore;
    INTEL_SHADER_INTEGER_FUNCTIONS2_EXTENSION_NAME = VK_INTEL_shader_integer_functions2;
    INTEL_PERFORMANCE_QUERY_EXTENSION_NAME = VK_INTEL_performance_query;
    KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME = VK_KHR_vulkan_memory_model;
    EXT_PCI_BUS_INFO_EXTENSION_NAME = VK_EXT_pci_bus_info;
    AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME = VK_AMD_display_native_hdr;
    FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME = VK_FUCHSIA_imagepipe_surface;
    KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME = VK_KHR_shader_terminate_invocation;
    EXT_METAL_SURFACE_EXTENSION_NAME = VK_EXT_metal_surface;
    EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME = VK_EXT_fragment_density_map;
    EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME = VK_EXT_scalar_block_layout;
    GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME = VK_GOOGLE_hlsl_functionality1;
    GOOGLE_DECORATE_STRING_EXTENSION_NAME = VK_GOOGLE_decorate_string;
    EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME = VK_EXT_subgroup_size_control;
    KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME = VK_KHR_fragment_shading_rate;
    AMD_SHADER_CORE_PROPERTIES2_EXTENSION_NAME = VK_AMD_shader_core_properties2;
    AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME = VK_AMD_device_coherent_memory;
    EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME = VK_EXT_shader_image_atomic_int64;
    KHR_SPIRV_1_4_EXTENSION_NAME = VK_KHR_spirv_1_4;
    EXT_MEMORY_BUDGET_EXTENSION_NAME = VK_EXT_memory_budget;
    EXT_MEMORY_PRIORITY_EXTENSION_NAME = VK_EXT_memory_priority;
    KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME = VK_KHR_surface_protected_capabilities;
    NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME = VK_NV_dedicated_allocation_image_aliasing;
    KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME = VK_KHR_separate_depth_stencil_layouts;
    EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = VK_EXT_buffer_device_address;
    EXT_TOOLING_INFO_EXTENSION_NAME = VK_EXT_tooling_info;
    EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME = VK_EXT_separate_stencil_usage;
    EXT_VALIDATION_FEATURES_EXTENSION_NAME = VK_EXT_validation_features;
    KHR_PRESENT_WAIT_EXTENSION_NAME = VK_KHR_present_wait;
    NV_COOPERATIVE_MATRIX_EXTENSION_NAME = VK_NV_cooperative_matrix;
    NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME = VK_NV_coverage_reduction_mode;
    EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME = VK_EXT_fragment_shader_interlock;
    EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME = VK_EXT_ycbcr_image_arrays;
    KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME = VK_KHR_uniform_buffer_standard_layout;
    EXT_PROVOKING_VERTEX_EXTENSION_NAME = VK_EXT_provoking_vertex;
    EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME = VK_EXT_full_screen_exclusive;
    EXT_HEADLESS_SURFACE_EXTENSION_NAME = VK_EXT_headless_surface;
    KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = VK_KHR_buffer_device_address;
    EXT_LINE_RASTERIZATION_EXTENSION_NAME = VK_EXT_line_rasterization;
    EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME = VK_EXT_shader_atomic_float;
    EXT_HOST_QUERY_RESET_EXTENSION_NAME = VK_EXT_host_query_reset;
    EXT_INDEX_TYPE_UINT8_EXTENSION_NAME = VK_EXT_index_type_uint8;
    EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME = VK_EXT_extended_dynamic_state;
    KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME = VK_KHR_deferred_host_operations;
    KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME = VK_KHR_pipeline_executable_properties;
    EXT_SHADER_ATOMIC_FLOAT2_EXTENSION_NAME = VK_EXT_shader_atomic_float2;
    EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME = VK_EXT_shader_demote_to_helper_invocation;
    NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = VK_NV_device_generated_commands;
    NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME = VK_NV_inherited_viewport_scissor;
    KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME = VK_KHR_shader_integer_dot_product;
    EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME = VK_EXT_texel_buffer_alignment;
    QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME = VK_QCOM_render_pass_transform;
    EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME = VK_EXT_device_memory_report;
    EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME = VK_EXT_acquire_drm_display;
    EXT_ROBUSTNESS2_EXTENSION_NAME = VK_EXT_robustness2;
    EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME = VK_EXT_custom_border_color;
    GOOGLE_USER_TYPE_EXTENSION_NAME = VK_GOOGLE_user_type;
    KHR_PIPELINE_LIBRARY_EXTENSION_NAME = VK_KHR_pipeline_library;
    NV_PRESENT_BARRIER_EXTENSION_NAME = VK_NV_present_barrier;
    KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME = VK_KHR_shader_non_semantic_info;
    KHR_PRESENT_ID_EXTENSION_NAME = VK_KHR_present_id;
    EXT_PRIVATE_DATA_EXTENSION_NAME = VK_EXT_private_data;
    EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME = VK_EXT_pipeline_creation_cache_control;
    KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME = VK_KHR_video_encode_queue;
    NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME = VK_NV_device_diagnostics_config;
    QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME = VK_QCOM_render_pass_store_ops;
    EXT_METAL_OBJECTS_EXTENSION_NAME = VK_EXT_metal_objects;
    KHR_SYNCHRONIZATION2_EXTENSION_NAME = VK_KHR_synchronization2;
    EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME = VK_EXT_graphics_pipeline_library;
    AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME = VK_AMD_shader_early_and_late_fragment_tests;
    KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = VK_KHR_fragment_shader_barycentric;
    KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME = VK_KHR_shader_subgroup_uniform_control_flow;
    KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME = VK_KHR_zero_initialize_workgroup_memory;
    NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME = VK_NV_fragment_shading_rate_enums;
    NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME = VK_NV_ray_tracing_motion_blur;
    EXT_MESH_SHADER_EXTENSION_NAME = VK_EXT_mesh_shader;
    EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME = VK_EXT_ycbcr_2plane_444_formats;
    EXT_FRAGMENT_DENSITY_MAP2_EXTENSION_NAME = VK_EXT_fragment_density_map2;
    QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME = VK_QCOM_rotated_copy_commands;
    EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME = VK_EXT_image_robustness;
    KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME = VK_KHR_workgroup_memory_explicit_layout;
    KHR_COPY_COMMANDS2_EXTENSION_NAME = VK_KHR_copy_commands2;
    EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME = VK_EXT_image_compression_control;
    EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME = VK_EXT_attachment_feedback_loop_layout;
    EXT_4444_FORMATS_EXTENSION_NAME = VK_EXT_4444_formats;
    EXT_DEVICE_FAULT_EXTENSION_NAME = VK_EXT_device_fault;
    ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME = VK_ARM_rasterization_order_attachment_access;
    EXT_RGBA10X6_FORMATS_EXTENSION_NAME = VK_EXT_rgba10x6_formats;
    NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME = VK_NV_acquire_winrt_display;
    EXT_DIRECTFB_SURFACE_EXTENSION_NAME = VK_EXT_directfb_surface;
    VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME = VK_VALVE_mutable_descriptor_type;
    EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME = VK_EXT_vertex_input_dynamic_state;
    EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME = VK_EXT_physical_device_drm;
    EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME = VK_EXT_device_address_binding_report;
    EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME = VK_EXT_depth_clip_control;
    EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME = VK_EXT_primitive_topology_list_restart;
    KHR_FORMAT_FEATURE_FLAGS2_EXTENSION_NAME = VK_KHR_format_feature_flags2;
    FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME = VK_FUCHSIA_external_memory;
    FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME = VK_FUCHSIA_external_semaphore;
    FUCHSIA_BUFFER_COLLECTION_EXTENSION_NAME = VK_FUCHSIA_buffer_collection;
    HUAWEI_SUBPASS_SHADING_EXTENSION_NAME = VK_HUAWEI_subpass_shading;
    HUAWEI_INVOCATION_MASK_EXTENSION_NAME = VK_HUAWEI_invocation_mask;
    NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME = VK_NV_external_memory_rdma;
    EXT_PIPELINE_PROPERTIES_EXTENSION_NAME = VK_EXT_pipeline_properties;
    EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME = VK_EXT_multisampled_render_to_single_sampled;
    EXT_EXTENDED_DYNAMIC_STATE2_EXTENSION_NAME = VK_EXT_extended_dynamic_state2;
    QNX_SCREEN_SURFACE_EXTENSION_NAME = VK_QNX_screen_surface;
    EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME = VK_EXT_color_write_enable;
    EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME = VK_EXT_primitives_generated_query;
    KHR_RAY_TRACING_MAINTENANCE1_EXTENSION_NAME = VK_KHR_ray_tracing_maintenance1;
    EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME = VK_EXT_global_priority_query;
    EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME = VK_EXT_image_view_min_lod;
    EXT_MULTI_DRAW_EXTENSION_NAME = VK_EXT_multi_draw;
    EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME = VK_EXT_image_2d_view_of_3d;
    KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME = VK_KHR_portability_enumeration;
    EXT_OPACITY_MICROMAP_EXTENSION_NAME = VK_EXT_opacity_micromap;
    EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME = VK_EXT_load_store_op_none;
    EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME = VK_EXT_border_color_swizzle;
    EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME = VK_EXT_pageable_device_local_memory;
    KHR_MAINTENANCE4_EXTENSION_NAME = VK_KHR_maintenance4;
    VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME = VK_VALVE_descriptor_set_host_mapping;
    EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME = VK_EXT_depth_clamp_zero_one;
    EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME = VK_EXT_non_seamless_cube_map;
    QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME = VK_QCOM_fragment_density_map_offset;
    NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME = VK_NV_linear_color_attachment;
    GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME = VK_GOOGLE_surfaceless_query;
    EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME = VK_EXT_image_compression_control_swapchain;
    QCOM_IMAGE_PROCESSING_EXTENSION_NAME = VK_QCOM_image_processing;
    EXT_EXTENDED_DYNAMIC_STATE3_EXTENSION_NAME = VK_EXT_extended_dynamic_state3;
    EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME = VK_EXT_subpass_merge_feedback;
    EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME = VK_EXT_shader_module_identifier;
    EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME = VK_EXT_rasterization_order_attachment_access;
    NV_OPTICAL_FLOW_EXTENSION_NAME = VK_NV_optical_flow;
    EXT_LEGACY_DITHERING_EXTENSION_NAME = VK_EXT_legacy_dithering;
    EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME = VK_EXT_pipeline_protected_access;
    QCOM_TILE_PROPERTIES_EXTENSION_NAME = VK_QCOM_tile_properties;
    SEC_AMIGO_PROFILING_EXTENSION_NAME = VK_SEC_amigo_profiling;
    EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME = VK_EXT_mutable_descriptor_type;
}

impl_externs! {
    ANativeWindow,
    AHardwareBuffer,
    CAMetalLayer,
    IOSurface,
    wl_display,
    wl_surface,
    IDirectFB,
    IDirectFBSurface,
    _screen_context,
    _screen_window,
}