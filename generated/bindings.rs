impl_enums! {
    bitmask FramebufferCreateFlags {
    };
    bitmask QueryPoolCreateFlags {
    };
    bitmask RenderPassCreateFlags {
    };
    bitmask PipelineLayoutCreateFlags {
    };
    bitmask PipelineCacheCreateFlags {
    };
    bitmask PipelineDepthStencilStateCreateFlags {
    };
    bitmask PipelineDynamicStateCreateFlags {
    };
    bitmask PipelineColorBlendStateCreateFlags {
    };
    bitmask PipelineMultisampleStateCreateFlags {
    };
    bitmask PipelineRasterizationStateCreateFlags {
    };
    bitmask PipelineViewportStateCreateFlags {
    };
    bitmask PipelineTessellationStateCreateFlags {
    };
    bitmask PipelineInputAssemblyStateCreateFlags {
    };
    bitmask PipelineVertexInputStateCreateFlags {
    };
    bitmask PipelineShaderStageCreateFlags {
    };
    bitmask BufferViewCreateFlags {
    };
    bitmask InstanceCreateFlags {
    };
    bitmask DeviceCreateFlags {
    };
    bitmask SemaphoreCreateFlags {
    };
    bitmask ShaderModuleCreateFlags {
    };
    bitmask EventCreateFlags {
    };
    bitmask MemoryMapFlags {
    };
    bitmask DescriptorPoolResetFlags {
    };
    bitmask DescriptorUpdateTemplateCreateFlags {
    };
    bitmask DisplayModeCreateFlagsKHR {
    };
    bitmask DisplaySurfaceCreateFlagsKHR {
    };
    bitmask AndroidSurfaceCreateFlagsKHR {
    };
    bitmask ViSurfaceCreateFlagsNN {
    };
    bitmask WaylandSurfaceCreateFlagsKHR {
    };
    bitmask Win32SurfaceCreateFlagsKHR {
    };
    bitmask XlibSurfaceCreateFlagsKHR {
    };
    bitmask XcbSurfaceCreateFlagsKHR {
    };
    bitmask IOSSurfaceCreateFlagsMVK {
    };
    bitmask MacOSSurfaceCreateFlagsMVK {
    };
    bitmask MetalSurfaceCreateFlagsEXT {
    };
    bitmask ImagePipeSurfaceCreateFlagsFUCHSIA {
    };
    bitmask StreamDescriptorSurfaceCreateFlagsGGP {
    };
    bitmask CommandPoolTrimFlags {
    };
    bitmask PipelineViewportSwizzleStateCreateFlagsNV {
    };
    bitmask PipelineDiscardRectangleStateCreateFlagsEXT {
    };
    bitmask PipelineCoverageToColorStateCreateFlagsNV {
    };
    bitmask PipelineCoverageModulationStateCreateFlagsNV {
    };
    bitmask ValidationCacheCreateFlagsEXT {
    };
    bitmask DebugUtilsMessengerCreateFlagsEXT {
    };
    bitmask DebugUtilsMessengerCallbackDataFlagsEXT {
    };
    bitmask PipelineRasterizationConservativeStateCreateFlagsEXT {
    };
    bitmask PipelineRasterizationStateStreamCreateFlagsEXT {
    };
    bitmask PipelineRasterizationDepthClipStateCreateFlagsEXT {
    };
    enum AttachmentLoadOp {
        LOAD = 0,
        CLEAR = 1,
        DONT_CARE = 2,
    };
    enum AttachmentStoreOp {
        STORE = 0,
        DONT_CARE = 1,
    };
    enum BlendFactor {
        ZERO = 0,
        ONE = 1,
        SRC_COLOR = 2,
        ONE_MINUS_SRC_COLOR = 3,
        DST_COLOR = 4,
        ONE_MINUS_DST_COLOR = 5,
        SRC_ALPHA = 6,
        ONE_MINUS_SRC_ALPHA = 7,
        DST_ALPHA = 8,
        ONE_MINUS_DST_ALPHA = 9,
        CONSTANT_COLOR = 10,
        ONE_MINUS_CONSTANT_COLOR = 11,
        CONSTANT_ALPHA = 12,
        ONE_MINUS_CONSTANT_ALPHA = 13,
        SRC_ALPHA_SATURATE = 14,
        SRC1_COLOR = 15,
        ONE_MINUS_SRC1_COLOR = 16,
        SRC1_ALPHA = 17,
        ONE_MINUS_SRC1_ALPHA = 18,
    };
    enum BlendOp {
        ADD = 0,
        SUBTRACT = 1,
        REVERSE_SUBTRACT = 2,
        MIN = 3,
        MAX = 4,
        ZERO_EXT = 1000148000,
        SRC_EXT = 1000148001,
        DST_EXT = 1000148002,
        SRC_OVER_EXT = 1000148003,
        DST_OVER_EXT = 1000148004,
        SRC_IN_EXT = 1000148005,
        DST_IN_EXT = 1000148006,
        SRC_OUT_EXT = 1000148007,
        DST_OUT_EXT = 1000148008,
        SRC_ATOP_EXT = 1000148009,
        DST_ATOP_EXT = 1000148010,
        XOR_EXT = 1000148011,
        MULTIPLY_EXT = 1000148012,
        SCREEN_EXT = 1000148013,
        OVERLAY_EXT = 1000148014,
        DARKEN_EXT = 1000148015,
        LIGHTEN_EXT = 1000148016,
        COLORDODGE_EXT = 1000148017,
        COLORBURN_EXT = 1000148018,
        HARDLIGHT_EXT = 1000148019,
        SOFTLIGHT_EXT = 1000148020,
        DIFFERENCE_EXT = 1000148021,
        EXCLUSION_EXT = 1000148022,
        INVERT_EXT = 1000148023,
        INVERT_RGB_EXT = 1000148024,
        LINEARDODGE_EXT = 1000148025,
        LINEARBURN_EXT = 1000148026,
        VIVIDLIGHT_EXT = 1000148027,
        LINEARLIGHT_EXT = 1000148028,
        PINLIGHT_EXT = 1000148029,
        HARDMIX_EXT = 1000148030,
        HSL_HUE_EXT = 1000148031,
        HSL_SATURATION_EXT = 1000148032,
        HSL_COLOR_EXT = 1000148033,
        HSL_LUMINOSITY_EXT = 1000148034,
        PLUS_EXT = 1000148035,
        PLUS_CLAMPED_EXT = 1000148036,
        PLUS_CLAMPED_ALPHA_EXT = 1000148037,
        PLUS_DARKER_EXT = 1000148038,
        MINUS_EXT = 1000148039,
        MINUS_CLAMPED_EXT = 1000148040,
        CONTRAST_EXT = 1000148041,
        INVERT_OVG_EXT = 1000148042,
        RED_EXT = 1000148043,
        GREEN_EXT = 1000148044,
        BLUE_EXT = 1000148045,
    };
    enum BorderColor {
        FLOAT_TRANSPARENT_BLACK = 0,
        INT_TRANSPARENT_BLACK = 1,
        FLOAT_OPAQUE_BLACK = 2,
        INT_OPAQUE_BLACK = 3,
        FLOAT_OPAQUE_WHITE = 4,
        INT_OPAQUE_WHITE = 5,
    };
    enum FramebufferCreateFlagBits {
    };
    enum QueryPoolCreateFlagBits {
    };
    bitmask RenderPassCreateFlagBits {
        RESERVED_0_BIT_KHR = 1,
    };
    bitmask SamplerCreateFlagBits {
        SUBSAMPLED_BIT_EXT = 1,
        SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 2,
    };
    enum PipelineCacheHeaderVersion {
        ONE = 1,
    };
    enum PipelineLayoutCreateFlagBits {
    };
    enum PipelineCacheCreateFlagBits {
    };
    enum PipelineDepthStencilStateCreateFlagBits {
    };
    enum PipelineDynamicStateCreateFlagBits {
    };
    enum PipelineColorBlendStateCreateFlagBits {
    };
    enum PipelineMultisampleStateCreateFlagBits {
    };
    enum PipelineRasterizationStateCreateFlagBits {
    };
    enum PipelineViewportStateCreateFlagBits {
    };
    enum PipelineTessellationStateCreateFlagBits {
    };
    enum PipelineInputAssemblyStateCreateFlagBits {
    };
    enum PipelineVertexInputStateCreateFlagBits {
    };
    enum PipelineShaderStageCreateFlagBits {
    };
    bitmask DescriptorSetLayoutCreateFlagBits {
        PUSH_DESCRIPTOR_BIT_KHR = 1,
        UPDATE_AFTER_BIND_POOL_BIT_EXT = 2,
    };
    enum BufferViewCreateFlagBits {
    };
    enum InstanceCreateFlagBits {
    };
    bitmask DeviceQueueCreateFlagBits {
        PROTECTED_BIT = 1,
    };
    bitmask BufferCreateFlagBits {
        SPARSE_BINDING_BIT = 1,
        SPARSE_RESIDENCY_BIT = 2,
        SPARSE_ALIASED_BIT = 4,
        PROTECTED_BIT = 8,
        DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 16,
    };
    bitmask BufferUsageFlagBits {
        TRANSFER_SRC_BIT = 1,
        TRANSFER_DST_BIT = 2,
        UNIFORM_TEXEL_BUFFER_BIT = 4,
        STORAGE_TEXEL_BUFFER_BIT = 8,
        UNIFORM_BUFFER_BIT = 16,
        STORAGE_BUFFER_BIT = 32,
        INDEX_BUFFER_BIT = 64,
        VERTEX_BUFFER_BIT = 128,
        INDIRECT_BUFFER_BIT = 256,
        RESERVED_15_BIT_KHR = 32768,
        RESERVED_16_BIT_KHR = 65536,
        RESERVED_13_BIT_KHR = 8192,
        RESERVED_14_BIT_KHR = 16384,
        TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 2048,
        TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 4096,
        CONDITIONAL_RENDERING_BIT_EXT = 512,
        RAY_TRACING_BIT_NV = 1024,
        SHADER_DEVICE_ADDRESS_BIT_EXT = 131072,
    };
    bitmask ColorComponentFlagBits {
        R_BIT = 1,
        G_BIT = 2,
        B_BIT = 4,
        A_BIT = 8,
    };
    enum ComponentSwizzle {
        IDENTITY = 0,
        ZERO = 1,
        ONE = 2,
        R = 3,
        G = 4,
        B = 5,
        A = 6,
    };
    bitmask CommandPoolCreateFlagBits {
        TRANSIENT_BIT = 1,
        RESET_COMMAND_BUFFER_BIT = 2,
        PROTECTED_BIT = 4,
    };
    bitmask CommandPoolResetFlagBits {
        RELEASE_RESOURCES_BIT = 1,
    };
    bitmask CommandBufferResetFlagBits {
        RELEASE_RESOURCES_BIT = 1,
    };
    enum CommandBufferLevel {
        PRIMARY = 0,
        SECONDARY = 1,
    };
    bitmask CommandBufferUsageFlagBits {
        ONE_TIME_SUBMIT_BIT = 1,
        RENDER_PASS_CONTINUE_BIT = 2,
        SIMULTANEOUS_USE_BIT = 4,
    };
    enum CompareOp {
        NEVER = 0,
        LESS = 1,
        EQUAL = 2,
        LESS_OR_EQUAL = 3,
        GREATER = 4,
        NOT_EQUAL = 5,
        GREATER_OR_EQUAL = 6,
        ALWAYS = 7,
    };
    bitmask CullModeFlagBits {
        NONE = 0,
        FRONT_BIT = 1,
        BACK_BIT = 2,
        FRONT_AND_BACK = 3,
    };
    enum DescriptorType {
        SAMPLER = 0,
        COMBINED_IMAGE_SAMPLER = 1,
        SAMPLED_IMAGE = 2,
        STORAGE_IMAGE = 3,
        UNIFORM_TEXEL_BUFFER = 4,
        STORAGE_TEXEL_BUFFER = 5,
        UNIFORM_BUFFER = 6,
        STORAGE_BUFFER = 7,
        UNIFORM_BUFFER_DYNAMIC = 8,
        STORAGE_BUFFER_DYNAMIC = 9,
        INPUT_ATTACHMENT = 10,
        INLINE_UNIFORM_BLOCK_EXT = 1000138000,
        ACCELERATION_STRUCTURE_NV = 1000165000,
    };
    enum DeviceCreateFlagBits {
    };
    enum DynamicState {
        VIEWPORT = 0,
        SCISSOR = 1,
        LINE_WIDTH = 2,
        DEPTH_BIAS = 3,
        BLEND_CONSTANTS = 4,
        DEPTH_BOUNDS = 5,
        STENCIL_COMPARE_MASK = 6,
        STENCIL_WRITE_MASK = 7,
        STENCIL_REFERENCE = 8,
        VIEWPORT_W_SCALING_NV = 1000087000,
        DISCARD_RECTANGLE_EXT = 1000099000,
        SAMPLE_LOCATIONS_EXT = 1000143000,
        VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
        VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
        EXCLUSIVE_SCISSOR_NV = 1000205001,
    };
    bitmask FenceCreateFlagBits {
        SIGNALED_BIT = 1,
    };
    enum PolygonMode {
        FILL = 0,
        LINE = 1,
        POINT = 2,
        FILL_RECTANGLE_NV = 1000153000,
    };
    enum Format {
        UNDEFINED = 0,
        R4G4_UNORM_PACK8 = 1,
        R4G4B4A4_UNORM_PACK16 = 2,
        B4G4R4A4_UNORM_PACK16 = 3,
        R5G6B5_UNORM_PACK16 = 4,
        B5G6R5_UNORM_PACK16 = 5,
        R5G5B5A1_UNORM_PACK16 = 6,
        B5G5R5A1_UNORM_PACK16 = 7,
        A1R5G5B5_UNORM_PACK16 = 8,
        R8_UNORM = 9,
        R8_SNORM = 10,
        R8_USCALED = 11,
        R8_SSCALED = 12,
        R8_UINT = 13,
        R8_SINT = 14,
        R8_SRGB = 15,
        R8G8_UNORM = 16,
        R8G8_SNORM = 17,
        R8G8_USCALED = 18,
        R8G8_SSCALED = 19,
        R8G8_UINT = 20,
        R8G8_SINT = 21,
        R8G8_SRGB = 22,
        R8G8B8_UNORM = 23,
        R8G8B8_SNORM = 24,
        R8G8B8_USCALED = 25,
        R8G8B8_SSCALED = 26,
        R8G8B8_UINT = 27,
        R8G8B8_SINT = 28,
        R8G8B8_SRGB = 29,
        B8G8R8_UNORM = 30,
        B8G8R8_SNORM = 31,
        B8G8R8_USCALED = 32,
        B8G8R8_SSCALED = 33,
        B8G8R8_UINT = 34,
        B8G8R8_SINT = 35,
        B8G8R8_SRGB = 36,
        R8G8B8A8_UNORM = 37,
        R8G8B8A8_SNORM = 38,
        R8G8B8A8_USCALED = 39,
        R8G8B8A8_SSCALED = 40,
        R8G8B8A8_UINT = 41,
        R8G8B8A8_SINT = 42,
        R8G8B8A8_SRGB = 43,
        B8G8R8A8_UNORM = 44,
        B8G8R8A8_SNORM = 45,
        B8G8R8A8_USCALED = 46,
        B8G8R8A8_SSCALED = 47,
        B8G8R8A8_UINT = 48,
        B8G8R8A8_SINT = 49,
        B8G8R8A8_SRGB = 50,
        A8B8G8R8_UNORM_PACK32 = 51,
        A8B8G8R8_SNORM_PACK32 = 52,
        A8B8G8R8_USCALED_PACK32 = 53,
        A8B8G8R8_SSCALED_PACK32 = 54,
        A8B8G8R8_UINT_PACK32 = 55,
        A8B8G8R8_SINT_PACK32 = 56,
        A8B8G8R8_SRGB_PACK32 = 57,
        A2R10G10B10_UNORM_PACK32 = 58,
        A2R10G10B10_SNORM_PACK32 = 59,
        A2R10G10B10_USCALED_PACK32 = 60,
        A2R10G10B10_SSCALED_PACK32 = 61,
        A2R10G10B10_UINT_PACK32 = 62,
        A2R10G10B10_SINT_PACK32 = 63,
        A2B10G10R10_UNORM_PACK32 = 64,
        A2B10G10R10_SNORM_PACK32 = 65,
        A2B10G10R10_USCALED_PACK32 = 66,
        A2B10G10R10_SSCALED_PACK32 = 67,
        A2B10G10R10_UINT_PACK32 = 68,
        A2B10G10R10_SINT_PACK32 = 69,
        R16_UNORM = 70,
        R16_SNORM = 71,
        R16_USCALED = 72,
        R16_SSCALED = 73,
        R16_UINT = 74,
        R16_SINT = 75,
        R16_SFLOAT = 76,
        R16G16_UNORM = 77,
        R16G16_SNORM = 78,
        R16G16_USCALED = 79,
        R16G16_SSCALED = 80,
        R16G16_UINT = 81,
        R16G16_SINT = 82,
        R16G16_SFLOAT = 83,
        R16G16B16_UNORM = 84,
        R16G16B16_SNORM = 85,
        R16G16B16_USCALED = 86,
        R16G16B16_SSCALED = 87,
        R16G16B16_UINT = 88,
        R16G16B16_SINT = 89,
        R16G16B16_SFLOAT = 90,
        R16G16B16A16_UNORM = 91,
        R16G16B16A16_SNORM = 92,
        R16G16B16A16_USCALED = 93,
        R16G16B16A16_SSCALED = 94,
        R16G16B16A16_UINT = 95,
        R16G16B16A16_SINT = 96,
        R16G16B16A16_SFLOAT = 97,
        R32_UINT = 98,
        R32_SINT = 99,
        R32_SFLOAT = 100,
        R32G32_UINT = 101,
        R32G32_SINT = 102,
        R32G32_SFLOAT = 103,
        R32G32B32_UINT = 104,
        R32G32B32_SINT = 105,
        R32G32B32_SFLOAT = 106,
        R32G32B32A32_UINT = 107,
        R32G32B32A32_SINT = 108,
        R32G32B32A32_SFLOAT = 109,
        R64_UINT = 110,
        R64_SINT = 111,
        R64_SFLOAT = 112,
        R64G64_UINT = 113,
        R64G64_SINT = 114,
        R64G64_SFLOAT = 115,
        R64G64B64_UINT = 116,
        R64G64B64_SINT = 117,
        R64G64B64_SFLOAT = 118,
        R64G64B64A64_UINT = 119,
        R64G64B64A64_SINT = 120,
        R64G64B64A64_SFLOAT = 121,
        B10G11R11_UFLOAT_PACK32 = 122,
        E5B9G9R9_UFLOAT_PACK32 = 123,
        D16_UNORM = 124,
        X8_D24_UNORM_PACK32 = 125,
        D32_SFLOAT = 126,
        S8_UINT = 127,
        D16_UNORM_S8_UINT = 128,
        D24_UNORM_S8_UINT = 129,
        D32_SFLOAT_S8_UINT = 130,
        BC1_RGB_UNORM_BLOCK = 131,
        BC1_RGB_SRGB_BLOCK = 132,
        BC1_RGBA_UNORM_BLOCK = 133,
        BC1_RGBA_SRGB_BLOCK = 134,
        BC2_UNORM_BLOCK = 135,
        BC2_SRGB_BLOCK = 136,
        BC3_UNORM_BLOCK = 137,
        BC3_SRGB_BLOCK = 138,
        BC4_UNORM_BLOCK = 139,
        BC4_SNORM_BLOCK = 140,
        BC5_UNORM_BLOCK = 141,
        BC5_SNORM_BLOCK = 142,
        BC6H_UFLOAT_BLOCK = 143,
        BC6H_SFLOAT_BLOCK = 144,
        BC7_UNORM_BLOCK = 145,
        BC7_SRGB_BLOCK = 146,
        ETC2_R8G8B8_UNORM_BLOCK = 147,
        ETC2_R8G8B8_SRGB_BLOCK = 148,
        ETC2_R8G8B8A1_UNORM_BLOCK = 149,
        ETC2_R8G8B8A1_SRGB_BLOCK = 150,
        ETC2_R8G8B8A8_UNORM_BLOCK = 151,
        ETC2_R8G8B8A8_SRGB_BLOCK = 152,
        EAC_R11_UNORM_BLOCK = 153,
        EAC_R11_SNORM_BLOCK = 154,
        EAC_R11G11_UNORM_BLOCK = 155,
        EAC_R11G11_SNORM_BLOCK = 156,
        ASTC_4x4_UNORM_BLOCK = 157,
        ASTC_4x4_SRGB_BLOCK = 158,
        ASTC_5x4_UNORM_BLOCK = 159,
        ASTC_5x4_SRGB_BLOCK = 160,
        ASTC_5x5_UNORM_BLOCK = 161,
        ASTC_5x5_SRGB_BLOCK = 162,
        ASTC_6x5_UNORM_BLOCK = 163,
        ASTC_6x5_SRGB_BLOCK = 164,
        ASTC_6x6_UNORM_BLOCK = 165,
        ASTC_6x6_SRGB_BLOCK = 166,
        ASTC_8x5_UNORM_BLOCK = 167,
        ASTC_8x5_SRGB_BLOCK = 168,
        ASTC_8x6_UNORM_BLOCK = 169,
        ASTC_8x6_SRGB_BLOCK = 170,
        ASTC_8x8_UNORM_BLOCK = 171,
        ASTC_8x8_SRGB_BLOCK = 172,
        ASTC_10x5_UNORM_BLOCK = 173,
        ASTC_10x5_SRGB_BLOCK = 174,
        ASTC_10x6_UNORM_BLOCK = 175,
        ASTC_10x6_SRGB_BLOCK = 176,
        ASTC_10x8_UNORM_BLOCK = 177,
        ASTC_10x8_SRGB_BLOCK = 178,
        ASTC_10x10_UNORM_BLOCK = 179,
        ASTC_10x10_SRGB_BLOCK = 180,
        ASTC_12x10_UNORM_BLOCK = 181,
        ASTC_12x10_SRGB_BLOCK = 182,
        ASTC_12x12_UNORM_BLOCK = 183,
        ASTC_12x12_SRGB_BLOCK = 184,
        G8B8G8R8_422_UNORM = 1000156000,
        B8G8R8G8_422_UNORM = 1000156001,
        G8_B8_R8_3PLANE_420_UNORM = 1000156002,
        G8_B8R8_2PLANE_420_UNORM = 1000156003,
        G8_B8_R8_3PLANE_422_UNORM = 1000156004,
        G8_B8R8_2PLANE_422_UNORM = 1000156005,
        G8_B8_R8_3PLANE_444_UNORM = 1000156006,
        R10X6_UNORM_PACK16 = 1000156007,
        R10X6G10X6_UNORM_2PACK16 = 1000156008,
        R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
        G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
        B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
        G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
        G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
        G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
        G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
        G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
        R12X4_UNORM_PACK16 = 1000156017,
        R12X4G12X4_UNORM_2PACK16 = 1000156018,
        R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
        G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
        B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
        G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
        G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
        G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
        G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
        G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
        G16B16G16R16_422_UNORM = 1000156027,
        B16G16R16G16_422_UNORM = 1000156028,
        G16_B16_R16_3PLANE_420_UNORM = 1000156029,
        G16_B16R16_2PLANE_420_UNORM = 1000156030,
        G16_B16_R16_3PLANE_422_UNORM = 1000156031,
        G16_B16R16_2PLANE_422_UNORM = 1000156032,
        G16_B16_R16_3PLANE_444_UNORM = 1000156033,
        PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
        PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
        PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
        PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
        PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
        PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
        PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
        PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
        G8B8G8R8_422_UNORM_KHR = 1000156000,
        B8G8R8G8_422_UNORM_KHR = 1000156001,
        G8_B8_R8_3PLANE_420_UNORM_KHR = 1000156002,
        G8_B8R8_2PLANE_420_UNORM_KHR = 1000156003,
        G8_B8_R8_3PLANE_422_UNORM_KHR = 1000156004,
        G8_B8R8_2PLANE_422_UNORM_KHR = 1000156005,
        G8_B8_R8_3PLANE_444_UNORM_KHR = 1000156006,
        R10X6_UNORM_PACK16_KHR = 1000156007,
        R10X6G10X6_UNORM_2PACK16_KHR = 1000156008,
        R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = 1000156009,
        G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = 1000156010,
        B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = 1000156011,
        G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = 1000156012,
        G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = 1000156013,
        G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = 1000156014,
        G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = 1000156015,
        G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = 1000156016,
        R12X4_UNORM_PACK16_KHR = 1000156017,
        R12X4G12X4_UNORM_2PACK16_KHR = 1000156018,
        R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = 1000156019,
        G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = 1000156020,
        B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = 1000156021,
        G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = 1000156022,
        G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = 1000156023,
        G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = 1000156024,
        G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = 1000156025,
        G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = 1000156026,
        G16B16G16R16_422_UNORM_KHR = 1000156027,
        B16G16R16G16_422_UNORM_KHR = 1000156028,
        G16_B16_R16_3PLANE_420_UNORM_KHR = 1000156029,
        G16_B16R16_2PLANE_420_UNORM_KHR = 1000156030,
        G16_B16_R16_3PLANE_422_UNORM_KHR = 1000156031,
        G16_B16R16_2PLANE_422_UNORM_KHR = 1000156032,
        G16_B16_R16_3PLANE_444_UNORM_KHR = 1000156033,
    };
    bitmask FormatFeatureFlagBits {
        SAMPLED_IMAGE_BIT = 1,
        STORAGE_IMAGE_BIT = 2,
        STORAGE_IMAGE_ATOMIC_BIT = 4,
        UNIFORM_TEXEL_BUFFER_BIT = 8,
        STORAGE_TEXEL_BUFFER_BIT = 16,
        STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 32,
        VERTEX_BUFFER_BIT = 64,
        COLOR_ATTACHMENT_BIT = 128,
        COLOR_ATTACHMENT_BLEND_BIT = 256,
        DEPTH_STENCIL_ATTACHMENT_BIT = 512,
        BLIT_SRC_BIT = 1024,
        BLIT_DST_BIT = 2048,
        SAMPLED_IMAGE_FILTER_LINEAR_BIT = 4096,
        TRANSFER_SRC_BIT = 16384,
        TRANSFER_DST_BIT = 32768,
        MIDPOINT_CHROMA_SAMPLES_BIT = 131072,
        SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 262144,
        SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 524288,
        SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 1048576,
        SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 2097152,
        DISJOINT_BIT = 4194304,
        COSITED_CHROMA_SAMPLES_BIT = 8388608,
        SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 8192,
        RESERVED_27_BIT_KHR = 134217728,
        RESERVED_28_BIT_KHR = 268435456,
        RESERVED_25_BIT_KHR = 33554432,
        RESERVED_26_BIT_KHR = 67108864,
        SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = 65536,
        FRAGMENT_DENSITY_MAP_BIT_EXT = 16777216,
        TRANSFER_SRC_BIT_KHR = 16384,
        TRANSFER_DST_BIT_KHR = 32768,
        MIDPOINT_CHROMA_SAMPLES_BIT_KHR = 131072,
        SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = 262144,
        SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = 524288,
        SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = 1048576,
        SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = 2097152,
        DISJOINT_BIT_KHR = 4194304,
        COSITED_CHROMA_SAMPLES_BIT_KHR = 8388608,
        SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 8192,
    };
    enum FrontFace {
        COUNTER_CLOCKWISE = 0,
        CLOCKWISE = 1,
    };
    bitmask ImageAspectFlagBits {
        COLOR_BIT = 1,
        DEPTH_BIT = 2,
        STENCIL_BIT = 4,
        METADATA_BIT = 8,
        PLANE_0_BIT = 16,
        PLANE_1_BIT = 32,
        PLANE_2_BIT = 64,
        MEMORY_PLANE_0_BIT_EXT = 128,
        MEMORY_PLANE_1_BIT_EXT = 256,
        MEMORY_PLANE_2_BIT_EXT = 512,
        MEMORY_PLANE_3_BIT_EXT = 1024,
        PLANE_0_BIT_KHR = 16,
        PLANE_1_BIT_KHR = 32,
        PLANE_2_BIT_KHR = 64,
    };
    bitmask ImageCreateFlagBits {
        SPARSE_BINDING_BIT = 1,
        SPARSE_RESIDENCY_BIT = 2,
        SPARSE_ALIASED_BIT = 4,
        MUTABLE_FORMAT_BIT = 8,
        CUBE_COMPATIBLE_BIT = 16,
        ALIAS_BIT = 1024,
        SPLIT_INSTANCE_BIND_REGIONS_BIT = 64,
        _2D_ARRAY_COMPATIBLE_BIT = 32,
        BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 128,
        EXTENDED_USAGE_BIT = 256,
        PROTECTED_BIT = 2048,
        DISJOINT_BIT = 512,
        CORNER_SAMPLED_BIT_NV = 8192,
        SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 4096,
        SUBSAMPLED_BIT_EXT = 16384,
        SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 64,
        _2D_ARRAY_COMPATIBLE_BIT_KHR = 32,
        BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = 128,
        EXTENDED_USAGE_BIT_KHR = 256,
        DISJOINT_BIT_KHR = 512,
        ALIAS_BIT_KHR = 1024,
    };
    enum ImageLayout {
        UNDEFINED = 0,
        GENERAL = 1,
        COLOR_ATTACHMENT_OPTIMAL = 2,
        DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
        DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
        SHADER_READ_ONLY_OPTIMAL = 5,
        TRANSFER_SRC_OPTIMAL = 6,
        TRANSFER_DST_OPTIMAL = 7,
        PREINITIALIZED = 8,
        DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
        DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
        PRESENT_SRC_KHR = 1000001002,
        SHARED_PRESENT_KHR = 1000111000,
        SHADING_RATE_OPTIMAL_NV = 1000164003,
        FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
        DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000117000,
        DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000117001,
    };
    enum ImageTiling {
        OPTIMAL = 0,
        LINEAR = 1,
        DRM_FORMAT_MODIFIER_EXT = 1000158000,
    };
    enum ImageType {
        _1D = 0,
        _2D = 1,
        _3D = 2,
    };
    bitmask ImageUsageFlagBits {
        TRANSFER_SRC_BIT = 1,
        TRANSFER_DST_BIT = 2,
        SAMPLED_BIT = 4,
        STORAGE_BIT = 8,
        COLOR_ATTACHMENT_BIT = 16,
        DEPTH_STENCIL_ATTACHMENT_BIT = 32,
        TRANSIENT_ATTACHMENT_BIT = 64,
        INPUT_ATTACHMENT_BIT = 128,
        RESERVED_13_BIT_KHR = 8192,
        RESERVED_14_BIT_KHR = 16384,
        RESERVED_15_BIT_KHR = 32768,
        RESERVED_10_BIT_KHR = 1024,
        RESERVED_11_BIT_KHR = 2048,
        RESERVED_12_BIT_KHR = 4096,
        SHADING_RATE_IMAGE_BIT_NV = 256,
        FRAGMENT_DENSITY_MAP_BIT_EXT = 512,
    };
    bitmask ImageViewCreateFlagBits {
        FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 1,
    };
    enum ImageViewType {
        _1D = 0,
        _2D = 1,
        _3D = 2,
        CUBE = 3,
        _1D_ARRAY = 4,
        _2D_ARRAY = 5,
        CUBE_ARRAY = 6,
    };
    enum SharingMode {
        EXCLUSIVE = 0,
        CONCURRENT = 1,
    };
    enum IndexType {
        UINT16 = 0,
        UINT32 = 1,
        NONE_NV = 1000165000,
    };
    enum LogicOp {
        CLEAR = 0,
        AND = 1,
        AND_REVERSE = 2,
        COPY = 3,
        AND_INVERTED = 4,
        NO_OP = 5,
        XOR = 6,
        OR = 7,
        NOR = 8,
        EQUIVALENT = 9,
        INVERT = 10,
        OR_REVERSE = 11,
        COPY_INVERTED = 12,
        OR_INVERTED = 13,
        NAND = 14,
        SET = 15,
    };
    bitmask MemoryHeapFlagBits {
        DEVICE_LOCAL_BIT = 1,
        MULTI_INSTANCE_BIT = 2,
        MULTI_INSTANCE_BIT_KHR = 2,
    };
    bitmask AccessFlagBits {
        INDIRECT_COMMAND_READ_BIT = 1,
        INDEX_READ_BIT = 2,
        VERTEX_ATTRIBUTE_READ_BIT = 4,
        UNIFORM_READ_BIT = 8,
        INPUT_ATTACHMENT_READ_BIT = 16,
        SHADER_READ_BIT = 32,
        SHADER_WRITE_BIT = 64,
        COLOR_ATTACHMENT_READ_BIT = 128,
        COLOR_ATTACHMENT_WRITE_BIT = 256,
        DEPTH_STENCIL_ATTACHMENT_READ_BIT = 512,
        DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1024,
        TRANSFER_READ_BIT = 2048,
        TRANSFER_WRITE_BIT = 4096,
        HOST_READ_BIT = 8192,
        HOST_WRITE_BIT = 16384,
        MEMORY_READ_BIT = 32768,
        MEMORY_WRITE_BIT = 65536,
        RESERVED_30_BIT_KHR = 1073741824,
        RESERVED_31_BIT_KHR = 2147483648,
        RESERVED_28_BIT_KHR = 268435456,
        RESERVED_29_BIT_KHR = 536870912,
        TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 33554432,
        TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 67108864,
        TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 134217728,
        CONDITIONAL_RENDERING_READ_BIT_EXT = 1048576,
        COMMAND_PROCESS_READ_BIT_NVX = 131072,
        COMMAND_PROCESS_WRITE_BIT_NVX = 262144,
        COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 524288,
        SHADING_RATE_IMAGE_READ_BIT_NV = 8388608,
        ACCELERATION_STRUCTURE_READ_BIT_NV = 2097152,
        ACCELERATION_STRUCTURE_WRITE_BIT_NV = 4194304,
        FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 16777216,
    };
    bitmask MemoryPropertyFlagBits {
        DEVICE_LOCAL_BIT = 1,
        HOST_VISIBLE_BIT = 2,
        HOST_COHERENT_BIT = 4,
        HOST_CACHED_BIT = 8,
        LAZILY_ALLOCATED_BIT = 16,
        PROTECTED_BIT = 32,
    };
    enum PhysicalDeviceType {
        OTHER = 0,
        INTEGRATED_GPU = 1,
        DISCRETE_GPU = 2,
        VIRTUAL_GPU = 3,
        CPU = 4,
    };
    enum PipelineBindPoint {
        GRAPHICS = 0,
        COMPUTE = 1,
        RAY_TRACING_NV = 1000165000,
    };
    bitmask PipelineCreateFlagBits {
        DISABLE_OPTIMIZATION_BIT = 1,
        ALLOW_DERIVATIVES_BIT = 2,
        DERIVATIVE_BIT = 4,
        VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 8,
        DISPATCH_BASE = 16,
        DEFER_COMPILE_BIT_NV = 32,
        VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 8,
        DISPATCH_BASE_KHR = 16,
    };
    enum PrimitiveTopology {
        POINT_LIST = 0,
        LINE_LIST = 1,
        LINE_STRIP = 2,
        TRIANGLE_LIST = 3,
        TRIANGLE_STRIP = 4,
        TRIANGLE_FAN = 5,
        LINE_LIST_WITH_ADJACENCY = 6,
        LINE_STRIP_WITH_ADJACENCY = 7,
        TRIANGLE_LIST_WITH_ADJACENCY = 8,
        TRIANGLE_STRIP_WITH_ADJACENCY = 9,
        PATCH_LIST = 10,
    };
    bitmask QueryControlFlagBits {
        PRECISE_BIT = 1,
    };
    bitmask QueryPipelineStatisticFlagBits {
        INPUT_ASSEMBLY_VERTICES_BIT = 1,
        INPUT_ASSEMBLY_PRIMITIVES_BIT = 2,
        VERTEX_SHADER_INVOCATIONS_BIT = 4,
        GEOMETRY_SHADER_INVOCATIONS_BIT = 8,
        GEOMETRY_SHADER_PRIMITIVES_BIT = 16,
        CLIPPING_INVOCATIONS_BIT = 32,
        CLIPPING_PRIMITIVES_BIT = 64,
        FRAGMENT_SHADER_INVOCATIONS_BIT = 128,
        TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 256,
        TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 512,
        COMPUTE_SHADER_INVOCATIONS_BIT = 1024,
    };
    bitmask QueryResultFlagBits {
        _64_BIT = 1,
        WAIT_BIT = 2,
        WITH_AVAILABILITY_BIT = 4,
        PARTIAL_BIT = 8,
    };
    enum QueryType {
        OCCLUSION = 0,
        PIPELINE_STATISTICS = 1,
        TIMESTAMP = 2,
        RESERVED_8 = 1000023008,
        RESERVED_4 = 1000024004,
        TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
        ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
    };
    bitmask QueueFlagBits {
        GRAPHICS_BIT = 1,
        COMPUTE_BIT = 2,
        TRANSFER_BIT = 4,
        SPARSE_BINDING_BIT = 8,
        PROTECTED_BIT = 16,
        RESERVED_6_BIT_KHR = 64,
        RESERVED_5_BIT_KHR = 32,
    };
    enum SubpassContents {
        INLINE = 0,
        SECONDARY_COMMAND_BUFFERS = 1,
    };
    enum Result {
        SUCCESS = 0,
        NOT_READY = 1,
        TIMEOUT = 2,
        EVENT_SET = 3,
        EVENT_RESET = 4,
        INCOMPLETE = 5,
        ERROR_OUT_OF_HOST_MEMORY = -1,
        ERROR_OUT_OF_DEVICE_MEMORY = -2,
        ERROR_INITIALIZATION_FAILED = -3,
        ERROR_DEVICE_LOST = -4,
        ERROR_MEMORY_MAP_FAILED = -5,
        ERROR_LAYER_NOT_PRESENT = -6,
        ERROR_EXTENSION_NOT_PRESENT = -7,
        ERROR_FEATURE_NOT_PRESENT = -8,
        ERROR_INCOMPATIBLE_DRIVER = -9,
        ERROR_TOO_MANY_OBJECTS = -10,
        ERROR_FORMAT_NOT_SUPPORTED = -11,
        ERROR_FRAGMENTED_POOL = -12,
        ERROR_OUT_OF_POOL_MEMORY = -1000069000,
        ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
        ERROR_SURFACE_LOST_KHR = -1000000000,
        ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
        SUBOPTIMAL_KHR = 1000001003,
        ERROR_OUT_OF_DATE_KHR = -1000001004,
        ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
        ERROR_VALIDATION_FAILED_EXT = -1000011001,
        ERROR_INVALID_SHADER_NV = -1000012000,
        ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
        ERROR_FRAGMENTATION_EXT = -1000161000,
        ERROR_NOT_PERMITTED_EXT = -1000174001,
        ERROR_INVALID_DEVICE_ADDRESS_EXT = -1000244000,
        ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
        ERROR_OUT_OF_POOL_MEMORY_KHR = -1000069000,
        ERROR_INVALID_EXTERNAL_HANDLE_KHR = -1000072003,
    };
    bitmask ShaderStageFlagBits {
        VERTEX_BIT = 1,
        TESSELLATION_CONTROL_BIT = 2,
        TESSELLATION_EVALUATION_BIT = 4,
        GEOMETRY_BIT = 8,
        FRAGMENT_BIT = 16,
        COMPUTE_BIT = 32,
        ALL_GRAPHICS = 31,
        ALL = 2147483647,
        RAYGEN_BIT_NV = 256,
        ANY_HIT_BIT_NV = 512,
        CLOSEST_HIT_BIT_NV = 1024,
        MISS_BIT_NV = 2048,
        INTERSECTION_BIT_NV = 4096,
        CALLABLE_BIT_NV = 8192,
        TASK_BIT_NV = 64,
        MESH_BIT_NV = 128,
    };
    bitmask SparseMemoryBindFlagBits {
        METADATA_BIT = 1,
    };
    bitmask StencilFaceFlagBits {
        FRONT_BIT = 1,
        BACK_BIT = 2,
        STENCIL_FRONT_AND_BACK = 3,
    };
    enum StencilOp {
        KEEP = 0,
        ZERO = 1,
        REPLACE = 2,
        INCREMENT_AND_CLAMP = 3,
        DECREMENT_AND_CLAMP = 4,
        INVERT = 5,
        INCREMENT_AND_WRAP = 6,
        DECREMENT_AND_WRAP = 7,
    };
    enum StructureType {
        APPLICATION_INFO = 0,
        INSTANCE_CREATE_INFO = 1,
        DEVICE_QUEUE_CREATE_INFO = 2,
        DEVICE_CREATE_INFO = 3,
        SUBMIT_INFO = 4,
        MEMORY_ALLOCATE_INFO = 5,
        MAPPED_MEMORY_RANGE = 6,
        BIND_SPARSE_INFO = 7,
        FENCE_CREATE_INFO = 8,
        SEMAPHORE_CREATE_INFO = 9,
        EVENT_CREATE_INFO = 10,
        QUERY_POOL_CREATE_INFO = 11,
        BUFFER_CREATE_INFO = 12,
        BUFFER_VIEW_CREATE_INFO = 13,
        IMAGE_CREATE_INFO = 14,
        IMAGE_VIEW_CREATE_INFO = 15,
        SHADER_MODULE_CREATE_INFO = 16,
        PIPELINE_CACHE_CREATE_INFO = 17,
        PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
        PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
        PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
        PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
        PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
        PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
        PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
        PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
        PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
        PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
        GRAPHICS_PIPELINE_CREATE_INFO = 28,
        COMPUTE_PIPELINE_CREATE_INFO = 29,
        PIPELINE_LAYOUT_CREATE_INFO = 30,
        SAMPLER_CREATE_INFO = 31,
        DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
        DESCRIPTOR_POOL_CREATE_INFO = 33,
        DESCRIPTOR_SET_ALLOCATE_INFO = 34,
        WRITE_DESCRIPTOR_SET = 35,
        COPY_DESCRIPTOR_SET = 36,
        FRAMEBUFFER_CREATE_INFO = 37,
        RENDER_PASS_CREATE_INFO = 38,
        COMMAND_POOL_CREATE_INFO = 39,
        COMMAND_BUFFER_ALLOCATE_INFO = 40,
        COMMAND_BUFFER_INHERITANCE_INFO = 41,
        COMMAND_BUFFER_BEGIN_INFO = 42,
        RENDER_PASS_BEGIN_INFO = 43,
        BUFFER_MEMORY_BARRIER = 44,
        IMAGE_MEMORY_BARRIER = 45,
        MEMORY_BARRIER = 46,
        LOADER_INSTANCE_CREATE_INFO = 47,
        LOADER_DEVICE_CREATE_INFO = 48,
        PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
        BIND_BUFFER_MEMORY_INFO = 1000157000,
        BIND_IMAGE_MEMORY_INFO = 1000157001,
        PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
        MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
        MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
        MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
        DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
        DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
        DEVICE_GROUP_SUBMIT_INFO = 1000060005,
        DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
        BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
        BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
        PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
        DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
        BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
        IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
        IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
        MEMORY_REQUIREMENTS_2 = 1000146003,
        SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
        PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
        PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
        FORMAT_PROPERTIES_2 = 1000059002,
        IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
        PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
        QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
        PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
        SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
        PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
        PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
        RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
        IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
        PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
        RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
        PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
        PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
        PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = 1000120000,
        PROTECTED_SUBMIT_INFO = 1000145000,
        PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
        PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
        DEVICE_QUEUE_INFO_2 = 1000145003,
        SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
        SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
        BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
        IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
        PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
        SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
        DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
        PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
        EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
        PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
        EXTERNAL_BUFFER_PROPERTIES = 1000071003,
        PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
        EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
        EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
        EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
        PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
        EXTERNAL_FENCE_PROPERTIES = 1000112001,
        EXPORT_FENCE_CREATE_INFO = 1000113000,
        EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
        PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
        EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
        PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
        DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
        PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = 1000063000,
        SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
        PRESENT_INFO_KHR = 1000001001,
        DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
        IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
        BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
        ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
        DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
        DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
        DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
        DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
        DISPLAY_PRESENT_INFO_KHR = 1000003000,
        XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
        XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
        WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
        ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
        WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
        NATIVE_BUFFER_ANDROID = 1000010000,
        DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
        PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
        DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
        DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
        DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
        DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
        DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
        DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
        PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
        PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
        PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
        IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
        TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
        STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
        PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
        EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
        EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
        IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
        EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
        WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
        VALIDATION_FLAGS_EXT = 1000061000,
        VI_SURFACE_CREATE_INFO_NN = 1000062000,
        IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
        PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
        IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
        EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
        MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
        MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
        IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
        MEMORY_FD_PROPERTIES_KHR = 1000074001,
        MEMORY_GET_FD_INFO_KHR = 1000074002,
        WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
        IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
        EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
        D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
        SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
        IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
        SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
        PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
        COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
        PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
        CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
        PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = 1000082000,
        PRESENT_REGIONS_KHR = 1000084000,
        OBJECT_TABLE_CREATE_INFO_NVX = 1000086000,
        INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = 1000086001,
        CMD_PROCESS_COMMANDS_INFO_NVX = 1000086002,
        CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = 1000086003,
        DEVICE_GENERATED_COMMANDS_LIMITS_NVX = 1000086004,
        DEVICE_GENERATED_COMMANDS_FEATURES_NVX = 1000086005,
        PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
        SURFACE_CAPABILITIES_2_EXT = 1000090000,
        DISPLAY_POWER_INFO_EXT = 1000091000,
        DEVICE_EVENT_INFO_EXT = 1000091001,
        DISPLAY_EVENT_INFO_EXT = 1000091002,
        SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
        PRESENT_TIMES_INFO_GOOGLE = 1000092000,
        PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
        PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
        PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
        PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
        PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
        PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
        PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
        PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
        HDR_METADATA_EXT = 1000105000,
        ATTACHMENT_DESCRIPTION_2_KHR = 1000109000,
        ATTACHMENT_REFERENCE_2_KHR = 1000109001,
        SUBPASS_DESCRIPTION_2_KHR = 1000109002,
        SUBPASS_DEPENDENCY_2_KHR = 1000109003,
        RENDER_PASS_CREATE_INFO_2_KHR = 1000109004,
        SUBPASS_BEGIN_INFO_KHR = 1000109005,
        SUBPASS_END_INFO_KHR = 1000109006,
        SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
        IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
        EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
        FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
        IMPORT_FENCE_FD_INFO_KHR = 1000115000,
        FENCE_GET_FD_INFO_KHR = 1000115001,
        PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
        SURFACE_CAPABILITIES_2_KHR = 1000119001,
        SURFACE_FORMAT_2_KHR = 1000119002,
        DISPLAY_PROPERTIES_2_KHR = 1000121000,
        DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
        DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
        DISPLAY_PLANE_INFO_2_KHR = 1000121003,
        DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
        IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
        MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
        DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
        DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
        DEBUG_UTILS_LABEL_EXT = 1000128002,
        DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
        DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
        ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
        ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
        ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
        IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
        MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
        EXTERNAL_FORMAT_ANDROID = 1000129005,
        PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000,
        SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001,
        PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000,
        PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001,
        WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002,
        DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003,
        SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
        RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
        PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
        PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
        MULTISAMPLE_PROPERTIES_EXT = 1000143004,
        IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 1000147000,
        PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
        PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
        PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
        PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
        PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
        DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
        DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158001,
        PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
        IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
        IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
        IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
        VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
        SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
        DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = 1000161000,
        PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = 1000161001,
        PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = 1000161002,
        DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = 1000161003,
        DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 1000161004,
        PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
        PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
        PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
        PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
        RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
        ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
        GEOMETRY_NV = 1000165003,
        GEOMETRY_TRIANGLES_NV = 1000165004,
        GEOMETRY_AABB_NV = 1000165005,
        BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
        WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
        ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
        PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
        RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
        ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
        PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
        PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
        PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
        FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
        DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000,
        PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = 1000177000,
        IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
        MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
        PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
        PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = 1000180000,
        CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000,
        PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
        DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
        PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
        PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
        PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002,
        PRESENT_FRAME_TOKEN_GGP = 1000191000,
        PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000,
        PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = 1000196000,
        PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = 1000197000,
        PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = 1000199000,
        SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = 1000199001,
        PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000,
        PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
        PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
        PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000,
        PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
        PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
        PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
        CHECKPOINT_DATA_NV = 1000206000,
        QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
        PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = 1000211000,
        PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
        DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
        SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
        IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
        METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
        PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
        PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
        RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
        PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = 1000221000,
        PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
        PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
        MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
        SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
        PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
        PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = 1000244000,
        BUFFER_DEVICE_ADDRESS_INFO_EXT = 1000244001,
        BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
        IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = 1000246000,
        VALIDATION_FEATURES_EXT = 1000247000,
        PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
        COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
        PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
        PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
        SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
        SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
        SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
        PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = 1000261000,
        DEBUG_REPORT_CREATE_INFO_EXT = 1000011000,
        RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = 1000053000,
        PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = 1000053001,
        PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = 1000053002,
        PHYSICAL_DEVICE_FEATURES_2_KHR = 1000059000,
        PHYSICAL_DEVICE_PROPERTIES_2_KHR = 1000059001,
        FORMAT_PROPERTIES_2_KHR = 1000059002,
        IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059003,
        PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = 1000059004,
        QUEUE_FAMILY_PROPERTIES_2_KHR = 1000059005,
        PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = 1000059006,
        SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059007,
        PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = 1000059008,
        MEMORY_ALLOCATE_FLAGS_INFO_KHR = 1000060000,
        DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = 1000060003,
        DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = 1000060004,
        DEVICE_GROUP_SUBMIT_INFO_KHR = 1000060005,
        DEVICE_GROUP_BIND_SPARSE_INFO_KHR = 1000060006,
        BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060013,
        BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060014,
        PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = 1000070000,
        DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = 1000070001,
        PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = 1000071000,
        EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = 1000071001,
        PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = 1000071002,
        EXTERNAL_BUFFER_PROPERTIES_KHR = 1000071003,
        PHYSICAL_DEVICE_ID_PROPERTIES_KHR = 1000071004,
        EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = 1000072000,
        EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = 1000072001,
        EXPORT_MEMORY_ALLOCATE_INFO_KHR = 1000072002,
        PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = 1000076000,
        EXTERNAL_SEMAPHORE_PROPERTIES_KHR = 1000076001,
        EXPORT_SEMAPHORE_CREATE_INFO_KHR = 1000077000,
        PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = 1000083000,
        DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = 1000085000,
        SURFACE_CAPABILITIES2_EXT = 1000090000,
        PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = 1000112000,
        EXTERNAL_FENCE_PROPERTIES_KHR = 1000112001,
        EXPORT_FENCE_CREATE_INFO_KHR = 1000113000,
        PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = 1000117000,
        RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = 1000117001,
        IMAGE_VIEW_USAGE_CREATE_INFO_KHR = 1000117002,
        PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = 1000117003,
        PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = 1000120000,
        MEMORY_DEDICATED_REQUIREMENTS_KHR = 1000127000,
        MEMORY_DEDICATED_ALLOCATE_INFO_KHR = 1000127001,
        BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146000,
        IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146001,
        IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146002,
        MEMORY_REQUIREMENTS_2_KHR = 1000146003,
        SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = 1000146004,
        SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = 1000156000,
        SAMPLER_YCBCR_CONVERSION_INFO_KHR = 1000156001,
        BIND_IMAGE_PLANE_MEMORY_INFO_KHR = 1000156002,
        IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = 1000156003,
        PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = 1000156004,
        SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = 1000156005,
        BIND_BUFFER_MEMORY_INFO_KHR = 1000157000,
        BIND_IMAGE_MEMORY_INFO_KHR = 1000157001,
        PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = 1000168000,
        DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = 1000168001,
    };
    enum SystemAllocationScope {
        COMMAND = 0,
        OBJECT = 1,
        CACHE = 2,
        DEVICE = 3,
        INSTANCE = 4,
    };
    enum InternalAllocationType {
        EXECUTABLE = 0,
    };
    enum SamplerAddressMode {
        REPEAT = 0,
        MIRRORED_REPEAT = 1,
        CLAMP_TO_EDGE = 2,
        CLAMP_TO_BORDER = 3,
        MIRROR_CLAMP_TO_EDGE = 4,
    };
    enum Filter {
        NEAREST = 0,
        LINEAR = 1,
        CUBIC_IMG = 1000015000,
        CUBIC_EXT = 1000015000,
    };
    enum SamplerMipmapMode {
        NEAREST = 0,
        LINEAR = 1,
    };
    enum VertexInputRate {
        VERTEX = 0,
        INSTANCE = 1,
    };
    bitmask PipelineStageFlagBits {
        TOP_OF_PIPE_BIT = 1,
        DRAW_INDIRECT_BIT = 2,
        VERTEX_INPUT_BIT = 4,
        VERTEX_SHADER_BIT = 8,
        TESSELLATION_CONTROL_SHADER_BIT = 16,
        TESSELLATION_EVALUATION_SHADER_BIT = 32,
        GEOMETRY_SHADER_BIT = 64,
        FRAGMENT_SHADER_BIT = 128,
        EARLY_FRAGMENT_TESTS_BIT = 256,
        LATE_FRAGMENT_TESTS_BIT = 512,
        COLOR_ATTACHMENT_OUTPUT_BIT = 1024,
        COMPUTE_SHADER_BIT = 2048,
        TRANSFER_BIT = 4096,
        BOTTOM_OF_PIPE_BIT = 8192,
        HOST_BIT = 16384,
        ALL_GRAPHICS_BIT = 32768,
        ALL_COMMANDS_BIT = 65536,
        RESERVED_27_BIT_KHR = 134217728,
        RESERVED_26_BIT_KHR = 67108864,
        TRANSFORM_FEEDBACK_BIT_EXT = 16777216,
        CONDITIONAL_RENDERING_BIT_EXT = 262144,
        COMMAND_PROCESS_BIT_NVX = 131072,
        SHADING_RATE_IMAGE_BIT_NV = 4194304,
        RAY_TRACING_SHADER_BIT_NV = 2097152,
        ACCELERATION_STRUCTURE_BUILD_BIT_NV = 33554432,
        TASK_SHADER_BIT_NV = 524288,
        MESH_SHADER_BIT_NV = 1048576,
        FRAGMENT_DENSITY_PROCESS_BIT_EXT = 8388608,
    };
    bitmask SparseImageFormatFlagBits {
        SINGLE_MIPTAIL_BIT = 1,
        ALIGNED_MIP_SIZE_BIT = 2,
        NONSTANDARD_BLOCK_SIZE_BIT = 4,
    };
    bitmask SampleCountFlagBits {
        _1_BIT = 1,
        _2_BIT = 2,
        _4_BIT = 4,
        _8_BIT = 8,
        _16_BIT = 16,
        _32_BIT = 32,
        _64_BIT = 64,
    };
    bitmask AttachmentDescriptionFlagBits {
        MAY_ALIAS_BIT = 1,
    };
    bitmask DescriptorPoolCreateFlagBits {
        FREE_DESCRIPTOR_SET_BIT = 1,
        UPDATE_AFTER_BIND_BIT_EXT = 2,
    };
    bitmask DependencyFlagBits {
        BY_REGION_BIT = 1,
        DEVICE_GROUP_BIT = 4,
        VIEW_LOCAL_BIT = 2,
        VIEW_LOCAL_BIT_KHR = 2,
        DEVICE_GROUP_BIT_KHR = 4,
    };
    enum ObjectType {
        UNKNOWN = 0,
        INSTANCE = 1,
        PHYSICAL_DEVICE = 2,
        DEVICE = 3,
        QUEUE = 4,
        SEMAPHORE = 5,
        COMMAND_BUFFER = 6,
        FENCE = 7,
        DEVICE_MEMORY = 8,
        BUFFER = 9,
        IMAGE = 10,
        EVENT = 11,
        QUERY_POOL = 12,
        BUFFER_VIEW = 13,
        IMAGE_VIEW = 14,
        SHADER_MODULE = 15,
        PIPELINE_CACHE = 16,
        PIPELINE_LAYOUT = 17,
        RENDER_PASS = 18,
        PIPELINE = 19,
        DESCRIPTOR_SET_LAYOUT = 20,
        SAMPLER = 21,
        DESCRIPTOR_POOL = 22,
        DESCRIPTOR_SET = 23,
        FRAMEBUFFER = 24,
        COMMAND_POOL = 25,
        SAMPLER_YCBCR_CONVERSION = 1000156000,
        DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
        SURFACE_KHR = 1000000000,
        SWAPCHAIN_KHR = 1000001000,
        DISPLAY_KHR = 1000002000,
        DISPLAY_MODE_KHR = 1000002001,
        DEBUG_REPORT_CALLBACK_EXT = 1000011000,
        OBJECT_TABLE_NVX = 1000086000,
        INDIRECT_COMMANDS_LAYOUT_NVX = 1000086001,
        DEBUG_UTILS_MESSENGER_EXT = 1000128000,
        VALIDATION_CACHE_EXT = 1000160000,
        ACCELERATION_STRUCTURE_NV = 1000165000,
        DESCRIPTOR_UPDATE_TEMPLATE_KHR = 1000085000,
        SAMPLER_YCBCR_CONVERSION_KHR = 1000156000,
    };
    bitmask DescriptorBindingFlagBitsEXT {
        UPDATE_AFTER_BIND_BIT_EXT = 1,
        UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = 2,
        PARTIALLY_BOUND_BIT_EXT = 4,
        VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = 8,
    };
    bitmask ConditionalRenderingFlagBitsEXT {
        INVERTED_BIT_EXT = 1,
    };
    bitmask IndirectCommandsLayoutUsageFlagBitsNVX {
        UNORDERED_SEQUENCES_BIT_NVX = 1,
        SPARSE_SEQUENCES_BIT_NVX = 2,
        EMPTY_EXECUTIONS_BIT_NVX = 4,
        INDEXED_SEQUENCES_BIT_NVX = 8,
    };
    enum IndirectCommandsTokenTypeNVX {
        PIPELINE_NVX = 0,
        DESCRIPTOR_SET_NVX = 1,
        INDEX_BUFFER_NVX = 2,
        VERTEX_BUFFER_NVX = 3,
        PUSH_CONSTANT_NVX = 4,
        DRAW_INDEXED_NVX = 5,
        DRAW_NVX = 6,
        DISPATCH_NVX = 7,
    };
    bitmask ObjectEntryUsageFlagBitsNVX {
        GRAPHICS_BIT_NVX = 1,
        COMPUTE_BIT_NVX = 2,
    };
    enum ObjectEntryTypeNVX {
        DESCRIPTOR_SET_NVX = 0,
        PIPELINE_NVX = 1,
        INDEX_BUFFER_NVX = 2,
        VERTEX_BUFFER_NVX = 3,
        PUSH_CONSTANT_NVX = 4,
    };
    enum DescriptorUpdateTemplateType {
        DESCRIPTOR_SET = 0,
        PUSH_DESCRIPTORS_KHR = 1,
        DESCRIPTOR_SET_KHR = 0,
    };
    enum ViewportCoordinateSwizzleNV {
        POSITIVE_X_NV = 0,
        NEGATIVE_X_NV = 1,
        POSITIVE_Y_NV = 2,
        NEGATIVE_Y_NV = 3,
        POSITIVE_Z_NV = 4,
        NEGATIVE_Z_NV = 5,
        POSITIVE_W_NV = 6,
        NEGATIVE_W_NV = 7,
    };
    enum DiscardRectangleModeEXT {
        INCLUSIVE_EXT = 0,
        EXCLUSIVE_EXT = 1,
    };
    bitmask SubpassDescriptionFlagBits {
        PER_VIEW_ATTRIBUTES_BIT_NVX = 1,
        PER_VIEW_POSITION_X_ONLY_BIT_NVX = 2,
    };
    enum PointClippingBehavior {
        ALL_CLIP_PLANES = 0,
        USER_CLIP_PLANES_ONLY = 1,
        ALL_CLIP_PLANES_KHR = 0,
        USER_CLIP_PLANES_ONLY_KHR = 1,
    };
    enum CoverageModulationModeNV {
        NONE_NV = 0,
        RGB_NV = 1,
        ALPHA_NV = 2,
        RGBA_NV = 3,
    };
    enum ValidationCacheHeaderVersionEXT {
        ONE_EXT = 1,
    };
    enum ShaderInfoTypeAMD {
        STATISTICS_AMD = 0,
        BINARY_AMD = 1,
        DISASSEMBLY_AMD = 2,
    };
    enum QueueGlobalPriorityEXT {
        LOW_EXT = 128,
        MEDIUM_EXT = 256,
        HIGH_EXT = 512,
        REALTIME_EXT = 1024,
    };
    enum TimeDomainEXT {
        DEVICE_EXT = 0,
        CLOCK_MONOTONIC_EXT = 1,
        CLOCK_MONOTONIC_RAW_EXT = 2,
        QUERY_PERFORMANCE_COUNTER_EXT = 3,
    };
    enum ConservativeRasterizationModeEXT {
        DISABLED_EXT = 0,
        OVERESTIMATE_EXT = 1,
        UNDERESTIMATE_EXT = 2,
    };
    bitmask ResolveModeFlagBitsKHR {
        NONE_KHR = 0,
        SAMPLE_ZERO_BIT_KHR = 1,
        AVERAGE_BIT_KHR = 2,
        MIN_BIT_KHR = 4,
        MAX_BIT_KHR = 8,
    };
    bitmask GeometryFlagBitsNV {
        OPAQUE_BIT_NV = 1,
        NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = 2,
    };
    bitmask GeometryInstanceFlagBitsNV {
        TRIANGLE_CULL_DISABLE_BIT_NV = 1,
        TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = 2,
        FORCE_OPAQUE_BIT_NV = 4,
        FORCE_NO_OPAQUE_BIT_NV = 8,
    };
    bitmask BuildAccelerationStructureFlagBitsNV {
        ALLOW_UPDATE_BIT_NV = 1,
        ALLOW_COMPACTION_BIT_NV = 2,
        PREFER_FAST_TRACE_BIT_NV = 4,
        PREFER_FAST_BUILD_BIT_NV = 8,
        LOW_MEMORY_BIT_NV = 16,
    };
    enum CopyAccelerationStructureModeNV {
        CLONE_NV = 0,
        COMPACT_NV = 1,
    };
    enum AccelerationStructureTypeNV {
        TOP_LEVEL_NV = 0,
        BOTTOM_LEVEL_NV = 1,
    };
    enum GeometryTypeNV {
        TRIANGLES_NV = 0,
        AABBS_NV = 1,
    };
    enum RayTracingShaderGroupTypeNV {
        GENERAL_NV = 0,
        TRIANGLES_HIT_GROUP_NV = 1,
        PROCEDURAL_HIT_GROUP_NV = 2,
    };
    enum AccelerationStructureMemoryRequirementsTypeNV {
        OBJECT_NV = 0,
        BUILD_SCRATCH_NV = 1,
        UPDATE_SCRATCH_NV = 2,
    };
    enum MemoryOverallocationBehaviorAMD {
        DEFAULT_AMD = 0,
        ALLOWED_AMD = 1,
        DISALLOWED_AMD = 2,
    };
    enum ScopeNV {
        DEVICE_NV = 1,
        WORKGROUP_NV = 2,
        SUBGROUP_NV = 3,
        QUEUE_FAMILY_NV = 5,
    };
    enum ComponentTypeNV {
        FLOAT16_NV = 0,
        FLOAT32_NV = 1,
        FLOAT64_NV = 2,
        SINT8_NV = 3,
        SINT16_NV = 4,
        SINT32_NV = 5,
        SINT64_NV = 6,
        UINT8_NV = 7,
        UINT16_NV = 8,
        UINT32_NV = 9,
        UINT64_NV = 10,
    };
    bitmask PipelineCreationFeedbackFlagBitsEXT {
        VALID_BIT_EXT = 1,
        APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = 2,
        BASE_PIPELINE_ACCELERATION_BIT_EXT = 4,
    };
    enum ColorSpaceKHR {
        SRGB_NONLINEAR_KHR = 0,
        DISPLAY_P3_NONLINEAR_EXT = 1000104001,
        EXTENDED_SRGB_LINEAR_EXT = 1000104002,
        DCI_P3_LINEAR_EXT = 1000104003,
        DCI_P3_NONLINEAR_EXT = 1000104004,
        BT709_LINEAR_EXT = 1000104005,
        BT709_NONLINEAR_EXT = 1000104006,
        BT2020_LINEAR_EXT = 1000104007,
        HDR10_ST2084_EXT = 1000104008,
        DOLBYVISION_EXT = 1000104009,
        HDR10_HLG_EXT = 1000104010,
        ADOBERGB_LINEAR_EXT = 1000104011,
        ADOBERGB_NONLINEAR_EXT = 1000104012,
        PASS_THROUGH_EXT = 1000104013,
        EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
        DISPLAY_NATIVE_AMD = 1000213000,
        COLORSPACE_SRGB_NONLINEAR_KHR = 0,
    };
    bitmask CompositeAlphaFlagBitsKHR {
        OPAQUE_BIT_KHR = 1,
        PRE_MULTIPLIED_BIT_KHR = 2,
        POST_MULTIPLIED_BIT_KHR = 4,
        INHERIT_BIT_KHR = 8,
    };
    bitmask DisplayPlaneAlphaFlagBitsKHR {
        OPAQUE_BIT_KHR = 1,
        GLOBAL_BIT_KHR = 2,
        PER_PIXEL_BIT_KHR = 4,
        PER_PIXEL_PREMULTIPLIED_BIT_KHR = 8,
    };
    enum PresentModeKHR {
        IMMEDIATE_KHR = 0,
        MAILBOX_KHR = 1,
        FIFO_KHR = 2,
        FIFO_RELAXED_KHR = 3,
        SHARED_DEMAND_REFRESH_KHR = 1000111000,
        SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
    };
    bitmask SurfaceTransformFlagBitsKHR {
        IDENTITY_BIT_KHR = 1,
        ROTATE_90_BIT_KHR = 2,
        ROTATE_180_BIT_KHR = 4,
        ROTATE_270_BIT_KHR = 8,
        HORIZONTAL_MIRROR_BIT_KHR = 16,
        HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 32,
        HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 64,
        HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 128,
        INHERIT_BIT_KHR = 256,
    };
    bitmask DebugReportFlagBitsEXT {
        INFORMATION_BIT_EXT = 1,
        WARNING_BIT_EXT = 2,
        PERFORMANCE_WARNING_BIT_EXT = 4,
        ERROR_BIT_EXT = 8,
        DEBUG_BIT_EXT = 16,
    };
    enum DebugReportObjectTypeEXT {
        UNKNOWN_EXT = 0,
        INSTANCE_EXT = 1,
        PHYSICAL_DEVICE_EXT = 2,
        DEVICE_EXT = 3,
        QUEUE_EXT = 4,
        SEMAPHORE_EXT = 5,
        COMMAND_BUFFER_EXT = 6,
        FENCE_EXT = 7,
        DEVICE_MEMORY_EXT = 8,
        BUFFER_EXT = 9,
        IMAGE_EXT = 10,
        EVENT_EXT = 11,
        QUERY_POOL_EXT = 12,
        BUFFER_VIEW_EXT = 13,
        IMAGE_VIEW_EXT = 14,
        SHADER_MODULE_EXT = 15,
        PIPELINE_CACHE_EXT = 16,
        PIPELINE_LAYOUT_EXT = 17,
        RENDER_PASS_EXT = 18,
        PIPELINE_EXT = 19,
        DESCRIPTOR_SET_LAYOUT_EXT = 20,
        SAMPLER_EXT = 21,
        DESCRIPTOR_POOL_EXT = 22,
        DESCRIPTOR_SET_EXT = 23,
        FRAMEBUFFER_EXT = 24,
        COMMAND_POOL_EXT = 25,
        SURFACE_KHR_EXT = 26,
        SWAPCHAIN_KHR_EXT = 27,
        DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
        DISPLAY_KHR_EXT = 29,
        DISPLAY_MODE_KHR_EXT = 30,
        OBJECT_TABLE_NVX_EXT = 31,
        INDIRECT_COMMANDS_LAYOUT_NVX_EXT = 32,
        VALIDATION_CACHE_EXT_EXT = 33,
        SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
        DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
        ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
        DEBUG_REPORT_EXT = 28,
        VALIDATION_CACHE_EXT = 33,
        DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = 1000085000,
        SAMPLER_YCBCR_CONVERSION_KHR_EXT = 1000156000,
    };
    enum RasterizationOrderAMD {
        STRICT_AMD = 0,
        RELAXED_AMD = 1,
    };
    bitmask ExternalMemoryHandleTypeFlagBitsNV {
        OPAQUE_WIN32_BIT_NV = 1,
        OPAQUE_WIN32_KMT_BIT_NV = 2,
        D3D11_IMAGE_BIT_NV = 4,
        D3D11_IMAGE_KMT_BIT_NV = 8,
    };
    bitmask ExternalMemoryFeatureFlagBitsNV {
        DEDICATED_ONLY_BIT_NV = 1,
        EXPORTABLE_BIT_NV = 2,
        IMPORTABLE_BIT_NV = 4,
    };
    enum ValidationCheckEXT {
        ALL_EXT = 0,
        SHADERS_EXT = 1,
    };
    enum ValidationFeatureEnableEXT {
        GPU_ASSISTED_EXT = 0,
        GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
    };
    enum ValidationFeatureDisableEXT {
        ALL_EXT = 0,
        SHADERS_EXT = 1,
        THREAD_SAFETY_EXT = 2,
        API_PARAMETERS_EXT = 3,
        OBJECT_LIFETIMES_EXT = 4,
        CORE_CHECKS_EXT = 5,
        UNIQUE_HANDLES_EXT = 6,
    };
    bitmask ExternalMemoryHandleTypeFlagBits {
        OPAQUE_FD_BIT = 1,
        OPAQUE_WIN32_BIT = 2,
        OPAQUE_WIN32_KMT_BIT = 4,
        D3D11_TEXTURE_BIT = 8,
        D3D11_TEXTURE_KMT_BIT = 16,
        D3D12_HEAP_BIT = 32,
        D3D12_RESOURCE_BIT = 64,
        DMA_BUF_BIT_EXT = 512,
        ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 1024,
        HOST_ALLOCATION_BIT_EXT = 128,
        HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 256,
        OPAQUE_FD_BIT_KHR = 1,
        OPAQUE_WIN32_BIT_KHR = 2,
        OPAQUE_WIN32_KMT_BIT_KHR = 4,
        D3D11_TEXTURE_BIT_KHR = 8,
        D3D11_TEXTURE_KMT_BIT_KHR = 16,
        D3D12_HEAP_BIT_KHR = 32,
        D3D12_RESOURCE_BIT_KHR = 64,
    };
    bitmask ExternalMemoryFeatureFlagBits {
        DEDICATED_ONLY_BIT = 1,
        EXPORTABLE_BIT = 2,
        IMPORTABLE_BIT = 4,
        DEDICATED_ONLY_BIT_KHR = 1,
        EXPORTABLE_BIT_KHR = 2,
        IMPORTABLE_BIT_KHR = 4,
    };
    bitmask ExternalSemaphoreHandleTypeFlagBits {
        OPAQUE_FD_BIT = 1,
        OPAQUE_WIN32_BIT = 2,
        OPAQUE_WIN32_KMT_BIT = 4,
        D3D12_FENCE_BIT = 8,
        SYNC_FD_BIT = 16,
        OPAQUE_FD_BIT_KHR = 1,
        OPAQUE_WIN32_BIT_KHR = 2,
        OPAQUE_WIN32_KMT_BIT_KHR = 4,
        D3D12_FENCE_BIT_KHR = 8,
        SYNC_FD_BIT_KHR = 16,
    };
    bitmask ExternalSemaphoreFeatureFlagBits {
        EXPORTABLE_BIT = 1,
        IMPORTABLE_BIT = 2,
        EXPORTABLE_BIT_KHR = 1,
        IMPORTABLE_BIT_KHR = 2,
    };
    bitmask SemaphoreImportFlagBits {
        TEMPORARY_BIT = 1,
        TEMPORARY_BIT_KHR = 1,
    };
    bitmask ExternalFenceHandleTypeFlagBits {
        OPAQUE_FD_BIT = 1,
        OPAQUE_WIN32_BIT = 2,
        OPAQUE_WIN32_KMT_BIT = 4,
        SYNC_FD_BIT = 8,
        OPAQUE_FD_BIT_KHR = 1,
        OPAQUE_WIN32_BIT_KHR = 2,
        OPAQUE_WIN32_KMT_BIT_KHR = 4,
        SYNC_FD_BIT_KHR = 8,
    };
    bitmask ExternalFenceFeatureFlagBits {
        EXPORTABLE_BIT = 1,
        IMPORTABLE_BIT = 2,
        EXPORTABLE_BIT_KHR = 1,
        IMPORTABLE_BIT_KHR = 2,
    };
    bitmask FenceImportFlagBits {
        TEMPORARY_BIT = 1,
        TEMPORARY_BIT_KHR = 1,
    };
    bitmask SurfaceCounterFlagBitsEXT {
        VBLANK_EXT = 1,
    };
    enum DisplayPowerStateEXT {
        OFF_EXT = 0,
        SUSPEND_EXT = 1,
        ON_EXT = 2,
    };
    enum DeviceEventTypeEXT {
        DISPLAY_HOTPLUG_EXT = 0,
    };
    enum DisplayEventTypeEXT {
        FIRST_PIXEL_OUT_EXT = 0,
    };
    bitmask PeerMemoryFeatureFlagBits {
        COPY_SRC_BIT = 1,
        COPY_DST_BIT = 2,
        GENERIC_SRC_BIT = 4,
        GENERIC_DST_BIT = 8,
        COPY_SRC_BIT_KHR = 1,
        COPY_DST_BIT_KHR = 2,
        GENERIC_SRC_BIT_KHR = 4,
        GENERIC_DST_BIT_KHR = 8,
    };
    bitmask MemoryAllocateFlagBits {
        DEVICE_MASK_BIT = 1,
        DEVICE_MASK_BIT_KHR = 1,
    };
    bitmask DeviceGroupPresentModeFlagBitsKHR {
        LOCAL_BIT_KHR = 1,
        REMOTE_BIT_KHR = 2,
        SUM_BIT_KHR = 4,
        LOCAL_MULTI_DEVICE_BIT_KHR = 8,
    };
    bitmask SwapchainCreateFlagBitsKHR {
        SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 1,
        PROTECTED_BIT_KHR = 2,
        MUTABLE_FORMAT_BIT_KHR = 4,
    };
    bitmask SubgroupFeatureFlagBits {
        BASIC_BIT = 1,
        VOTE_BIT = 2,
        ARITHMETIC_BIT = 4,
        BALLOT_BIT = 8,
        SHUFFLE_BIT = 16,
        SHUFFLE_RELATIVE_BIT = 32,
        CLUSTERED_BIT = 64,
        QUAD_BIT = 128,
        PARTITIONED_BIT_NV = 256,
    };
    enum TessellationDomainOrigin {
        UPPER_LEFT = 0,
        LOWER_LEFT = 1,
        UPPER_LEFT_KHR = 0,
        LOWER_LEFT_KHR = 1,
    };
    enum SamplerYcbcrModelConversion {
        RGB_IDENTITY = 0,
        YCBCR_IDENTITY = 1,
        YCBCR_709 = 2,
        YCBCR_601 = 3,
        YCBCR_2020 = 4,
        RGB_IDENTITY_KHR = 0,
        YCBCR_IDENTITY_KHR = 1,
        YCBCR_709_KHR = 2,
        YCBCR_601_KHR = 3,
        YCBCR_2020_KHR = 4,
    };
    enum SamplerYcbcrRange {
        ITU_FULL = 0,
        ITU_NARROW = 1,
        ITU_FULL_KHR = 0,
        ITU_NARROW_KHR = 1,
    };
    enum ChromaLocation {
        COSITED_EVEN = 0,
        MIDPOINT = 1,
        COSITED_EVEN_KHR = 0,
        MIDPOINT_KHR = 1,
    };
    enum SamplerReductionModeEXT {
        WEIGHTED_AVERAGE_EXT = 0,
        MIN_EXT = 1,
        MAX_EXT = 2,
    };
    enum BlendOverlapEXT {
        UNCORRELATED_EXT = 0,
        DISJOINT_EXT = 1,
        CONJOINT_EXT = 2,
    };
    bitmask DebugUtilsMessageSeverityFlagBitsEXT {
        VERBOSE_BIT_EXT = 1,
        INFO_BIT_EXT = 16,
        WARNING_BIT_EXT = 256,
        ERROR_BIT_EXT = 4096,
    };
    bitmask DebugUtilsMessageTypeFlagBitsEXT {
        GENERAL_BIT_EXT = 1,
        VALIDATION_BIT_EXT = 2,
        PERFORMANCE_BIT_EXT = 4,
    };
    enum FullScreenExclusiveEXT {
        DEFAULT_EXT = 0,
        ALLOWED_EXT = 1,
        DISALLOWED_EXT = 2,
        APPLICATION_CONTROLLED_EXT = 3,
    };
    enum VendorId {
        VIV = 65537,
        VSI = 65538,
        KAZAN = 65539,
    };
    enum DriverIdKHR {
        AMD_PROPRIETARY_KHR = 1,
        AMD_OPEN_SOURCE_KHR = 2,
        MESA_RADV_KHR = 3,
        NVIDIA_PROPRIETARY_KHR = 4,
        INTEL_PROPRIETARY_WINDOWS_KHR = 5,
        INTEL_OPEN_SOURCE_MESA_KHR = 6,
        IMAGINATION_PROPRIETARY_KHR = 7,
        QUALCOMM_PROPRIETARY_KHR = 8,
        ARM_PROPRIETARY_KHR = 9,
        GOOGLE_PASTEL_KHR = 10,
        GGP_PROPRIETARY_KHR = 11,
    };
    enum ShadingRatePaletteEntryNV {
        NO_INVOCATIONS_NV = 0,
        _16_INVOCATIONS_PER_PIXEL_NV = 1,
        _8_INVOCATIONS_PER_PIXEL_NV = 2,
        _4_INVOCATIONS_PER_PIXEL_NV = 3,
        _2_INVOCATIONS_PER_PIXEL_NV = 4,
        _1_INVOCATION_PER_PIXEL_NV = 5,
        _1_INVOCATION_PER_2X1_PIXELS_NV = 6,
        _1_INVOCATION_PER_1X2_PIXELS_NV = 7,
        _1_INVOCATION_PER_2X2_PIXELS_NV = 8,
        _1_INVOCATION_PER_4X2_PIXELS_NV = 9,
        _1_INVOCATION_PER_2X4_PIXELS_NV = 10,
        _1_INVOCATION_PER_4X4_PIXELS_NV = 11,
    };
    enum CoarseSampleOrderTypeNV {
        DEFAULT_NV = 0,
        CUSTOM_NV = 1,
        PIXEL_MAJOR_NV = 2,
        SAMPLE_MAJOR_NV = 3,
    };
}

impl_aliases! {
    SampleMask = u32;
    Bool32 = u32;
    Flags = u32;
    DeviceSize = u64;
    DeviceAddress = u64;
    SamplerCreateFlags = crate::data::SamplerCreateFlagBits;
    DescriptorSetLayoutCreateFlags = crate::data::DescriptorSetLayoutCreateFlagBits;
    DeviceQueueCreateFlags = crate::data::DeviceQueueCreateFlagBits;
    QueueFlags = crate::data::QueueFlagBits;
    MemoryPropertyFlags = crate::data::MemoryPropertyFlagBits;
    MemoryHeapFlags = crate::data::MemoryHeapFlagBits;
    AccessFlags = crate::data::AccessFlagBits;
    BufferUsageFlags = crate::data::BufferUsageFlagBits;
    BufferCreateFlags = crate::data::BufferCreateFlagBits;
    ShaderStageFlags = crate::data::ShaderStageFlagBits;
    ImageUsageFlags = crate::data::ImageUsageFlagBits;
    ImageCreateFlags = crate::data::ImageCreateFlagBits;
    ImageViewCreateFlags = crate::data::ImageViewCreateFlagBits;
    PipelineCreateFlags = crate::data::PipelineCreateFlagBits;
    ColorComponentFlags = crate::data::ColorComponentFlagBits;
    FenceCreateFlags = crate::data::FenceCreateFlagBits;
    FormatFeatureFlags = crate::data::FormatFeatureFlagBits;
    QueryControlFlags = crate::data::QueryControlFlagBits;
    QueryResultFlags = crate::data::QueryResultFlagBits;
    CommandPoolCreateFlags = crate::data::CommandPoolCreateFlagBits;
    CommandPoolResetFlags = crate::data::CommandPoolResetFlagBits;
    CommandBufferResetFlags = crate::data::CommandBufferResetFlagBits;
    CommandBufferUsageFlags = crate::data::CommandBufferUsageFlagBits;
    QueryPipelineStatisticFlags = crate::data::QueryPipelineStatisticFlagBits;
    ImageAspectFlags = crate::data::ImageAspectFlagBits;
    SparseMemoryBindFlags = crate::data::SparseMemoryBindFlagBits;
    SparseImageFormatFlags = crate::data::SparseImageFormatFlagBits;
    SubpassDescriptionFlags = crate::data::SubpassDescriptionFlagBits;
    PipelineStageFlags = crate::data::PipelineStageFlagBits;
    SampleCountFlags = crate::data::SampleCountFlagBits;
    AttachmentDescriptionFlags = crate::data::AttachmentDescriptionFlagBits;
    StencilFaceFlags = crate::data::StencilFaceFlagBits;
    CullModeFlags = crate::data::CullModeFlagBits;
    DescriptorPoolCreateFlags = crate::data::DescriptorPoolCreateFlagBits;
    DependencyFlags = crate::data::DependencyFlagBits;
    SubgroupFeatureFlags = crate::data::SubgroupFeatureFlagBits;
    IndirectCommandsLayoutUsageFlagsNVX = crate::data::IndirectCommandsLayoutUsageFlagBitsNVX;
    ObjectEntryUsageFlagsNVX = crate::data::ObjectEntryUsageFlagBitsNVX;
    GeometryFlagsNV = crate::data::GeometryFlagBitsNV;
    GeometryInstanceFlagsNV = crate::data::GeometryInstanceFlagBitsNV;
    BuildAccelerationStructureFlagsNV = crate::data::BuildAccelerationStructureFlagBitsNV;
    DescriptorUpdateTemplateCreateFlagsKHR = crate::data::DescriptorUpdateTemplateCreateFlags;
    PipelineCreationFeedbackFlagsEXT = crate::data::PipelineCreationFeedbackFlagBitsEXT;
    CompositeAlphaFlagsKHR = crate::data::CompositeAlphaFlagBitsKHR;
    DisplayPlaneAlphaFlagsKHR = crate::data::DisplayPlaneAlphaFlagBitsKHR;
    SurfaceTransformFlagsKHR = crate::data::SurfaceTransformFlagBitsKHR;
    SwapchainCreateFlagsKHR = crate::data::SwapchainCreateFlagBitsKHR;
    PeerMemoryFeatureFlags = crate::data::PeerMemoryFeatureFlagBits;
    PeerMemoryFeatureFlagsKHR = crate::data::PeerMemoryFeatureFlags;
    MemoryAllocateFlags = crate::data::MemoryAllocateFlagBits;
    MemoryAllocateFlagsKHR = crate::data::MemoryAllocateFlags;
    DeviceGroupPresentModeFlagsKHR = crate::data::DeviceGroupPresentModeFlagBitsKHR;
    DebugReportFlagsEXT = crate::data::DebugReportFlagBitsEXT;
    CommandPoolTrimFlagsKHR = crate::data::CommandPoolTrimFlags;
    ExternalMemoryHandleTypeFlagsNV = crate::data::ExternalMemoryHandleTypeFlagBitsNV;
    ExternalMemoryFeatureFlagsNV = crate::data::ExternalMemoryFeatureFlagBitsNV;
    ExternalMemoryHandleTypeFlags = crate::data::ExternalMemoryHandleTypeFlagBits;
    ExternalMemoryHandleTypeFlagsKHR = crate::data::ExternalMemoryHandleTypeFlags;
    ExternalMemoryFeatureFlags = crate::data::ExternalMemoryFeatureFlagBits;
    ExternalMemoryFeatureFlagsKHR = crate::data::ExternalMemoryFeatureFlags;
    ExternalSemaphoreHandleTypeFlags = crate::data::ExternalSemaphoreHandleTypeFlagBits;
    ExternalSemaphoreHandleTypeFlagsKHR = crate::data::ExternalSemaphoreHandleTypeFlags;
    ExternalSemaphoreFeatureFlags = crate::data::ExternalSemaphoreFeatureFlagBits;
    ExternalSemaphoreFeatureFlagsKHR = crate::data::ExternalSemaphoreFeatureFlags;
    SemaphoreImportFlags = crate::data::SemaphoreImportFlagBits;
    SemaphoreImportFlagsKHR = crate::data::SemaphoreImportFlags;
    ExternalFenceHandleTypeFlags = crate::data::ExternalFenceHandleTypeFlagBits;
    ExternalFenceHandleTypeFlagsKHR = crate::data::ExternalFenceHandleTypeFlags;
    ExternalFenceFeatureFlags = crate::data::ExternalFenceFeatureFlagBits;
    ExternalFenceFeatureFlagsKHR = crate::data::ExternalFenceFeatureFlags;
    FenceImportFlags = crate::data::FenceImportFlagBits;
    FenceImportFlagsKHR = crate::data::FenceImportFlags;
    SurfaceCounterFlagsEXT = crate::data::SurfaceCounterFlagBitsEXT;
    DebugUtilsMessageSeverityFlagsEXT = crate::data::DebugUtilsMessageSeverityFlagBitsEXT;
    DebugUtilsMessageTypeFlagsEXT = crate::data::DebugUtilsMessageTypeFlagBitsEXT;
    DescriptorBindingFlagsEXT = crate::data::DescriptorBindingFlagBitsEXT;
    ConditionalRenderingFlagsEXT = crate::data::ConditionalRenderingFlagBitsEXT;
    ResolveModeFlagsKHR = crate::data::ResolveModeFlagBitsKHR;
    DescriptorUpdateTemplateKHR = crate::data::DescriptorUpdateTemplate;
    SamplerYcbcrConversionKHR = crate::data::SamplerYcbcrConversion;
    DescriptorUpdateTemplateTypeKHR = crate::data::DescriptorUpdateTemplateType;
    PointClippingBehaviorKHR = crate::data::PointClippingBehavior;
    ExternalMemoryHandleTypeFlagBitsKHR = crate::data::ExternalMemoryHandleTypeFlagBits;
    ExternalMemoryFeatureFlagBitsKHR = crate::data::ExternalMemoryFeatureFlagBits;
    ExternalSemaphoreHandleTypeFlagBitsKHR = crate::data::ExternalSemaphoreHandleTypeFlagBits;
    ExternalSemaphoreFeatureFlagBitsKHR = crate::data::ExternalSemaphoreFeatureFlagBits;
    SemaphoreImportFlagBitsKHR = crate::data::SemaphoreImportFlagBits;
    ExternalFenceHandleTypeFlagBitsKHR = crate::data::ExternalFenceHandleTypeFlagBits;
    ExternalFenceFeatureFlagBitsKHR = crate::data::ExternalFenceFeatureFlagBits;
    FenceImportFlagBitsKHR = crate::data::FenceImportFlagBits;
    PeerMemoryFeatureFlagBitsKHR = crate::data::PeerMemoryFeatureFlagBits;
    MemoryAllocateFlagBitsKHR = crate::data::MemoryAllocateFlagBits;
    TessellationDomainOriginKHR = crate::data::TessellationDomainOrigin;
    SamplerYcbcrModelConversionKHR = crate::data::SamplerYcbcrModelConversion;
    SamplerYcbcrRangeKHR = crate::data::SamplerYcbcrRange;
    ChromaLocationKHR = crate::data::ChromaLocation;
    PhysicalDeviceFeatures2KHR = crate::data::PhysicalDeviceFeatures2;
    PhysicalDeviceProperties2KHR = crate::data::PhysicalDeviceProperties2;
    FormatProperties2KHR = crate::data::FormatProperties2;
    ImageFormatProperties2KHR = crate::data::ImageFormatProperties2;
    PhysicalDeviceImageFormatInfo2KHR = crate::data::PhysicalDeviceImageFormatInfo2;
    QueueFamilyProperties2KHR = crate::data::QueueFamilyProperties2;
    PhysicalDeviceMemoryProperties2KHR = crate::data::PhysicalDeviceMemoryProperties2;
    SparseImageFormatProperties2KHR = crate::data::SparseImageFormatProperties2;
    PhysicalDeviceSparseImageFormatInfo2KHR = crate::data::PhysicalDeviceSparseImageFormatInfo2;
    PhysicalDeviceVariablePointerFeaturesKHR = crate::data::PhysicalDeviceVariablePointerFeatures;
    ExternalMemoryPropertiesKHR = crate::data::ExternalMemoryProperties;
    PhysicalDeviceExternalImageFormatInfoKHR = crate::data::PhysicalDeviceExternalImageFormatInfo;
    ExternalImageFormatPropertiesKHR = crate::data::ExternalImageFormatProperties;
    PhysicalDeviceExternalBufferInfoKHR = crate::data::PhysicalDeviceExternalBufferInfo;
    ExternalBufferPropertiesKHR = crate::data::ExternalBufferProperties;
    PhysicalDeviceIDPropertiesKHR = crate::data::PhysicalDeviceIDProperties;
    ExternalMemoryImageCreateInfoKHR = crate::data::ExternalMemoryImageCreateInfo;
    ExternalMemoryBufferCreateInfoKHR = crate::data::ExternalMemoryBufferCreateInfo;
    ExportMemoryAllocateInfoKHR = crate::data::ExportMemoryAllocateInfo;
    PhysicalDeviceExternalSemaphoreInfoKHR = crate::data::PhysicalDeviceExternalSemaphoreInfo;
    ExternalSemaphorePropertiesKHR = crate::data::ExternalSemaphoreProperties;
    ExportSemaphoreCreateInfoKHR = crate::data::ExportSemaphoreCreateInfo;
    PhysicalDeviceExternalFenceInfoKHR = crate::data::PhysicalDeviceExternalFenceInfo;
    ExternalFencePropertiesKHR = crate::data::ExternalFenceProperties;
    ExportFenceCreateInfoKHR = crate::data::ExportFenceCreateInfo;
    PhysicalDeviceMultiviewFeaturesKHR = crate::data::PhysicalDeviceMultiviewFeatures;
    PhysicalDeviceMultiviewPropertiesKHR = crate::data::PhysicalDeviceMultiviewProperties;
    RenderPassMultiviewCreateInfoKHR = crate::data::RenderPassMultiviewCreateInfo;
    PhysicalDeviceGroupPropertiesKHR = crate::data::PhysicalDeviceGroupProperties;
    MemoryAllocateFlagsInfoKHR = crate::data::MemoryAllocateFlagsInfo;
    BindBufferMemoryInfoKHR = crate::data::BindBufferMemoryInfo;
    BindBufferMemoryDeviceGroupInfoKHR = crate::data::BindBufferMemoryDeviceGroupInfo;
    BindImageMemoryInfoKHR = crate::data::BindImageMemoryInfo;
    BindImageMemoryDeviceGroupInfoKHR = crate::data::BindImageMemoryDeviceGroupInfo;
    DeviceGroupRenderPassBeginInfoKHR = crate::data::DeviceGroupRenderPassBeginInfo;
    DeviceGroupCommandBufferBeginInfoKHR = crate::data::DeviceGroupCommandBufferBeginInfo;
    DeviceGroupSubmitInfoKHR = crate::data::DeviceGroupSubmitInfo;
    DeviceGroupBindSparseInfoKHR = crate::data::DeviceGroupBindSparseInfo;
    DeviceGroupDeviceCreateInfoKHR = crate::data::DeviceGroupDeviceCreateInfo;
    DescriptorUpdateTemplateEntryKHR = crate::data::DescriptorUpdateTemplateEntry;
    DescriptorUpdateTemplateCreateInfoKHR = crate::data::DescriptorUpdateTemplateCreateInfo;
    InputAttachmentAspectReferenceKHR = crate::data::InputAttachmentAspectReference;
    RenderPassInputAttachmentAspectCreateInfoKHR = crate::data::RenderPassInputAttachmentAspectCreateInfo;
    PhysicalDevice16BitStorageFeaturesKHR = crate::data::PhysicalDevice16BitStorageFeatures;
    BufferMemoryRequirementsInfo2KHR = crate::data::BufferMemoryRequirementsInfo2;
    ImageMemoryRequirementsInfo2KHR = crate::data::ImageMemoryRequirementsInfo2;
    ImageSparseMemoryRequirementsInfo2KHR = crate::data::ImageSparseMemoryRequirementsInfo2;
    MemoryRequirements2KHR = crate::data::MemoryRequirements2;
    SparseImageMemoryRequirements2KHR = crate::data::SparseImageMemoryRequirements2;
    PhysicalDevicePointClippingPropertiesKHR = crate::data::PhysicalDevicePointClippingProperties;
    MemoryDedicatedRequirementsKHR = crate::data::MemoryDedicatedRequirements;
    MemoryDedicatedAllocateInfoKHR = crate::data::MemoryDedicatedAllocateInfo;
    ImageViewUsageCreateInfoKHR = crate::data::ImageViewUsageCreateInfo;
    PipelineTessellationDomainOriginStateCreateInfoKHR = crate::data::PipelineTessellationDomainOriginStateCreateInfo;
    SamplerYcbcrConversionInfoKHR = crate::data::SamplerYcbcrConversionInfo;
    SamplerYcbcrConversionCreateInfoKHR = crate::data::SamplerYcbcrConversionCreateInfo;
    BindImagePlaneMemoryInfoKHR = crate::data::BindImagePlaneMemoryInfo;
    ImagePlaneMemoryRequirementsInfoKHR = crate::data::ImagePlaneMemoryRequirementsInfo;
    PhysicalDeviceSamplerYcbcrConversionFeaturesKHR = crate::data::PhysicalDeviceSamplerYcbcrConversionFeatures;
    SamplerYcbcrConversionImageFormatPropertiesKHR = crate::data::SamplerYcbcrConversionImageFormatProperties;
    PhysicalDeviceMaintenance3PropertiesKHR = crate::data::PhysicalDeviceMaintenance3Properties;
    DescriptorSetLayoutSupportKHR = crate::data::DescriptorSetLayoutSupport;
}

impl_handles! {
    Instance { dispatchable: true };
    PhysicalDevice { dispatchable: true };
    Device { dispatchable: true };
    Queue { dispatchable: true };
    CommandBuffer { dispatchable: true };
    DeviceMemory { dispatchable: false };
    CommandPool { dispatchable: false };
    Buffer { dispatchable: false };
    BufferView { dispatchable: false };
    Image { dispatchable: false };
    ImageView { dispatchable: false };
    ShaderModule { dispatchable: false };
    Pipeline { dispatchable: false };
    PipelineLayout { dispatchable: false };
    Sampler { dispatchable: false };
    DescriptorSet { dispatchable: false };
    DescriptorSetLayout { dispatchable: false };
    DescriptorPool { dispatchable: false };
    Fence { dispatchable: false };
    Semaphore { dispatchable: false };
    Event { dispatchable: false };
    QueryPool { dispatchable: false };
    Framebuffer { dispatchable: false };
    RenderPass { dispatchable: false };
    PipelineCache { dispatchable: false };
    ObjectTableNVX { dispatchable: false };
    IndirectCommandsLayoutNVX { dispatchable: false };
    DescriptorUpdateTemplate { dispatchable: false };
    SamplerYcbcrConversion { dispatchable: false };
    ValidationCacheEXT { dispatchable: false };
    AccelerationStructureNV { dispatchable: false };
    DisplayKHR { dispatchable: false };
    DisplayModeKHR { dispatchable: false };
    SurfaceKHR { dispatchable: false };
    SwapchainKHR { dispatchable: false };
    DebugReportCallbackEXT { dispatchable: false };
    DebugUtilsMessengerEXT { dispatchable: false };
}

impl_func_pointers! {
    InternalAllocationNotification(
        p_user_data: *mut c_void,
        size: usize,
        allocation_type: crate::data::InternalAllocationType,
        allocation_scope: crate::data::SystemAllocationScope,
    );
    InternalFreeNotification(
        p_user_data: *mut c_void,
        size: usize,
        allocation_type: crate::data::InternalAllocationType,
        allocation_scope: crate::data::SystemAllocationScope,
    );
    ReallocationFunction(
        p_user_data: *mut c_void,
        p_original: *mut c_void,
        size: usize,
        alignment: usize,
        allocation_scope: crate::data::SystemAllocationScope,
    ) -> *mut c_void;
    AllocationFunction(
        p_user_data: *mut c_void,
        size: usize,
        alignment: usize,
        allocation_scope: crate::data::SystemAllocationScope,
    ) -> *mut c_void;
    FreeFunction(
        p_user_data: *mut c_void,
        p_memory: *mut c_void,
    );
    VoidFunction(
    );
    DebugReportCallbackEXT(
        flags: crate::data::DebugReportFlagsEXT,
        object_type: crate::data::DebugReportObjectTypeEXT,
        object: u64,
        location: usize,
        message_code: i32,
        p_layer_prefix: *const c_char,
        p_message: *const c_char,
        p_user_data: *mut c_void,
    ) -> crate::data::Bool32;
    DebugUtilsMessengerCallbackEXT(
        message_severity: crate::data::DebugUtilsMessageSeverityFlagBitsEXT,
        message_types: crate::data::DebugUtilsMessageTypeFlagsEXT,
        p_callback_data: *const crate::data::DebugUtilsMessengerCallbackDataEXT,
        p_user_data: *mut c_void,
    ) -> crate::data::Bool32;
}

impl_aggregates! {
    struct BaseOutStructure {
        s_type: crate::data::StructureType,
        p_next: *mut crate::data::BaseOutStructure,
    };
    struct BaseInStructure {
        s_type: crate::data::StructureType,
        p_next: *const crate::data::BaseInStructure,
    };
    struct Offset2D {
        x: i32,
        y: i32,
    };
    struct Offset3D {
        x: i32,
        y: i32,
        z: i32,
    };
    struct Extent2D {
        width: u32,
        height: u32,
    };
    struct Extent3D {
        width: u32,
        height: u32,
        depth: u32,
    };
    struct Viewport {
        x: c_float,
        y: c_float,
        width: c_float,
        height: c_float,
        min_depth: c_float,
        max_depth: c_float,
    };
    struct Rect2D {
        offset: crate::data::Offset2D,
        extent: crate::data::Extent2D,
    };
    struct ClearRect {
        rect: crate::data::Rect2D,
        base_array_layer: u32,
        layer_count: u32,
    };
    struct ComponentMapping {
        r: crate::data::ComponentSwizzle,
        g: crate::data::ComponentSwizzle,
        b: crate::data::ComponentSwizzle,
        a: crate::data::ComponentSwizzle,
    };
    struct PhysicalDeviceProperties {
        api_version: u32,
        driver_version: u32,
        vendor_id: u32,
        device_id: u32,
        device_type: crate::data::PhysicalDeviceType,
        device_name: [c_char; 256],
        pipeline_cache_uuid: [u8; 16],
        limits: crate::data::PhysicalDeviceLimits,
        sparse_properties: crate::data::PhysicalDeviceSparseProperties,
    };
    struct ExtensionProperties {
        extension_name: [c_char; 256],
        spec_version: u32,
    };
    struct LayerProperties {
        layer_name: [c_char; 256],
        spec_version: u32,
        implementation_version: u32,
        description: [c_char; 256],
    };
    struct ApplicationInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::APPLICATION_INFO,
        p_next: *const c_void,
        p_application_name: *const c_char,
        application_version: u32,
        p_engine_name: *const c_char,
        engine_version: u32,
        api_version: u32,
    };
    struct AllocationCallbacks {
        p_user_data: *mut c_void,
        pfn_allocation: crate::pfn::AllocationFunction,
        pfn_reallocation: crate::pfn::ReallocationFunction,
        pfn_free: crate::pfn::FreeFunction,
        pfn_internal_allocation: crate::pfn::InternalAllocationNotification,
        pfn_internal_free: crate::pfn::InternalFreeNotification,
    };
    struct DeviceQueueCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_QUEUE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::DeviceQueueCreateFlags,
        queue_family_index: u32,
        queue_count: u32,
        p_queue_priorities: *const c_float,
    };
    struct DeviceCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::DeviceCreateFlags,
        queue_create_info_count: u32,
        p_queue_create_infos: *const crate::data::DeviceQueueCreateInfo,
        enabled_layer_count: u32,
        pp_enabled_layer_names: *const *const c_char,
        enabled_extension_count: u32,
        pp_enabled_extension_names: *const *const c_char,
        p_enabled_features: *const crate::data::PhysicalDeviceFeatures,
    };
    struct InstanceCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::INSTANCE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::InstanceCreateFlags,
        p_application_info: *const crate::data::ApplicationInfo,
        enabled_layer_count: u32,
        pp_enabled_layer_names: *const *const c_char,
        enabled_extension_count: u32,
        pp_enabled_extension_names: *const *const c_char,
    };
    struct QueueFamilyProperties {
        queue_flags: crate::data::QueueFlags,
        queue_count: u32,
        timestamp_valid_bits: u32,
        min_image_transfer_granularity: crate::data::Extent3D,
    };
    struct PhysicalDeviceMemoryProperties {
        memory_type_count: u32,
        memory_types: [crate::data::MemoryType; 32],
        memory_heap_count: u32,
        memory_heaps: [crate::data::MemoryHeap; 16],
    };
    struct MemoryAllocateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_ALLOCATE_INFO,
        p_next: *const c_void,
        allocation_size: crate::data::DeviceSize,
        memory_type_index: u32,
    };
    struct MemoryRequirements {
        size: crate::data::DeviceSize,
        alignment: crate::data::DeviceSize,
        memory_type_bits: u32,
    };
    struct SparseImageFormatProperties {
        aspect_mask: crate::data::ImageAspectFlags,
        image_granularity: crate::data::Extent3D,
        flags: crate::data::SparseImageFormatFlags,
    };
    struct SparseImageMemoryRequirements {
        format_properties: crate::data::SparseImageFormatProperties,
        image_mip_tail_first_lod: u32,
        image_mip_tail_size: crate::data::DeviceSize,
        image_mip_tail_offset: crate::data::DeviceSize,
        image_mip_tail_stride: crate::data::DeviceSize,
    };
    struct MemoryType {
        property_flags: crate::data::MemoryPropertyFlags,
        heap_index: u32,
    };
    struct MemoryHeap {
        size: crate::data::DeviceSize,
        flags: crate::data::MemoryHeapFlags,
    };
    struct MappedMemoryRange {
        s_type: crate::data::StructureType = crate::data::StructureType::MAPPED_MEMORY_RANGE,
        p_next: *const c_void,
        memory: crate::data::DeviceMemory,
        offset: crate::data::DeviceSize,
        size: crate::data::DeviceSize,
    };
    struct FormatProperties {
        linear_tiling_features: crate::data::FormatFeatureFlags,
        optimal_tiling_features: crate::data::FormatFeatureFlags,
        buffer_features: crate::data::FormatFeatureFlags,
    };
    struct ImageFormatProperties {
        max_extent: crate::data::Extent3D,
        max_mip_levels: u32,
        max_array_layers: u32,
        sample_counts: crate::data::SampleCountFlags,
        max_resource_size: crate::data::DeviceSize,
    };
    struct DescriptorBufferInfo {
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        range: crate::data::DeviceSize,
    };
    struct DescriptorImageInfo {
        sampler: crate::data::Sampler,
        image_view: crate::data::ImageView,
        image_layout: crate::data::ImageLayout,
    };
    struct WriteDescriptorSet {
        s_type: crate::data::StructureType = crate::data::StructureType::WRITE_DESCRIPTOR_SET,
        p_next: *const c_void,
        dst_set: crate::data::DescriptorSet,
        dst_binding: u32,
        dst_array_element: u32,
        descriptor_count: u32,
        descriptor_type: crate::data::DescriptorType,
        p_image_info: *const crate::data::DescriptorImageInfo,
        p_buffer_info: *const crate::data::DescriptorBufferInfo,
        p_texel_buffer_view: *const crate::data::BufferView,
    };
    struct CopyDescriptorSet {
        s_type: crate::data::StructureType = crate::data::StructureType::COPY_DESCRIPTOR_SET,
        p_next: *const c_void,
        src_set: crate::data::DescriptorSet,
        src_binding: u32,
        src_array_element: u32,
        dst_set: crate::data::DescriptorSet,
        dst_binding: u32,
        dst_array_element: u32,
        descriptor_count: u32,
    };
    struct BufferCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::BufferCreateFlags,
        size: crate::data::DeviceSize,
        usage: crate::data::BufferUsageFlags,
        sharing_mode: crate::data::SharingMode,
        queue_family_index_count: u32,
        p_queue_family_indices: *const u32,
    };
    struct BufferViewCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_VIEW_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::BufferViewCreateFlags,
        buffer: crate::data::Buffer,
        format: crate::data::Format,
        offset: crate::data::DeviceSize,
        range: crate::data::DeviceSize,
    };
    struct ImageSubresource {
        aspect_mask: crate::data::ImageAspectFlags,
        mip_level: u32,
        array_layer: u32,
    };
    struct ImageSubresourceLayers {
        aspect_mask: crate::data::ImageAspectFlags,
        mip_level: u32,
        base_array_layer: u32,
        layer_count: u32,
    };
    struct ImageSubresourceRange {
        aspect_mask: crate::data::ImageAspectFlags,
        base_mip_level: u32,
        level_count: u32,
        base_array_layer: u32,
        layer_count: u32,
    };
    struct MemoryBarrier {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_BARRIER,
        p_next: *const c_void,
        src_access_mask: crate::data::AccessFlags,
        dst_access_mask: crate::data::AccessFlags,
    };
    struct BufferMemoryBarrier {
        s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_MEMORY_BARRIER,
        p_next: *const c_void,
        src_access_mask: crate::data::AccessFlags,
        dst_access_mask: crate::data::AccessFlags,
        src_queue_family_index: u32,
        dst_queue_family_index: u32,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        size: crate::data::DeviceSize,
    };
    struct ImageMemoryBarrier {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_MEMORY_BARRIER,
        p_next: *const c_void,
        src_access_mask: crate::data::AccessFlags,
        dst_access_mask: crate::data::AccessFlags,
        old_layout: crate::data::ImageLayout,
        new_layout: crate::data::ImageLayout,
        src_queue_family_index: u32,
        dst_queue_family_index: u32,
        image: crate::data::Image,
        subresource_range: crate::data::ImageSubresourceRange,
    };
    struct ImageCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::ImageCreateFlags,
        image_type: crate::data::ImageType,
        format: crate::data::Format,
        extent: crate::data::Extent3D,
        mip_levels: u32,
        array_layers: u32,
        samples: crate::data::SampleCountFlagBits,
        tiling: crate::data::ImageTiling,
        usage: crate::data::ImageUsageFlags,
        sharing_mode: crate::data::SharingMode,
        queue_family_index_count: u32,
        p_queue_family_indices: *const u32,
        initial_layout: crate::data::ImageLayout,
    };
    struct SubresourceLayout {
        offset: crate::data::DeviceSize,
        size: crate::data::DeviceSize,
        row_pitch: crate::data::DeviceSize,
        array_pitch: crate::data::DeviceSize,
        depth_pitch: crate::data::DeviceSize,
    };
    struct ImageViewCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_VIEW_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::ImageViewCreateFlags,
        image: crate::data::Image,
        view_type: crate::data::ImageViewType,
        format: crate::data::Format,
        components: crate::data::ComponentMapping,
        subresource_range: crate::data::ImageSubresourceRange,
    };
    struct BufferCopy {
        src_offset: crate::data::DeviceSize,
        dst_offset: crate::data::DeviceSize,
        size: crate::data::DeviceSize,
    };
    struct SparseMemoryBind {
        resource_offset: crate::data::DeviceSize,
        size: crate::data::DeviceSize,
        memory: crate::data::DeviceMemory,
        memory_offset: crate::data::DeviceSize,
        flags: crate::data::SparseMemoryBindFlags,
    };
    struct SparseImageMemoryBind {
        subresource: crate::data::ImageSubresource,
        offset: crate::data::Offset3D,
        extent: crate::data::Extent3D,
        memory: crate::data::DeviceMemory,
        memory_offset: crate::data::DeviceSize,
        flags: crate::data::SparseMemoryBindFlags,
    };
    struct SparseBufferMemoryBindInfo {
        buffer: crate::data::Buffer,
        bind_count: u32,
        p_binds: *const crate::data::SparseMemoryBind,
    };
    struct SparseImageOpaqueMemoryBindInfo {
        image: crate::data::Image,
        bind_count: u32,
        p_binds: *const crate::data::SparseMemoryBind,
    };
    struct SparseImageMemoryBindInfo {
        image: crate::data::Image,
        bind_count: u32,
        p_binds: *const crate::data::SparseImageMemoryBind,
    };
    struct BindSparseInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::BIND_SPARSE_INFO,
        p_next: *const c_void,
        wait_semaphore_count: u32,
        p_wait_semaphores: *const crate::data::Semaphore,
        buffer_bind_count: u32,
        p_buffer_binds: *const crate::data::SparseBufferMemoryBindInfo,
        image_opaque_bind_count: u32,
        p_image_opaque_binds: *const crate::data::SparseImageOpaqueMemoryBindInfo,
        image_bind_count: u32,
        p_image_binds: *const crate::data::SparseImageMemoryBindInfo,
        signal_semaphore_count: u32,
        p_signal_semaphores: *const crate::data::Semaphore,
    };
    struct ImageCopy {
        src_subresource: crate::data::ImageSubresourceLayers,
        src_offset: crate::data::Offset3D,
        dst_subresource: crate::data::ImageSubresourceLayers,
        dst_offset: crate::data::Offset3D,
        extent: crate::data::Extent3D,
    };
    struct ImageBlit {
        src_subresource: crate::data::ImageSubresourceLayers,
        src_offsets: [crate::data::Offset3D; 2],
        dst_subresource: crate::data::ImageSubresourceLayers,
        dst_offsets: [crate::data::Offset3D; 2],
    };
    struct BufferImageCopy {
        buffer_offset: crate::data::DeviceSize,
        buffer_row_length: u32,
        buffer_image_height: u32,
        image_subresource: crate::data::ImageSubresourceLayers,
        image_offset: crate::data::Offset3D,
        image_extent: crate::data::Extent3D,
    };
    struct ImageResolve {
        src_subresource: crate::data::ImageSubresourceLayers,
        src_offset: crate::data::Offset3D,
        dst_subresource: crate::data::ImageSubresourceLayers,
        dst_offset: crate::data::Offset3D,
        extent: crate::data::Extent3D,
    };
    struct ShaderModuleCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::SHADER_MODULE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::ShaderModuleCreateFlags,
        code_size: usize,
        p_code: *const u32,
    };
    struct DescriptorSetLayoutBinding {
        binding: u32,
        descriptor_type: crate::data::DescriptorType,
        descriptor_count: u32,
        stage_flags: crate::data::ShaderStageFlags,
        p_immutable_samplers: *const crate::data::Sampler,
    };
    struct DescriptorSetLayoutCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::DescriptorSetLayoutCreateFlags,
        binding_count: u32,
        p_bindings: *const crate::data::DescriptorSetLayoutBinding,
    };
    struct DescriptorPoolSize {
        ty: crate::data::DescriptorType,
        descriptor_count: u32,
    };
    struct DescriptorPoolCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_POOL_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::DescriptorPoolCreateFlags,
        max_sets: u32,
        pool_size_count: u32,
        p_pool_sizes: *const crate::data::DescriptorPoolSize,
    };
    struct DescriptorSetAllocateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_ALLOCATE_INFO,
        p_next: *const c_void,
        descriptor_pool: crate::data::DescriptorPool,
        descriptor_set_count: u32,
        p_set_layouts: *const crate::data::DescriptorSetLayout,
    };
    struct SpecializationMapEntry {
        constant_id: u32,
        offset: u32,
        size: usize,
    };
    struct SpecializationInfo {
        map_entry_count: u32,
        p_map_entries: *const crate::data::SpecializationMapEntry,
        data_size: usize,
        p_data: *const c_void,
    };
    struct PipelineShaderStageCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_SHADER_STAGE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineShaderStageCreateFlags,
        stage: crate::data::ShaderStageFlagBits,
        module: crate::data::ShaderModule,
        p_name: *const c_char,
        p_specialization_info: *const crate::data::SpecializationInfo,
    };
    struct ComputePipelineCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::COMPUTE_PIPELINE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineCreateFlags,
        stage: crate::data::PipelineShaderStageCreateInfo,
        layout: crate::data::PipelineLayout,
        base_pipeline_handle: crate::data::Pipeline,
        base_pipeline_index: i32,
    };
    struct VertexInputBindingDescription {
        binding: u32,
        stride: u32,
        input_rate: crate::data::VertexInputRate,
    };
    struct VertexInputAttributeDescription {
        location: u32,
        binding: u32,
        format: crate::data::Format,
        offset: u32,
    };
    struct PipelineVertexInputStateCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineVertexInputStateCreateFlags,
        vertex_binding_description_count: u32,
        p_vertex_binding_descriptions: *const crate::data::VertexInputBindingDescription,
        vertex_attribute_description_count: u32,
        p_vertex_attribute_descriptions: *const crate::data::VertexInputAttributeDescription,
    };
    struct PipelineInputAssemblyStateCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineInputAssemblyStateCreateFlags,
        topology: crate::data::PrimitiveTopology,
        primitive_restart_enable: crate::data::Bool32,
    };
    struct PipelineTessellationStateCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_TESSELLATION_STATE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineTessellationStateCreateFlags,
        patch_control_points: u32,
    };
    struct PipelineViewportStateCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_STATE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineViewportStateCreateFlags,
        viewport_count: u32,
        p_viewports: *const crate::data::Viewport,
        scissor_count: u32,
        p_scissors: *const crate::data::Rect2D,
    };
    struct PipelineRasterizationStateCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineRasterizationStateCreateFlags,
        depth_clamp_enable: crate::data::Bool32,
        rasterizer_discard_enable: crate::data::Bool32,
        polygon_mode: crate::data::PolygonMode,
        cull_mode: crate::data::CullModeFlags,
        front_face: crate::data::FrontFace,
        depth_bias_enable: crate::data::Bool32,
        depth_bias_constant_factor: c_float,
        depth_bias_clamp: c_float,
        depth_bias_slope_factor: c_float,
        line_width: c_float,
    };
    struct PipelineMultisampleStateCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineMultisampleStateCreateFlags,
        rasterization_samples: crate::data::SampleCountFlagBits,
        sample_shading_enable: crate::data::Bool32,
        min_sample_shading: c_float,
        p_sample_mask: *const crate::data::SampleMask,
        alpha_to_coverage_enable: crate::data::Bool32,
        alpha_to_one_enable: crate::data::Bool32,
    };
    struct PipelineColorBlendAttachmentState {
        blend_enable: crate::data::Bool32,
        src_color_blend_factor: crate::data::BlendFactor,
        dst_color_blend_factor: crate::data::BlendFactor,
        color_blend_op: crate::data::BlendOp,
        src_alpha_blend_factor: crate::data::BlendFactor,
        dst_alpha_blend_factor: crate::data::BlendFactor,
        alpha_blend_op: crate::data::BlendOp,
        color_write_mask: crate::data::ColorComponentFlags,
    };
    struct PipelineColorBlendStateCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineColorBlendStateCreateFlags,
        logic_op_enable: crate::data::Bool32,
        logic_op: crate::data::LogicOp,
        attachment_count: u32,
        p_attachments: *const crate::data::PipelineColorBlendAttachmentState,
        blend_constants: [c_float; 4],
    };
    struct PipelineDynamicStateCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_DYNAMIC_STATE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineDynamicStateCreateFlags,
        dynamic_state_count: u32,
        p_dynamic_states: *const crate::data::DynamicState,
    };
    struct StencilOpState {
        fail_op: crate::data::StencilOp,
        pass_op: crate::data::StencilOp,
        depth_fail_op: crate::data::StencilOp,
        compare_op: crate::data::CompareOp,
        compare_mask: u32,
        write_mask: u32,
        reference: u32,
    };
    struct PipelineDepthStencilStateCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineDepthStencilStateCreateFlags,
        depth_test_enable: crate::data::Bool32,
        depth_write_enable: crate::data::Bool32,
        depth_compare_op: crate::data::CompareOp,
        depth_bounds_test_enable: crate::data::Bool32,
        stencil_test_enable: crate::data::Bool32,
        front: crate::data::StencilOpState,
        back: crate::data::StencilOpState,
        min_depth_bounds: c_float,
        max_depth_bounds: c_float,
    };
    struct GraphicsPipelineCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::GRAPHICS_PIPELINE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineCreateFlags,
        stage_count: u32,
        p_stages: *const crate::data::PipelineShaderStageCreateInfo,
        p_vertex_input_state: *const crate::data::PipelineVertexInputStateCreateInfo,
        p_input_assembly_state: *const crate::data::PipelineInputAssemblyStateCreateInfo,
        p_tessellation_state: *const crate::data::PipelineTessellationStateCreateInfo,
        p_viewport_state: *const crate::data::PipelineViewportStateCreateInfo,
        p_rasterization_state: *const crate::data::PipelineRasterizationStateCreateInfo,
        p_multisample_state: *const crate::data::PipelineMultisampleStateCreateInfo,
        p_depth_stencil_state: *const crate::data::PipelineDepthStencilStateCreateInfo,
        p_color_blend_state: *const crate::data::PipelineColorBlendStateCreateInfo,
        p_dynamic_state: *const crate::data::PipelineDynamicStateCreateInfo,
        layout: crate::data::PipelineLayout,
        render_pass: crate::data::RenderPass,
        subpass: u32,
        base_pipeline_handle: crate::data::Pipeline,
        base_pipeline_index: i32,
    };
    struct PipelineCacheCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_CACHE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineCacheCreateFlags,
        initial_data_size: usize,
        p_initial_data: *const c_void,
    };
    struct PushConstantRange {
        stage_flags: crate::data::ShaderStageFlags,
        offset: u32,
        size: u32,
    };
    struct PipelineLayoutCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_LAYOUT_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::PipelineLayoutCreateFlags,
        set_layout_count: u32,
        p_set_layouts: *const crate::data::DescriptorSetLayout,
        push_constant_range_count: u32,
        p_push_constant_ranges: *const crate::data::PushConstantRange,
    };
    struct SamplerCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::SAMPLER_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::SamplerCreateFlags,
        mag_filter: crate::data::Filter,
        min_filter: crate::data::Filter,
        mipmap_mode: crate::data::SamplerMipmapMode,
        address_mode_u: crate::data::SamplerAddressMode,
        address_mode_v: crate::data::SamplerAddressMode,
        address_mode_w: crate::data::SamplerAddressMode,
        mip_lod_bias: c_float,
        anisotropy_enable: crate::data::Bool32,
        max_anisotropy: c_float,
        compare_enable: crate::data::Bool32,
        compare_op: crate::data::CompareOp,
        min_lod: c_float,
        max_lod: c_float,
        border_color: crate::data::BorderColor,
        unnormalized_coordinates: crate::data::Bool32,
    };
    struct CommandPoolCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_POOL_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::CommandPoolCreateFlags,
        queue_family_index: u32,
    };
    struct CommandBufferAllocateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_BUFFER_ALLOCATE_INFO,
        p_next: *const c_void,
        command_pool: crate::data::CommandPool,
        level: crate::data::CommandBufferLevel,
        command_buffer_count: u32,
    };
    struct CommandBufferInheritanceInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_BUFFER_INHERITANCE_INFO,
        p_next: *const c_void,
        render_pass: crate::data::RenderPass,
        subpass: u32,
        framebuffer: crate::data::Framebuffer,
        occlusion_query_enable: crate::data::Bool32,
        query_flags: crate::data::QueryControlFlags,
        pipeline_statistics: crate::data::QueryPipelineStatisticFlags,
    };
    struct CommandBufferBeginInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_BUFFER_BEGIN_INFO,
        p_next: *const c_void,
        flags: crate::data::CommandBufferUsageFlags,
        p_inheritance_info: *const crate::data::CommandBufferInheritanceInfo,
    };
    struct RenderPassBeginInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_BEGIN_INFO,
        p_next: *const c_void,
        render_pass: crate::data::RenderPass,
        framebuffer: crate::data::Framebuffer,
        render_area: crate::data::Rect2D,
        clear_value_count: u32,
        p_clear_values: *const crate::data::ClearValue,
    };
    union ClearColorValue {
        float_32: [c_float; 4],
        int_32: [i32; 4],
        uint_32: [u32; 4],
    };
    struct ClearDepthStencilValue {
        depth: c_float,
        stencil: u32,
    };
    union ClearValue {
        color: crate::data::ClearColorValue,
        depth_stencil: crate::data::ClearDepthStencilValue,
    };
    struct ClearAttachment {
        aspect_mask: crate::data::ImageAspectFlags,
        color_attachment: u32,
        clear_value: crate::data::ClearValue,
    };
    struct AttachmentDescription {
        flags: crate::data::AttachmentDescriptionFlags,
        format: crate::data::Format,
        samples: crate::data::SampleCountFlagBits,
        load_op: crate::data::AttachmentLoadOp,
        store_op: crate::data::AttachmentStoreOp,
        stencil_load_op: crate::data::AttachmentLoadOp,
        stencil_store_op: crate::data::AttachmentStoreOp,
        initial_layout: crate::data::ImageLayout,
        final_layout: crate::data::ImageLayout,
    };
    struct AttachmentReference {
        attachment: u32,
        layout: crate::data::ImageLayout,
    };
    struct SubpassDescription {
        flags: crate::data::SubpassDescriptionFlags,
        pipeline_bind_point: crate::data::PipelineBindPoint,
        input_attachment_count: u32,
        p_input_attachments: *const crate::data::AttachmentReference,
        color_attachment_count: u32,
        p_color_attachments: *const crate::data::AttachmentReference,
        p_resolve_attachments: *const crate::data::AttachmentReference,
        p_depth_stencil_attachment: *const crate::data::AttachmentReference,
        preserve_attachment_count: u32,
        p_preserve_attachments: *const u32,
    };
    struct SubpassDependency {
        src_subpass: u32,
        dst_subpass: u32,
        src_stage_mask: crate::data::PipelineStageFlags,
        dst_stage_mask: crate::data::PipelineStageFlags,
        src_access_mask: crate::data::AccessFlags,
        dst_access_mask: crate::data::AccessFlags,
        dependency_flags: crate::data::DependencyFlags,
    };
    struct RenderPassCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::RenderPassCreateFlags,
        attachment_count: u32,
        p_attachments: *const crate::data::AttachmentDescription,
        subpass_count: u32,
        p_subpasses: *const crate::data::SubpassDescription,
        dependency_count: u32,
        p_dependencies: *const crate::data::SubpassDependency,
    };
    struct EventCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::EVENT_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::EventCreateFlags,
    };
    struct FenceCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::FENCE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::FenceCreateFlags,
    };
    struct PhysicalDeviceFeatures {
        robust_buffer_access: crate::data::Bool32,
        full_draw_index_uint_32: crate::data::Bool32,
        image_cube_array: crate::data::Bool32,
        independent_blend: crate::data::Bool32,
        geometry_shader: crate::data::Bool32,
        tessellation_shader: crate::data::Bool32,
        sample_rate_shading: crate::data::Bool32,
        dual_src_blend: crate::data::Bool32,
        logic_op: crate::data::Bool32,
        multi_draw_indirect: crate::data::Bool32,
        draw_indirect_first_instance: crate::data::Bool32,
        depth_clamp: crate::data::Bool32,
        depth_bias_clamp: crate::data::Bool32,
        fill_mode_non_solid: crate::data::Bool32,
        depth_bounds: crate::data::Bool32,
        wide_lines: crate::data::Bool32,
        large_points: crate::data::Bool32,
        alpha_to_one: crate::data::Bool32,
        multi_viewport: crate::data::Bool32,
        sampler_anisotropy: crate::data::Bool32,
        texture_compression_etc_2: crate::data::Bool32,
        texture_compression_astc_ldr: crate::data::Bool32,
        texture_compression_bc: crate::data::Bool32,
        occlusion_query_precise: crate::data::Bool32,
        pipeline_statistics_query: crate::data::Bool32,
        vertex_pipeline_stores_and_atomics: crate::data::Bool32,
        fragment_stores_and_atomics: crate::data::Bool32,
        shader_tessellation_and_geometry_point_size: crate::data::Bool32,
        shader_image_gather_extended: crate::data::Bool32,
        shader_storage_image_extended_formats: crate::data::Bool32,
        shader_storage_image_multisample: crate::data::Bool32,
        shader_storage_image_read_without_format: crate::data::Bool32,
        shader_storage_image_write_without_format: crate::data::Bool32,
        shader_uniform_buffer_array_dynamic_indexing: crate::data::Bool32,
        shader_sampled_image_array_dynamic_indexing: crate::data::Bool32,
        shader_storage_buffer_array_dynamic_indexing: crate::data::Bool32,
        shader_storage_image_array_dynamic_indexing: crate::data::Bool32,
        shader_clip_distance: crate::data::Bool32,
        shader_cull_distance: crate::data::Bool32,
        shader_float_64: crate::data::Bool32,
        shader_int_64: crate::data::Bool32,
        shader_int_16: crate::data::Bool32,
        shader_resource_residency: crate::data::Bool32,
        shader_resource_min_lod: crate::data::Bool32,
        sparse_binding: crate::data::Bool32,
        sparse_residency_buffer: crate::data::Bool32,
        sparse_residency_image_2d: crate::data::Bool32,
        sparse_residency_image_3d: crate::data::Bool32,
        sparse_residency_2_samples: crate::data::Bool32,
        sparse_residency_4_samples: crate::data::Bool32,
        sparse_residency_8_samples: crate::data::Bool32,
        sparse_residency_16_samples: crate::data::Bool32,
        sparse_residency_aliased: crate::data::Bool32,
        variable_multisample_rate: crate::data::Bool32,
        inherited_queries: crate::data::Bool32,
    };
    struct PhysicalDeviceSparseProperties {
        residency_standard_2d_block_shape: crate::data::Bool32,
        residency_standard_2d_multisample_block_shape: crate::data::Bool32,
        residency_standard_3d_block_shape: crate::data::Bool32,
        residency_aligned_mip_size: crate::data::Bool32,
        residency_non_resident_strict: crate::data::Bool32,
    };
    struct PhysicalDeviceLimits {
        max_image_dimension_1d: u32,
        max_image_dimension_2d: u32,
        max_image_dimension_3d: u32,
        max_image_dimension_cube: u32,
        max_image_array_layers: u32,
        max_texel_buffer_elements: u32,
        max_uniform_buffer_range: u32,
        max_storage_buffer_range: u32,
        max_push_constants_size: u32,
        max_memory_allocation_count: u32,
        max_sampler_allocation_count: u32,
        buffer_image_granularity: crate::data::DeviceSize,
        sparse_address_space_size: crate::data::DeviceSize,
        max_bound_descriptor_sets: u32,
        max_per_stage_descriptor_samplers: u32,
        max_per_stage_descriptor_uniform_buffers: u32,
        max_per_stage_descriptor_storage_buffers: u32,
        max_per_stage_descriptor_sampled_images: u32,
        max_per_stage_descriptor_storage_images: u32,
        max_per_stage_descriptor_input_attachments: u32,
        max_per_stage_resources: u32,
        max_descriptor_set_samplers: u32,
        max_descriptor_set_uniform_buffers: u32,
        max_descriptor_set_uniform_buffers_dynamic: u32,
        max_descriptor_set_storage_buffers: u32,
        max_descriptor_set_storage_buffers_dynamic: u32,
        max_descriptor_set_sampled_images: u32,
        max_descriptor_set_storage_images: u32,
        max_descriptor_set_input_attachments: u32,
        max_vertex_input_attributes: u32,
        max_vertex_input_bindings: u32,
        max_vertex_input_attribute_offset: u32,
        max_vertex_input_binding_stride: u32,
        max_vertex_output_components: u32,
        max_tessellation_generation_level: u32,
        max_tessellation_patch_size: u32,
        max_tessellation_control_per_vertex_input_components: u32,
        max_tessellation_control_per_vertex_output_components: u32,
        max_tessellation_control_per_patch_output_components: u32,
        max_tessellation_control_total_output_components: u32,
        max_tessellation_evaluation_input_components: u32,
        max_tessellation_evaluation_output_components: u32,
        max_geometry_shader_invocations: u32,
        max_geometry_input_components: u32,
        max_geometry_output_components: u32,
        max_geometry_output_vertices: u32,
        max_geometry_total_output_components: u32,
        max_fragment_input_components: u32,
        max_fragment_output_attachments: u32,
        max_fragment_dual_src_attachments: u32,
        max_fragment_combined_output_resources: u32,
        max_compute_shared_memory_size: u32,
        max_compute_work_group_count: [u32; 3],
        max_compute_work_group_invocations: u32,
        max_compute_work_group_size: [u32; 3],
        sub_pixel_precision_bits: u32,
        sub_texel_precision_bits: u32,
        mipmap_precision_bits: u32,
        max_draw_indexed_index_value: u32,
        max_draw_indirect_count: u32,
        max_sampler_lod_bias: c_float,
        max_sampler_anisotropy: c_float,
        max_viewports: u32,
        max_viewport_dimensions: [u32; 2],
        viewport_bounds_range: [c_float; 2],
        viewport_sub_pixel_bits: u32,
        min_memory_map_alignment: usize,
        min_texel_buffer_offset_alignment: crate::data::DeviceSize,
        min_uniform_buffer_offset_alignment: crate::data::DeviceSize,
        min_storage_buffer_offset_alignment: crate::data::DeviceSize,
        min_texel_offset: i32,
        max_texel_offset: u32,
        min_texel_gather_offset: i32,
        max_texel_gather_offset: u32,
        min_interpolation_offset: c_float,
        max_interpolation_offset: c_float,
        sub_pixel_interpolation_offset_bits: u32,
        max_framebuffer_width: u32,
        max_framebuffer_height: u32,
        max_framebuffer_layers: u32,
        framebuffer_color_sample_counts: crate::data::SampleCountFlags,
        framebuffer_depth_sample_counts: crate::data::SampleCountFlags,
        framebuffer_stencil_sample_counts: crate::data::SampleCountFlags,
        framebuffer_no_attachments_sample_counts: crate::data::SampleCountFlags,
        max_color_attachments: u32,
        sampled_image_color_sample_counts: crate::data::SampleCountFlags,
        sampled_image_integer_sample_counts: crate::data::SampleCountFlags,
        sampled_image_depth_sample_counts: crate::data::SampleCountFlags,
        sampled_image_stencil_sample_counts: crate::data::SampleCountFlags,
        storage_image_sample_counts: crate::data::SampleCountFlags,
        max_sample_mask_words: u32,
        timestamp_compute_and_graphics: crate::data::Bool32,
        timestamp_period: c_float,
        max_clip_distances: u32,
        max_cull_distances: u32,
        max_combined_clip_and_cull_distances: u32,
        discrete_queue_priorities: u32,
        point_size_range: [c_float; 2],
        line_width_range: [c_float; 2],
        point_size_granularity: c_float,
        line_width_granularity: c_float,
        strict_lines: crate::data::Bool32,
        standard_sample_locations: crate::data::Bool32,
        optimal_buffer_copy_offset_alignment: crate::data::DeviceSize,
        optimal_buffer_copy_row_pitch_alignment: crate::data::DeviceSize,
        non_coherent_atom_size: crate::data::DeviceSize,
    };
    struct SemaphoreCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::SEMAPHORE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::SemaphoreCreateFlags,
    };
    struct QueryPoolCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::QUERY_POOL_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::QueryPoolCreateFlags,
        query_type: crate::data::QueryType,
        query_count: u32,
        pipeline_statistics: crate::data::QueryPipelineStatisticFlags,
    };
    struct FramebufferCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::FRAMEBUFFER_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::FramebufferCreateFlags,
        render_pass: crate::data::RenderPass,
        attachment_count: u32,
        p_attachments: *const crate::data::ImageView,
        width: u32,
        height: u32,
        layers: u32,
    };
    struct DrawIndirectCommand {
        vertex_count: u32,
        instance_count: u32,
        first_vertex: u32,
        first_instance: u32,
    };
    struct DrawIndexedIndirectCommand {
        index_count: u32,
        instance_count: u32,
        first_index: u32,
        vertex_offset: i32,
        first_instance: u32,
    };
    struct DispatchIndirectCommand {
        x: u32,
        y: u32,
        z: u32,
    };
    struct SubmitInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::SUBMIT_INFO,
        p_next: *const c_void,
        wait_semaphore_count: u32,
        p_wait_semaphores: *const crate::data::Semaphore,
        p_wait_dst_stage_mask: *const crate::data::PipelineStageFlags,
        command_buffer_count: u32,
        p_command_buffers: *const crate::data::CommandBuffer,
        signal_semaphore_count: u32,
        p_signal_semaphores: *const crate::data::Semaphore,
    };
    struct DisplayPropertiesKHR {
        display: crate::data::DisplayKHR,
        display_name: *const c_char,
        physical_dimensions: crate::data::Extent2D,
        physical_resolution: crate::data::Extent2D,
        supported_transforms: crate::data::SurfaceTransformFlagsKHR,
        plane_reorder_possible: crate::data::Bool32,
        persistent_content: crate::data::Bool32,
    };
    struct DisplayPlanePropertiesKHR {
        current_display: crate::data::DisplayKHR,
        current_stack_index: u32,
    };
    struct DisplayModeParametersKHR {
        visible_region: crate::data::Extent2D,
        refresh_rate: u32,
    };
    struct DisplayModePropertiesKHR {
        display_mode: crate::data::DisplayModeKHR,
        parameters: crate::data::DisplayModeParametersKHR,
    };
    struct DisplayModeCreateInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_MODE_CREATE_INFO_KHR,
        p_next: *const c_void,
        flags: crate::data::DisplayModeCreateFlagsKHR,
        parameters: crate::data::DisplayModeParametersKHR,
    };
    struct DisplayPlaneCapabilitiesKHR {
        supported_alpha: crate::data::DisplayPlaneAlphaFlagsKHR,
        min_src_position: crate::data::Offset2D,
        max_src_position: crate::data::Offset2D,
        min_src_extent: crate::data::Extent2D,
        max_src_extent: crate::data::Extent2D,
        min_dst_position: crate::data::Offset2D,
        max_dst_position: crate::data::Offset2D,
        min_dst_extent: crate::data::Extent2D,
        max_dst_extent: crate::data::Extent2D,
    };
    struct DisplaySurfaceCreateInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_SURFACE_CREATE_INFO_KHR,
        p_next: *const c_void,
        flags: crate::data::DisplaySurfaceCreateFlagsKHR,
        display_mode: crate::data::DisplayModeKHR,
        plane_index: u32,
        plane_stack_index: u32,
        transform: crate::data::SurfaceTransformFlagBitsKHR,
        global_alpha: c_float,
        alpha_mode: crate::data::DisplayPlaneAlphaFlagBitsKHR,
        image_extent: crate::data::Extent2D,
    };
    struct DisplayPresentInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_PRESENT_INFO_KHR,
        p_next: *const c_void,
        src_rect: crate::data::Rect2D,
        dst_rect: crate::data::Rect2D,
        persistent: crate::data::Bool32,
    };
    struct SurfaceCapabilitiesKHR {
        min_image_count: u32,
        max_image_count: u32,
        current_extent: crate::data::Extent2D,
        min_image_extent: crate::data::Extent2D,
        max_image_extent: crate::data::Extent2D,
        max_image_array_layers: u32,
        supported_transforms: crate::data::SurfaceTransformFlagsKHR,
        current_transform: crate::data::SurfaceTransformFlagBitsKHR,
        supported_composite_alpha: crate::data::CompositeAlphaFlagsKHR,
        supported_usage_flags: crate::data::ImageUsageFlags,
    };
    struct ViSurfaceCreateInfoNN {
        s_type: crate::data::StructureType = crate::data::StructureType::VI_SURFACE_CREATE_INFO_NN,
        p_next: *const c_void,
        flags: crate::data::ViSurfaceCreateFlagsNN,
        window: *mut c_void,
    };
    struct SurfaceFormatKHR {
        format: crate::data::Format,
        color_space: crate::data::ColorSpaceKHR,
    };
    struct SwapchainCreateInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::SWAPCHAIN_CREATE_INFO_KHR,
        p_next: *const c_void,
        flags: crate::data::SwapchainCreateFlagsKHR,
        surface: crate::data::SurfaceKHR,
        min_image_count: u32,
        image_format: crate::data::Format,
        image_color_space: crate::data::ColorSpaceKHR,
        image_extent: crate::data::Extent2D,
        image_array_layers: u32,
        image_usage: crate::data::ImageUsageFlags,
        image_sharing_mode: crate::data::SharingMode,
        queue_family_index_count: u32,
        p_queue_family_indices: *const u32,
        pre_transform: crate::data::SurfaceTransformFlagBitsKHR,
        composite_alpha: crate::data::CompositeAlphaFlagBitsKHR,
        present_mode: crate::data::PresentModeKHR,
        clipped: crate::data::Bool32,
        old_swapchain: crate::data::SwapchainKHR,
    };
    struct PresentInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::PRESENT_INFO_KHR,
        p_next: *const c_void,
        wait_semaphore_count: u32,
        p_wait_semaphores: *const crate::data::Semaphore,
        swapchain_count: u32,
        p_swapchains: *const crate::data::SwapchainKHR,
        p_image_indices: *const u32,
        p_results: *mut crate::data::Result,
    };
    struct DebugReportCallbackCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
        p_next: *const c_void,
        flags: crate::data::DebugReportFlagsEXT,
        pfn_callback: crate::pfn::DebugReportCallbackEXT,
        p_user_data: *mut c_void,
    };
    struct ValidationFlagsEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::VALIDATION_FLAGS_EXT,
        p_next: *const c_void,
        disabled_validation_check_count: u32,
        p_disabled_validation_checks: *const crate::data::ValidationCheckEXT,
    };
    struct ValidationFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::VALIDATION_FEATURES_EXT,
        p_next: *const c_void,
        enabled_validation_feature_count: u32,
        p_enabled_validation_features: *const crate::data::ValidationFeatureEnableEXT,
        disabled_validation_feature_count: u32,
        p_disabled_validation_features: *const crate::data::ValidationFeatureDisableEXT,
    };
    struct PipelineRasterizationStateRasterizationOrderAMD {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
        p_next: *const c_void,
        rasterization_order: crate::data::RasterizationOrderAMD,
    };
    struct DebugMarkerObjectNameInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
        p_next: *const c_void,
        object_type: crate::data::DebugReportObjectTypeEXT,
        object: u64,
        p_object_name: *const c_char,
    };
    struct DebugMarkerObjectTagInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
        p_next: *const c_void,
        object_type: crate::data::DebugReportObjectTypeEXT,
        object: u64,
        tag_name: u64,
        tag_size: usize,
        p_tag: *const c_void,
    };
    struct DebugMarkerMarkerInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_MARKER_MARKER_INFO_EXT,
        p_next: *const c_void,
        p_marker_name: *const c_char,
        color: [c_float; 4],
    };
    struct DedicatedAllocationImageCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
        p_next: *const c_void,
        dedicated_allocation: crate::data::Bool32,
    };
    struct DedicatedAllocationBufferCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
        p_next: *const c_void,
        dedicated_allocation: crate::data::Bool32,
    };
    struct DedicatedAllocationMemoryAllocateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
        p_next: *const c_void,
        image: crate::data::Image,
        buffer: crate::data::Buffer,
    };
    struct ExternalImageFormatPropertiesNV {
        image_format_properties: crate::data::ImageFormatProperties,
        external_memory_features: crate::data::ExternalMemoryFeatureFlagsNV,
        export_from_imported_handle_types: crate::data::ExternalMemoryHandleTypeFlagsNV,
        compatible_handle_types: crate::data::ExternalMemoryHandleTypeFlagsNV,
    };
    struct ExternalMemoryImageCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
        p_next: *const c_void,
        handle_types: crate::data::ExternalMemoryHandleTypeFlagsNV,
    };
    struct ExportMemoryAllocateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_MEMORY_ALLOCATE_INFO_NV,
        p_next: *const c_void,
        handle_types: crate::data::ExternalMemoryHandleTypeFlagsNV,
    };
    struct Win32KeyedMutexAcquireReleaseInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
        p_next: *const c_void,
        acquire_count: u32,
        p_acquire_syncs: *const crate::data::DeviceMemory,
        p_acquire_keys: *const u64,
        p_acquire_timeout_milliseconds: *const u32,
        release_count: u32,
        p_release_syncs: *const crate::data::DeviceMemory,
        p_release_keys: *const u64,
    };
    struct DeviceGeneratedCommandsFeaturesNVX {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GENERATED_COMMANDS_FEATURES_NVX,
        p_next: *const c_void,
        compute_binding_point_support: crate::data::Bool32,
    };
    struct DeviceGeneratedCommandsLimitsNVX {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GENERATED_COMMANDS_LIMITS_NVX,
        p_next: *const c_void,
        max_indirect_commands_layout_token_count: u32,
        max_object_entry_counts: u32,
        min_sequence_count_buffer_offset_alignment: u32,
        min_sequence_index_buffer_offset_alignment: u32,
        min_commands_token_buffer_offset_alignment: u32,
    };
    struct IndirectCommandsTokenNVX {
        token_type: crate::data::IndirectCommandsTokenTypeNVX,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
    };
    struct IndirectCommandsLayoutTokenNVX {
        token_type: crate::data::IndirectCommandsTokenTypeNVX,
        binding_unit: u32,
        dynamic_count: u32,
        divisor: u32,
    };
    struct IndirectCommandsLayoutCreateInfoNVX {
        s_type: crate::data::StructureType = crate::data::StructureType::INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX,
        p_next: *const c_void,
        pipeline_bind_point: crate::data::PipelineBindPoint,
        flags: crate::data::IndirectCommandsLayoutUsageFlagsNVX,
        token_count: u32,
        p_tokens: *const crate::data::IndirectCommandsLayoutTokenNVX,
    };
    struct CmdProcessCommandsInfoNVX {
        s_type: crate::data::StructureType = crate::data::StructureType::CMD_PROCESS_COMMANDS_INFO_NVX,
        p_next: *const c_void,
        object_table: crate::data::ObjectTableNVX,
        indirect_commands_layout: crate::data::IndirectCommandsLayoutNVX,
        indirect_commands_token_count: u32,
        p_indirect_commands_tokens: *const crate::data::IndirectCommandsTokenNVX,
        max_sequences_count: u32,
        target_command_buffer: crate::data::CommandBuffer,
        sequences_count_buffer: crate::data::Buffer,
        sequences_count_offset: crate::data::DeviceSize,
        sequences_index_buffer: crate::data::Buffer,
        sequences_index_offset: crate::data::DeviceSize,
    };
    struct CmdReserveSpaceForCommandsInfoNVX {
        s_type: crate::data::StructureType = crate::data::StructureType::CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX,
        p_next: *const c_void,
        object_table: crate::data::ObjectTableNVX,
        indirect_commands_layout: crate::data::IndirectCommandsLayoutNVX,
        max_sequences_count: u32,
    };
    struct ObjectTableCreateInfoNVX {
        s_type: crate::data::StructureType = crate::data::StructureType::OBJECT_TABLE_CREATE_INFO_NVX,
        p_next: *const c_void,
        object_count: u32,
        p_object_entry_types: *const crate::data::ObjectEntryTypeNVX,
        p_object_entry_counts: *const u32,
        p_object_entry_usage_flags: *const crate::data::ObjectEntryUsageFlagsNVX,
        max_uniform_buffers_per_descriptor: u32,
        max_storage_buffers_per_descriptor: u32,
        max_storage_images_per_descriptor: u32,
        max_sampled_images_per_descriptor: u32,
        max_pipeline_layouts: u32,
    };
    struct ObjectTableEntryNVX {
        ty: crate::data::ObjectEntryTypeNVX,
        flags: crate::data::ObjectEntryUsageFlagsNVX,
    };
    struct ObjectTablePipelineEntryNVX {
        ty: crate::data::ObjectEntryTypeNVX,
        flags: crate::data::ObjectEntryUsageFlagsNVX,
        pipeline: crate::data::Pipeline,
    };
    struct ObjectTableDescriptorSetEntryNVX {
        ty: crate::data::ObjectEntryTypeNVX,
        flags: crate::data::ObjectEntryUsageFlagsNVX,
        pipeline_layout: crate::data::PipelineLayout,
        descriptor_set: crate::data::DescriptorSet,
    };
    struct ObjectTableVertexBufferEntryNVX {
        ty: crate::data::ObjectEntryTypeNVX,
        flags: crate::data::ObjectEntryUsageFlagsNVX,
        buffer: crate::data::Buffer,
    };
    struct ObjectTableIndexBufferEntryNVX {
        ty: crate::data::ObjectEntryTypeNVX,
        flags: crate::data::ObjectEntryUsageFlagsNVX,
        buffer: crate::data::Buffer,
        index_type: crate::data::IndexType,
    };
    struct ObjectTablePushConstantEntryNVX {
        ty: crate::data::ObjectEntryTypeNVX,
        flags: crate::data::ObjectEntryUsageFlagsNVX,
        pipeline_layout: crate::data::PipelineLayout,
        stage_flags: crate::data::ShaderStageFlags,
    };
    struct PhysicalDeviceFeatures2 {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FEATURES_2,
        p_next: *mut c_void,
        features: crate::data::PhysicalDeviceFeatures,
    };
    struct PhysicalDeviceProperties2 {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PROPERTIES_2,
        p_next: *mut c_void,
        properties: crate::data::PhysicalDeviceProperties,
    };
    struct FormatProperties2 {
        s_type: crate::data::StructureType = crate::data::StructureType::FORMAT_PROPERTIES_2,
        p_next: *mut c_void,
        format_properties: crate::data::FormatProperties,
    };
    struct ImageFormatProperties2 {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_FORMAT_PROPERTIES_2,
        p_next: *mut c_void,
        image_format_properties: crate::data::ImageFormatProperties,
    };
    struct PhysicalDeviceImageFormatInfo2 {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
        p_next: *const c_void,
        format: crate::data::Format,
        ty: crate::data::ImageType,
        tiling: crate::data::ImageTiling,
        usage: crate::data::ImageUsageFlags,
        flags: crate::data::ImageCreateFlags,
    };
    struct QueueFamilyProperties2 {
        s_type: crate::data::StructureType = crate::data::StructureType::QUEUE_FAMILY_PROPERTIES_2,
        p_next: *mut c_void,
        queue_family_properties: crate::data::QueueFamilyProperties,
    };
    struct PhysicalDeviceMemoryProperties2 {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
        p_next: *mut c_void,
        memory_properties: crate::data::PhysicalDeviceMemoryProperties,
    };
    struct SparseImageFormatProperties2 {
        s_type: crate::data::StructureType = crate::data::StructureType::SPARSE_IMAGE_FORMAT_PROPERTIES_2,
        p_next: *mut c_void,
        properties: crate::data::SparseImageFormatProperties,
    };
    struct PhysicalDeviceSparseImageFormatInfo2 {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
        p_next: *const c_void,
        format: crate::data::Format,
        ty: crate::data::ImageType,
        samples: crate::data::SampleCountFlagBits,
        usage: crate::data::ImageUsageFlags,
        tiling: crate::data::ImageTiling,
    };
    struct PhysicalDevicePushDescriptorPropertiesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
        p_next: *mut c_void,
        max_push_descriptors: u32,
    };
    struct ConformanceVersionKHR {
        major: u8,
        minor: u8,
        subminor: u8,
        patch: u8,
    };
    struct PhysicalDeviceDriverPropertiesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR,
        p_next: *mut c_void,
        driver_id: crate::data::DriverIdKHR,
        driver_name: [c_char; 256],
        driver_info: [c_char; 256],
        conformance_version: crate::data::ConformanceVersionKHR,
    };
    struct PresentRegionsKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::PRESENT_REGIONS_KHR,
        p_next: *const c_void,
        swapchain_count: u32,
        p_regions: *const crate::data::PresentRegionKHR,
    };
    struct PresentRegionKHR {
        rectangle_count: u32,
        p_rectangles: *const crate::data::RectLayerKHR,
    };
    struct RectLayerKHR {
        offset: crate::data::Offset2D,
        extent: crate::data::Extent2D,
        layer: u32,
    };
    struct PhysicalDeviceVariablePointerFeatures {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
        p_next: *mut c_void,
        variable_pointers_storage_buffer: crate::data::Bool32,
        variable_pointers: crate::data::Bool32,
    };
    struct ExternalMemoryProperties {
        external_memory_features: crate::data::ExternalMemoryFeatureFlags,
        export_from_imported_handle_types: crate::data::ExternalMemoryHandleTypeFlags,
        compatible_handle_types: crate::data::ExternalMemoryHandleTypeFlags,
    };
    struct PhysicalDeviceExternalImageFormatInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
        p_next: *const c_void,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
    };
    struct ExternalImageFormatProperties {
        s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_IMAGE_FORMAT_PROPERTIES,
        p_next: *mut c_void,
        external_memory_properties: crate::data::ExternalMemoryProperties,
    };
    struct PhysicalDeviceExternalBufferInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
        p_next: *const c_void,
        flags: crate::data::BufferCreateFlags,
        usage: crate::data::BufferUsageFlags,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
    };
    struct ExternalBufferProperties {
        s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_BUFFER_PROPERTIES,
        p_next: *mut c_void,
        external_memory_properties: crate::data::ExternalMemoryProperties,
    };
    struct PhysicalDeviceIDProperties {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_ID_PROPERTIES,
        p_next: *mut c_void,
        device_uuid: [u8; 16],
        driver_uuid: [u8; 16],
        device_luid: [u8; 8],
        device_node_mask: u32,
        device_luid_valid: crate::data::Bool32,
    };
    struct ExternalMemoryImageCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
        p_next: *const c_void,
        handle_types: crate::data::ExternalMemoryHandleTypeFlags,
    };
    struct ExternalMemoryBufferCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
        p_next: *const c_void,
        handle_types: crate::data::ExternalMemoryHandleTypeFlags,
    };
    struct ExportMemoryAllocateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_MEMORY_ALLOCATE_INFO,
        p_next: *const c_void,
        handle_types: crate::data::ExternalMemoryHandleTypeFlags,
    };
    struct MemoryWin32HandlePropertiesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
        p_next: *mut c_void,
        memory_type_bits: u32,
    };
    struct MemoryGetWin32HandleInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_GET_WIN32_HANDLE_INFO_KHR,
        p_next: *const c_void,
        memory: crate::data::DeviceMemory,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
    };
    struct ImportMemoryFdInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_MEMORY_FD_INFO_KHR,
        p_next: *const c_void,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        fd: c_int,
    };
    struct MemoryFdPropertiesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_FD_PROPERTIES_KHR,
        p_next: *mut c_void,
        memory_type_bits: u32,
    };
    struct MemoryGetFdInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_GET_FD_INFO_KHR,
        p_next: *const c_void,
        memory: crate::data::DeviceMemory,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
    };
    struct Win32KeyedMutexAcquireReleaseInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
        p_next: *const c_void,
        acquire_count: u32,
        p_acquire_syncs: *const crate::data::DeviceMemory,
        p_acquire_keys: *const u64,
        p_acquire_timeouts: *const u32,
        release_count: u32,
        p_release_syncs: *const crate::data::DeviceMemory,
        p_release_keys: *const u64,
    };
    struct PhysicalDeviceExternalSemaphoreInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
        p_next: *const c_void,
        handle_type: crate::data::ExternalSemaphoreHandleTypeFlagBits,
    };
    struct ExternalSemaphoreProperties {
        s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_SEMAPHORE_PROPERTIES,
        p_next: *mut c_void,
        export_from_imported_handle_types: crate::data::ExternalSemaphoreHandleTypeFlags,
        compatible_handle_types: crate::data::ExternalSemaphoreHandleTypeFlags,
        external_semaphore_features: crate::data::ExternalSemaphoreFeatureFlags,
    };
    struct ExportSemaphoreCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_SEMAPHORE_CREATE_INFO,
        p_next: *const c_void,
        handle_types: crate::data::ExternalSemaphoreHandleTypeFlags,
    };
    struct D3D12FenceSubmitInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::D3D12_FENCE_SUBMIT_INFO_KHR,
        p_next: *const c_void,
        wait_semaphore_values_count: u32,
        p_wait_semaphore_values: *const u64,
        signal_semaphore_values_count: u32,
        p_signal_semaphore_values: *const u64,
    };
    struct SemaphoreGetWin32HandleInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
        p_next: *const c_void,
        semaphore: crate::data::Semaphore,
        handle_type: crate::data::ExternalSemaphoreHandleTypeFlagBits,
    };
    struct ImportSemaphoreFdInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_SEMAPHORE_FD_INFO_KHR,
        p_next: *const c_void,
        semaphore: crate::data::Semaphore,
        flags: crate::data::SemaphoreImportFlags,
        handle_type: crate::data::ExternalSemaphoreHandleTypeFlagBits,
        fd: c_int,
    };
    struct SemaphoreGetFdInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::SEMAPHORE_GET_FD_INFO_KHR,
        p_next: *const c_void,
        semaphore: crate::data::Semaphore,
        handle_type: crate::data::ExternalSemaphoreHandleTypeFlagBits,
    };
    struct PhysicalDeviceExternalFenceInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
        p_next: *const c_void,
        handle_type: crate::data::ExternalFenceHandleTypeFlagBits,
    };
    struct ExternalFenceProperties {
        s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_FENCE_PROPERTIES,
        p_next: *mut c_void,
        export_from_imported_handle_types: crate::data::ExternalFenceHandleTypeFlags,
        compatible_handle_types: crate::data::ExternalFenceHandleTypeFlags,
        external_fence_features: crate::data::ExternalFenceFeatureFlags,
    };
    struct ExportFenceCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::EXPORT_FENCE_CREATE_INFO,
        p_next: *const c_void,
        handle_types: crate::data::ExternalFenceHandleTypeFlags,
    };
    struct FenceGetWin32HandleInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::FENCE_GET_WIN32_HANDLE_INFO_KHR,
        p_next: *const c_void,
        fence: crate::data::Fence,
        handle_type: crate::data::ExternalFenceHandleTypeFlagBits,
    };
    struct ImportFenceFdInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_FENCE_FD_INFO_KHR,
        p_next: *const c_void,
        fence: crate::data::Fence,
        flags: crate::data::FenceImportFlags,
        handle_type: crate::data::ExternalFenceHandleTypeFlagBits,
        fd: c_int,
    };
    struct FenceGetFdInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::FENCE_GET_FD_INFO_KHR,
        p_next: *const c_void,
        fence: crate::data::Fence,
        handle_type: crate::data::ExternalFenceHandleTypeFlagBits,
    };
    struct PhysicalDeviceMultiviewFeatures {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
        p_next: *mut c_void,
        multiview: crate::data::Bool32,
        multiview_geometry_shader: crate::data::Bool32,
        multiview_tessellation_shader: crate::data::Bool32,
    };
    struct PhysicalDeviceMultiviewProperties {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
        p_next: *mut c_void,
        max_multiview_view_count: u32,
        max_multiview_instance_index: u32,
    };
    struct RenderPassMultiviewCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_MULTIVIEW_CREATE_INFO,
        p_next: *const c_void,
        subpass_count: u32,
        p_view_masks: *const u32,
        dependency_count: u32,
        p_view_offsets: *const i32,
        correlation_mask_count: u32,
        p_correlation_masks: *const u32,
    };
    struct SurfaceCapabilities2EXT {
        s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_CAPABILITIES_2_EXT,
        p_next: *mut c_void,
        min_image_count: u32,
        max_image_count: u32,
        current_extent: crate::data::Extent2D,
        min_image_extent: crate::data::Extent2D,
        max_image_extent: crate::data::Extent2D,
        max_image_array_layers: u32,
        supported_transforms: crate::data::SurfaceTransformFlagsKHR,
        current_transform: crate::data::SurfaceTransformFlagBitsKHR,
        supported_composite_alpha: crate::data::CompositeAlphaFlagsKHR,
        supported_usage_flags: crate::data::ImageUsageFlags,
        supported_surface_counters: crate::data::SurfaceCounterFlagsEXT,
    };
    struct DisplayPowerInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_POWER_INFO_EXT,
        p_next: *const c_void,
        power_state: crate::data::DisplayPowerStateEXT,
    };
    struct DeviceEventInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_EVENT_INFO_EXT,
        p_next: *const c_void,
        device_event: crate::data::DeviceEventTypeEXT,
    };
    struct DisplayEventInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_EVENT_INFO_EXT,
        p_next: *const c_void,
        display_event: crate::data::DisplayEventTypeEXT,
    };
    struct SwapchainCounterCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
        p_next: *const c_void,
        surface_counters: crate::data::SurfaceCounterFlagsEXT,
    };
    struct PhysicalDeviceGroupProperties {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_GROUP_PROPERTIES,
        p_next: *mut c_void,
        physical_device_count: u32,
        physical_devices: [crate::data::PhysicalDevice; 32],
        subset_allocation: crate::data::Bool32,
    };
    struct MemoryAllocateFlagsInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_ALLOCATE_FLAGS_INFO,
        p_next: *const c_void,
        flags: crate::data::MemoryAllocateFlags,
        device_mask: u32,
    };
    struct BindBufferMemoryInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::BIND_BUFFER_MEMORY_INFO,
        p_next: *const c_void,
        buffer: crate::data::Buffer,
        memory: crate::data::DeviceMemory,
        memory_offset: crate::data::DeviceSize,
    };
    struct BindBufferMemoryDeviceGroupInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
        p_next: *const c_void,
        device_index_count: u32,
        p_device_indices: *const u32,
    };
    struct BindImageMemoryInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::BIND_IMAGE_MEMORY_INFO,
        p_next: *const c_void,
        image: crate::data::Image,
        memory: crate::data::DeviceMemory,
        memory_offset: crate::data::DeviceSize,
    };
    struct BindImageMemoryDeviceGroupInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
        p_next: *const c_void,
        device_index_count: u32,
        p_device_indices: *const u32,
        split_instance_bind_region_count: u32,
        p_split_instance_bind_regions: *const crate::data::Rect2D,
    };
    struct DeviceGroupRenderPassBeginInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
        p_next: *const c_void,
        device_mask: u32,
        device_render_area_count: u32,
        p_device_render_areas: *const crate::data::Rect2D,
    };
    struct DeviceGroupCommandBufferBeginInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
        p_next: *const c_void,
        device_mask: u32,
    };
    struct DeviceGroupSubmitInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_SUBMIT_INFO,
        p_next: *const c_void,
        wait_semaphore_count: u32,
        p_wait_semaphore_device_indices: *const u32,
        command_buffer_count: u32,
        p_command_buffer_device_masks: *const u32,
        signal_semaphore_count: u32,
        p_signal_semaphore_device_indices: *const u32,
    };
    struct DeviceGroupBindSparseInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_BIND_SPARSE_INFO,
        p_next: *const c_void,
        resource_device_index: u32,
        memory_device_index: u32,
    };
    struct DeviceGroupPresentCapabilitiesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
        p_next: *const c_void,
        present_mask: [u32; 32],
        modes: crate::data::DeviceGroupPresentModeFlagsKHR,
    };
    struct ImageSwapchainCreateInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
        p_next: *const c_void,
        swapchain: crate::data::SwapchainKHR,
    };
    struct BindImageMemorySwapchainInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
        p_next: *const c_void,
        swapchain: crate::data::SwapchainKHR,
        image_index: u32,
    };
    struct AcquireNextImageInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::ACQUIRE_NEXT_IMAGE_INFO_KHR,
        p_next: *const c_void,
        swapchain: crate::data::SwapchainKHR,
        timeout: u64,
        semaphore: crate::data::Semaphore,
        fence: crate::data::Fence,
        device_mask: u32,
    };
    struct DeviceGroupPresentInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_PRESENT_INFO_KHR,
        p_next: *const c_void,
        swapchain_count: u32,
        p_device_masks: *const u32,
        mode: crate::data::DeviceGroupPresentModeFlagBitsKHR,
    };
    struct DeviceGroupDeviceCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_DEVICE_CREATE_INFO,
        p_next: *const c_void,
        physical_device_count: u32,
        p_physical_devices: *const crate::data::PhysicalDevice,
    };
    struct DeviceGroupSwapchainCreateInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
        p_next: *const c_void,
        modes: crate::data::DeviceGroupPresentModeFlagsKHR,
    };
    struct DescriptorUpdateTemplateEntry {
        dst_binding: u32,
        dst_array_element: u32,
        descriptor_count: u32,
        descriptor_type: crate::data::DescriptorType,
        offset: usize,
        stride: usize,
    };
    struct DescriptorUpdateTemplateCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
        p_next: *const c_void,
        flags: crate::data::DescriptorUpdateTemplateCreateFlags,
        descriptor_update_entry_count: u32,
        p_descriptor_update_entries: *const crate::data::DescriptorUpdateTemplateEntry,
        template_type: crate::data::DescriptorUpdateTemplateType,
        descriptor_set_layout: crate::data::DescriptorSetLayout,
        pipeline_bind_point: crate::data::PipelineBindPoint,
        pipeline_layout: crate::data::PipelineLayout,
        set: u32,
    };
    struct XYColorEXT {
        x: c_float,
        y: c_float,
    };
    struct HdrMetadataEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::HDR_METADATA_EXT,
        p_next: *const c_void,
        display_primary_red: crate::data::XYColorEXT,
        display_primary_green: crate::data::XYColorEXT,
        display_primary_blue: crate::data::XYColorEXT,
        white_point: crate::data::XYColorEXT,
        max_luminance: c_float,
        min_luminance: c_float,
        max_content_light_level: c_float,
        max_frame_average_light_level: c_float,
    };
    struct DisplayNativeHdrSurfaceCapabilitiesAMD {
        s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
        p_next: *mut c_void,
        local_dimming_support: crate::data::Bool32,
    };
    struct SwapchainDisplayNativeHdrCreateInfoAMD {
        s_type: crate::data::StructureType = crate::data::StructureType::SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
        p_next: *const c_void,
        local_dimming_enable: crate::data::Bool32,
    };
    struct RefreshCycleDurationGOOGLE {
        refresh_duration: u64,
    };
    struct PastPresentationTimingGOOGLE {
        present_id: u32,
        desired_present_time: u64,
        actual_present_time: u64,
        earliest_present_time: u64,
        present_margin: u64,
    };
    struct PresentTimesInfoGOOGLE {
        s_type: crate::data::StructureType = crate::data::StructureType::PRESENT_TIMES_INFO_GOOGLE,
        p_next: *const c_void,
        swapchain_count: u32,
        p_times: *const crate::data::PresentTimeGOOGLE,
    };
    struct PresentTimeGOOGLE {
        present_id: u32,
        desired_present_time: u64,
    };
    struct IOSSurfaceCreateInfoMVK {
        s_type: crate::data::StructureType = crate::data::StructureType::IOS_SURFACE_CREATE_INFO_MVK,
        p_next: *const c_void,
        flags: crate::data::IOSSurfaceCreateFlagsMVK,
        p_view: *const c_void,
    };
    struct MacOSSurfaceCreateInfoMVK {
        s_type: crate::data::StructureType = crate::data::StructureType::MACOS_SURFACE_CREATE_INFO_MVK,
        p_next: *const c_void,
        flags: crate::data::MacOSSurfaceCreateFlagsMVK,
        p_view: *const c_void,
    };
    struct ViewportWScalingNV {
        xcoeff: c_float,
        ycoeff: c_float,
    };
    struct PipelineViewportWScalingStateCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
        p_next: *const c_void,
        viewport_w_scaling_enable: crate::data::Bool32,
        viewport_count: u32,
        p_viewport_w_scalings: *const crate::data::ViewportWScalingNV,
    };
    struct ViewportSwizzleNV {
        x: crate::data::ViewportCoordinateSwizzleNV,
        y: crate::data::ViewportCoordinateSwizzleNV,
        z: crate::data::ViewportCoordinateSwizzleNV,
        w: crate::data::ViewportCoordinateSwizzleNV,
    };
    struct PipelineViewportSwizzleStateCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
        p_next: *const c_void,
        flags: crate::data::PipelineViewportSwizzleStateCreateFlagsNV,
        viewport_count: u32,
        p_viewport_swizzles: *const crate::data::ViewportSwizzleNV,
    };
    struct PhysicalDeviceDiscardRectanglePropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
        p_next: *mut c_void,
        max_discard_rectangles: u32,
    };
    struct PipelineDiscardRectangleStateCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
        p_next: *const c_void,
        flags: crate::data::PipelineDiscardRectangleStateCreateFlagsEXT,
        discard_rectangle_mode: crate::data::DiscardRectangleModeEXT,
        discard_rectangle_count: u32,
        p_discard_rectangles: *const crate::data::Rect2D,
    };
    struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
        p_next: *mut c_void,
        per_view_position_all_components: crate::data::Bool32,
    };
    struct InputAttachmentAspectReference {
        subpass: u32,
        input_attachment_index: u32,
        aspect_mask: crate::data::ImageAspectFlags,
    };
    struct RenderPassInputAttachmentAspectCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
        p_next: *const c_void,
        aspect_reference_count: u32,
        p_aspect_references: *const crate::data::InputAttachmentAspectReference,
    };
    struct PhysicalDeviceSurfaceInfo2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
        p_next: *const c_void,
        surface: crate::data::SurfaceKHR,
    };
    struct SurfaceCapabilities2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_CAPABILITIES_2_KHR,
        p_next: *mut c_void,
        surface_capabilities: crate::data::SurfaceCapabilitiesKHR,
    };
    struct SurfaceFormat2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_FORMAT_2_KHR,
        p_next: *mut c_void,
        surface_format: crate::data::SurfaceFormatKHR,
    };
    struct DisplayProperties2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_PROPERTIES_2_KHR,
        p_next: *mut c_void,
        display_properties: crate::data::DisplayPropertiesKHR,
    };
    struct DisplayPlaneProperties2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_PLANE_PROPERTIES_2_KHR,
        p_next: *mut c_void,
        display_plane_properties: crate::data::DisplayPlanePropertiesKHR,
    };
    struct DisplayModeProperties2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_MODE_PROPERTIES_2_KHR,
        p_next: *mut c_void,
        display_mode_properties: crate::data::DisplayModePropertiesKHR,
    };
    struct DisplayPlaneInfo2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_PLANE_INFO_2_KHR,
        p_next: *const c_void,
        mode: crate::data::DisplayModeKHR,
        plane_index: u32,
    };
    struct DisplayPlaneCapabilities2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::DISPLAY_PLANE_CAPABILITIES_2_KHR,
        p_next: *mut c_void,
        capabilities: crate::data::DisplayPlaneCapabilitiesKHR,
    };
    struct SharedPresentSurfaceCapabilitiesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
        p_next: *mut c_void,
        shared_present_supported_usage_flags: crate::data::ImageUsageFlags,
    };
    struct PhysicalDevice16BitStorageFeatures {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
        p_next: *mut c_void,
        storage_buffer_16_bit_access: crate::data::Bool32,
        uniform_and_storage_buffer_16_bit_access: crate::data::Bool32,
        storage_push_constant_16: crate::data::Bool32,
        storage_input_output_16: crate::data::Bool32,
    };
    struct PhysicalDeviceSubgroupProperties {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
        p_next: *mut c_void,
        subgroup_size: u32,
        supported_stages: crate::data::ShaderStageFlags,
        supported_operations: crate::data::SubgroupFeatureFlags,
        quad_operations_in_all_stages: crate::data::Bool32,
    };
    struct BufferMemoryRequirementsInfo2 {
        s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_MEMORY_REQUIREMENTS_INFO_2,
        p_next: *const c_void,
        buffer: crate::data::Buffer,
    };
    struct ImageMemoryRequirementsInfo2 {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_MEMORY_REQUIREMENTS_INFO_2,
        p_next: *const c_void,
        image: crate::data::Image,
    };
    struct ImageSparseMemoryRequirementsInfo2 {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
        p_next: *const c_void,
        image: crate::data::Image,
    };
    struct MemoryRequirements2 {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_REQUIREMENTS_2,
        p_next: *mut c_void,
        memory_requirements: crate::data::MemoryRequirements,
    };
    struct SparseImageMemoryRequirements2 {
        s_type: crate::data::StructureType = crate::data::StructureType::SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
        p_next: *mut c_void,
        memory_requirements: crate::data::SparseImageMemoryRequirements,
    };
    struct PhysicalDevicePointClippingProperties {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
        p_next: *mut c_void,
        point_clipping_behavior: crate::data::PointClippingBehavior,
    };
    struct MemoryDedicatedRequirements {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_DEDICATED_REQUIREMENTS,
        p_next: *mut c_void,
        prefers_dedicated_allocation: crate::data::Bool32,
        requires_dedicated_allocation: crate::data::Bool32,
    };
    struct MemoryDedicatedAllocateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_DEDICATED_ALLOCATE_INFO,
        p_next: *const c_void,
        image: crate::data::Image,
        buffer: crate::data::Buffer,
    };
    struct ImageViewUsageCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_VIEW_USAGE_CREATE_INFO,
        p_next: *const c_void,
        usage: crate::data::ImageUsageFlags,
    };
    struct PipelineTessellationDomainOriginStateCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
        p_next: *const c_void,
        domain_origin: crate::data::TessellationDomainOrigin,
    };
    struct SamplerYcbcrConversionInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::SAMPLER_YCBCR_CONVERSION_INFO,
        p_next: *const c_void,
        conversion: crate::data::SamplerYcbcrConversion,
    };
    struct SamplerYcbcrConversionCreateInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
        p_next: *const c_void,
        format: crate::data::Format,
        ycbcr_model: crate::data::SamplerYcbcrModelConversion,
        ycbcr_range: crate::data::SamplerYcbcrRange,
        components: crate::data::ComponentMapping,
        x_chroma_offset: crate::data::ChromaLocation,
        y_chroma_offset: crate::data::ChromaLocation,
        chroma_filter: crate::data::Filter,
        force_explicit_reconstruction: crate::data::Bool32,
    };
    struct BindImagePlaneMemoryInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::BIND_IMAGE_PLANE_MEMORY_INFO,
        p_next: *const c_void,
        plane_aspect: crate::data::ImageAspectFlagBits,
    };
    struct ImagePlaneMemoryRequirementsInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
        p_next: *const c_void,
        plane_aspect: crate::data::ImageAspectFlagBits,
    };
    struct PhysicalDeviceSamplerYcbcrConversionFeatures {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
        p_next: *mut c_void,
        sampler_ycbcr_conversion: crate::data::Bool32,
    };
    struct SamplerYcbcrConversionImageFormatProperties {
        s_type: crate::data::StructureType = crate::data::StructureType::SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
        p_next: *mut c_void,
        combined_image_sampler_descriptor_count: u32,
    };
    struct TextureLODGatherFormatPropertiesAMD {
        s_type: crate::data::StructureType = crate::data::StructureType::TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
        p_next: *mut c_void,
        supports_texture_gather_lod_bias_amd: crate::data::Bool32,
    };
    struct ConditionalRenderingBeginInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
        p_next: *const c_void,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        flags: crate::data::ConditionalRenderingFlagsEXT,
    };
    struct ProtectedSubmitInfo {
        s_type: crate::data::StructureType = crate::data::StructureType::PROTECTED_SUBMIT_INFO,
        p_next: *const c_void,
        protected_submit: crate::data::Bool32,
    };
    struct PhysicalDeviceProtectedMemoryFeatures {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
        p_next: *mut c_void,
        protected_memory: crate::data::Bool32,
    };
    struct PhysicalDeviceProtectedMemoryProperties {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
        p_next: *mut c_void,
        protected_no_fault: crate::data::Bool32,
    };
    struct DeviceQueueInfo2 {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_QUEUE_INFO_2,
        p_next: *const c_void,
        flags: crate::data::DeviceQueueCreateFlags,
        queue_family_index: u32,
        queue_index: u32,
    };
    struct PipelineCoverageToColorStateCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
        p_next: *const c_void,
        flags: crate::data::PipelineCoverageToColorStateCreateFlagsNV,
        coverage_to_color_enable: crate::data::Bool32,
        coverage_to_color_location: u32,
    };
    struct PhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT,
        p_next: *mut c_void,
        filter_minmax_single_component_formats: crate::data::Bool32,
        filter_minmax_image_component_mapping: crate::data::Bool32,
    };
    struct SampleLocationEXT {
        x: c_float,
        y: c_float,
    };
    struct SampleLocationsInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::SAMPLE_LOCATIONS_INFO_EXT,
        p_next: *const c_void,
        sample_locations_per_pixel: crate::data::SampleCountFlagBits,
        sample_location_grid_size: crate::data::Extent2D,
        sample_locations_count: u32,
        p_sample_locations: *const crate::data::SampleLocationEXT,
    };
    struct AttachmentSampleLocationsEXT {
        attachment_index: u32,
        sample_locations_info: crate::data::SampleLocationsInfoEXT,
    };
    struct SubpassSampleLocationsEXT {
        subpass_index: u32,
        sample_locations_info: crate::data::SampleLocationsInfoEXT,
    };
    struct RenderPassSampleLocationsBeginInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
        p_next: *const c_void,
        attachment_initial_sample_locations_count: u32,
        p_attachment_initial_sample_locations: *const crate::data::AttachmentSampleLocationsEXT,
        post_subpass_sample_locations_count: u32,
        p_post_subpass_sample_locations: *const crate::data::SubpassSampleLocationsEXT,
    };
    struct PipelineSampleLocationsStateCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
        p_next: *const c_void,
        sample_locations_enable: crate::data::Bool32,
        sample_locations_info: crate::data::SampleLocationsInfoEXT,
    };
    struct PhysicalDeviceSampleLocationsPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
        p_next: *mut c_void,
        sample_location_sample_counts: crate::data::SampleCountFlags,
        max_sample_location_grid_size: crate::data::Extent2D,
        sample_location_coordinate_range: [c_float; 2],
        sample_location_sub_pixel_bits: u32,
        variable_sample_locations: crate::data::Bool32,
    };
    struct MultisamplePropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::MULTISAMPLE_PROPERTIES_EXT,
        p_next: *mut c_void,
        max_sample_location_grid_size: crate::data::Extent2D,
    };
    struct SamplerReductionModeCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT,
        p_next: *const c_void,
        reduction_mode: crate::data::SamplerReductionModeEXT,
    };
    struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
        p_next: *mut c_void,
        advanced_blend_coherent_operations: crate::data::Bool32,
    };
    struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
        p_next: *mut c_void,
        advanced_blend_max_color_attachments: u32,
        advanced_blend_independent_blend: crate::data::Bool32,
        advanced_blend_non_premultiplied_src_color: crate::data::Bool32,
        advanced_blend_non_premultiplied_dst_color: crate::data::Bool32,
        advanced_blend_correlated_overlap: crate::data::Bool32,
        advanced_blend_all_operations: crate::data::Bool32,
    };
    struct PipelineColorBlendAdvancedStateCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
        p_next: *const c_void,
        src_premultiplied: crate::data::Bool32,
        dst_premultiplied: crate::data::Bool32,
        blend_overlap: crate::data::BlendOverlapEXT,
    };
    struct PhysicalDeviceInlineUniformBlockFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT,
        p_next: *mut c_void,
        inline_uniform_block: crate::data::Bool32,
        descriptor_binding_inline_uniform_block_update_after_bind: crate::data::Bool32,
    };
    struct PhysicalDeviceInlineUniformBlockPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT,
        p_next: *mut c_void,
        max_inline_uniform_block_size: u32,
        max_per_stage_descriptor_inline_uniform_blocks: u32,
        max_per_stage_descriptor_update_after_bind_inline_uniform_blocks: u32,
        max_descriptor_set_inline_uniform_blocks: u32,
        max_descriptor_set_update_after_bind_inline_uniform_blocks: u32,
    };
    struct WriteDescriptorSetInlineUniformBlockEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT,
        p_next: *const c_void,
        data_size: u32,
        p_data: *const c_void,
    };
    struct DescriptorPoolInlineUniformBlockCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT,
        p_next: *const c_void,
        max_inline_uniform_block_bindings: u32,
    };
    struct PipelineCoverageModulationStateCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
        p_next: *const c_void,
        flags: crate::data::PipelineCoverageModulationStateCreateFlagsNV,
        coverage_modulation_mode: crate::data::CoverageModulationModeNV,
        coverage_modulation_table_enable: crate::data::Bool32,
        coverage_modulation_table_count: u32,
        p_coverage_modulation_table: *const c_float,
    };
    struct ImageFormatListCreateInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_FORMAT_LIST_CREATE_INFO_KHR,
        p_next: *const c_void,
        view_format_count: u32,
        p_view_formats: *const crate::data::Format,
    };
    struct ValidationCacheCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::VALIDATION_CACHE_CREATE_INFO_EXT,
        p_next: *const c_void,
        flags: crate::data::ValidationCacheCreateFlagsEXT,
        initial_data_size: usize,
        p_initial_data: *const c_void,
    };
    struct ShaderModuleValidationCacheCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
        p_next: *const c_void,
        validation_cache: crate::data::ValidationCacheEXT,
    };
    struct PhysicalDeviceMaintenance3Properties {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
        p_next: *mut c_void,
        max_per_set_descriptors: u32,
        max_memory_allocation_size: crate::data::DeviceSize,
    };
    struct DescriptorSetLayoutSupport {
        s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_LAYOUT_SUPPORT,
        p_next: *mut c_void,
        supported: crate::data::Bool32,
    };
    struct PhysicalDeviceShaderDrawParameterFeatures {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES,
        p_next: *mut c_void,
        shader_draw_parameters: crate::data::Bool32,
    };
    struct PhysicalDeviceFloat16Int8FeaturesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR,
        p_next: *mut c_void,
        shader_float_16: crate::data::Bool32,
        shader_int_8: crate::data::Bool32,
    };
    struct PhysicalDeviceFloatControlsPropertiesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR,
        p_next: *mut c_void,
        separate_denorm_settings: crate::data::Bool32,
        separate_rounding_mode_settings: crate::data::Bool32,
        shader_signed_zero_inf_nan_preserve_float_16: crate::data::Bool32,
        shader_signed_zero_inf_nan_preserve_float_32: crate::data::Bool32,
        shader_signed_zero_inf_nan_preserve_float_64: crate::data::Bool32,
        shader_denorm_preserve_float_16: crate::data::Bool32,
        shader_denorm_preserve_float_32: crate::data::Bool32,
        shader_denorm_preserve_float_64: crate::data::Bool32,
        shader_denorm_flush_to_zero_float_16: crate::data::Bool32,
        shader_denorm_flush_to_zero_float_32: crate::data::Bool32,
        shader_denorm_flush_to_zero_float_64: crate::data::Bool32,
        shader_rounding_mode_rte_float_16: crate::data::Bool32,
        shader_rounding_mode_rte_float_32: crate::data::Bool32,
        shader_rounding_mode_rte_float_64: crate::data::Bool32,
        shader_rounding_mode_rtz_float_16: crate::data::Bool32,
        shader_rounding_mode_rtz_float_32: crate::data::Bool32,
        shader_rounding_mode_rtz_float_64: crate::data::Bool32,
    };
    struct PhysicalDeviceHostQueryResetFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT,
        p_next: *mut c_void,
        host_query_reset: crate::data::Bool32,
    };
    struct NativeBufferANDROID {
        s_type: crate::data::StructureType = crate::data::StructureType::NATIVE_BUFFER_ANDROID,
        p_next: *const c_void,
        handle: *const c_void,
        stride: c_int,
        format: c_int,
        usage: c_int,
    };
    struct ShaderResourceUsageAMD {
        num_used_vgprs: u32,
        num_used_sgprs: u32,
        lds_size_per_local_work_group: u32,
        lds_usage_size_in_bytes: usize,
        scratch_mem_usage_in_bytes: usize,
    };
    struct ShaderStatisticsInfoAMD {
        shader_stage_mask: crate::data::ShaderStageFlags,
        resource_usage: crate::data::ShaderResourceUsageAMD,
        num_physical_vgprs: u32,
        num_physical_sgprs: u32,
        num_available_vgprs: u32,
        num_available_sgprs: u32,
        compute_work_group_size: [u32; 3],
    };
    struct DeviceQueueGlobalPriorityCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT,
        p_next: *const c_void,
        global_priority: crate::data::QueueGlobalPriorityEXT,
    };
    struct DebugUtilsObjectNameInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
        p_next: *const c_void,
        object_type: crate::data::ObjectType,
        object_handle: u64,
        p_object_name: *const c_char,
    };
    struct DebugUtilsObjectTagInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
        p_next: *const c_void,
        object_type: crate::data::ObjectType,
        object_handle: u64,
        tag_name: u64,
        tag_size: usize,
        p_tag: *const c_void,
    };
    struct DebugUtilsLabelEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_UTILS_LABEL_EXT,
        p_next: *const c_void,
        p_label_name: *const c_char,
        color: [c_float; 4],
    };
    struct DebugUtilsMessengerCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
        p_next: *const c_void,
        flags: crate::data::DebugUtilsMessengerCreateFlagsEXT,
        message_severity: crate::data::DebugUtilsMessageSeverityFlagsEXT,
        message_type: crate::data::DebugUtilsMessageTypeFlagsEXT,
        pfn_user_callback: crate::pfn::DebugUtilsMessengerCallbackEXT,
        p_user_data: *mut c_void,
    };
    struct DebugUtilsMessengerCallbackDataEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
        p_next: *const c_void,
        flags: crate::data::DebugUtilsMessengerCallbackDataFlagsEXT,
        p_message_id_name: *const c_char,
        message_id_number: i32,
        p_message: *const c_char,
        queue_label_count: u32,
        p_queue_labels: *const crate::data::DebugUtilsLabelEXT,
        cmd_buf_label_count: u32,
        p_cmd_buf_labels: *const crate::data::DebugUtilsLabelEXT,
        object_count: u32,
        p_objects: *const crate::data::DebugUtilsObjectNameInfoEXT,
    };
    struct ImportMemoryHostPointerInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
        p_next: *const c_void,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        p_host_pointer: *mut c_void,
    };
    struct MemoryHostPointerPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_HOST_POINTER_PROPERTIES_EXT,
        p_next: *mut c_void,
        memory_type_bits: u32,
    };
    struct PhysicalDeviceExternalMemoryHostPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
        p_next: *mut c_void,
        min_imported_host_pointer_alignment: crate::data::DeviceSize,
    };
    struct PhysicalDeviceConservativeRasterizationPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
        p_next: *mut c_void,
        primitive_overestimation_size: c_float,
        max_extra_primitive_overestimation_size: c_float,
        extra_primitive_overestimation_size_granularity: c_float,
        primitive_underestimation: crate::data::Bool32,
        conservative_point_and_line_rasterization: crate::data::Bool32,
        degenerate_triangles_rasterized: crate::data::Bool32,
        degenerate_lines_rasterized: crate::data::Bool32,
        fully_covered_fragment_shader_input_variable: crate::data::Bool32,
        conservative_rasterization_post_depth_coverage: crate::data::Bool32,
    };
    struct CalibratedTimestampInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::CALIBRATED_TIMESTAMP_INFO_EXT,
        p_next: *const c_void,
        time_domain: crate::data::TimeDomainEXT,
    };
    struct PhysicalDeviceShaderCorePropertiesAMD {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
        p_next: *mut c_void,
        shader_engine_count: u32,
        shader_arrays_per_engine_count: u32,
        compute_units_per_shader_array: u32,
        simd_per_compute_unit: u32,
        wavefronts_per_simd: u32,
        wavefront_size: u32,
        sgprs_per_simd: u32,
        min_sgpr_allocation: u32,
        max_sgpr_allocation: u32,
        sgpr_allocation_granularity: u32,
        vgprs_per_simd: u32,
        min_vgpr_allocation: u32,
        max_vgpr_allocation: u32,
        vgpr_allocation_granularity: u32,
    };
    struct PipelineRasterizationConservativeStateCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
        p_next: *const c_void,
        flags: crate::data::PipelineRasterizationConservativeStateCreateFlagsEXT,
        conservative_rasterization_mode: crate::data::ConservativeRasterizationModeEXT,
        extra_primitive_overestimation_size: c_float,
    };
    struct PhysicalDeviceDescriptorIndexingFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT,
        p_next: *mut c_void,
        shader_input_attachment_array_dynamic_indexing: crate::data::Bool32,
        shader_uniform_texel_buffer_array_dynamic_indexing: crate::data::Bool32,
        shader_storage_texel_buffer_array_dynamic_indexing: crate::data::Bool32,
        shader_uniform_buffer_array_non_uniform_indexing: crate::data::Bool32,
        shader_sampled_image_array_non_uniform_indexing: crate::data::Bool32,
        shader_storage_buffer_array_non_uniform_indexing: crate::data::Bool32,
        shader_storage_image_array_non_uniform_indexing: crate::data::Bool32,
        shader_input_attachment_array_non_uniform_indexing: crate::data::Bool32,
        shader_uniform_texel_buffer_array_non_uniform_indexing: crate::data::Bool32,
        shader_storage_texel_buffer_array_non_uniform_indexing: crate::data::Bool32,
        descriptor_binding_uniform_buffer_update_after_bind: crate::data::Bool32,
        descriptor_binding_sampled_image_update_after_bind: crate::data::Bool32,
        descriptor_binding_storage_image_update_after_bind: crate::data::Bool32,
        descriptor_binding_storage_buffer_update_after_bind: crate::data::Bool32,
        descriptor_binding_uniform_texel_buffer_update_after_bind: crate::data::Bool32,
        descriptor_binding_storage_texel_buffer_update_after_bind: crate::data::Bool32,
        descriptor_binding_update_unused_while_pending: crate::data::Bool32,
        descriptor_binding_partially_bound: crate::data::Bool32,
        descriptor_binding_variable_descriptor_count: crate::data::Bool32,
        runtime_descriptor_array: crate::data::Bool32,
    };
    struct PhysicalDeviceDescriptorIndexingPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT,
        p_next: *mut c_void,
        max_update_after_bind_descriptors_in_all_pools: u32,
        shader_uniform_buffer_array_non_uniform_indexing_native: crate::data::Bool32,
        shader_sampled_image_array_non_uniform_indexing_native: crate::data::Bool32,
        shader_storage_buffer_array_non_uniform_indexing_native: crate::data::Bool32,
        shader_storage_image_array_non_uniform_indexing_native: crate::data::Bool32,
        shader_input_attachment_array_non_uniform_indexing_native: crate::data::Bool32,
        robust_buffer_access_update_after_bind: crate::data::Bool32,
        quad_divergent_implicit_lod: crate::data::Bool32,
        max_per_stage_descriptor_update_after_bind_samplers: u32,
        max_per_stage_descriptor_update_after_bind_uniform_buffers: u32,
        max_per_stage_descriptor_update_after_bind_storage_buffers: u32,
        max_per_stage_descriptor_update_after_bind_sampled_images: u32,
        max_per_stage_descriptor_update_after_bind_storage_images: u32,
        max_per_stage_descriptor_update_after_bind_input_attachments: u32,
        max_per_stage_update_after_bind_resources: u32,
        max_descriptor_set_update_after_bind_samplers: u32,
        max_descriptor_set_update_after_bind_uniform_buffers: u32,
        max_descriptor_set_update_after_bind_uniform_buffers_dynamic: u32,
        max_descriptor_set_update_after_bind_storage_buffers: u32,
        max_descriptor_set_update_after_bind_storage_buffers_dynamic: u32,
        max_descriptor_set_update_after_bind_sampled_images: u32,
        max_descriptor_set_update_after_bind_storage_images: u32,
        max_descriptor_set_update_after_bind_input_attachments: u32,
    };
    struct DescriptorSetLayoutBindingFlagsCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
        p_next: *const c_void,
        binding_count: u32,
        p_binding_flags: *const crate::data::DescriptorBindingFlagsEXT,
    };
    struct DescriptorSetVariableDescriptorCountAllocateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT,
        p_next: *const c_void,
        descriptor_set_count: u32,
        p_descriptor_counts: *const u32,
    };
    struct DescriptorSetVariableDescriptorCountLayoutSupportEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT,
        p_next: *mut c_void,
        max_variable_descriptor_count: u32,
    };
    struct AttachmentDescription2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::ATTACHMENT_DESCRIPTION_2_KHR,
        p_next: *const c_void,
        flags: crate::data::AttachmentDescriptionFlags,
        format: crate::data::Format,
        samples: crate::data::SampleCountFlagBits,
        load_op: crate::data::AttachmentLoadOp,
        store_op: crate::data::AttachmentStoreOp,
        stencil_load_op: crate::data::AttachmentLoadOp,
        stencil_store_op: crate::data::AttachmentStoreOp,
        initial_layout: crate::data::ImageLayout,
        final_layout: crate::data::ImageLayout,
    };
    struct AttachmentReference2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::ATTACHMENT_REFERENCE_2_KHR,
        p_next: *const c_void,
        attachment: u32,
        layout: crate::data::ImageLayout,
        aspect_mask: crate::data::ImageAspectFlags,
    };
    struct SubpassDescription2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_DESCRIPTION_2_KHR,
        p_next: *const c_void,
        flags: crate::data::SubpassDescriptionFlags,
        pipeline_bind_point: crate::data::PipelineBindPoint,
        view_mask: u32,
        input_attachment_count: u32,
        p_input_attachments: *const crate::data::AttachmentReference2KHR,
        color_attachment_count: u32,
        p_color_attachments: *const crate::data::AttachmentReference2KHR,
        p_resolve_attachments: *const crate::data::AttachmentReference2KHR,
        p_depth_stencil_attachment: *const crate::data::AttachmentReference2KHR,
        preserve_attachment_count: u32,
        p_preserve_attachments: *const u32,
    };
    struct SubpassDependency2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_DEPENDENCY_2_KHR,
        p_next: *const c_void,
        src_subpass: u32,
        dst_subpass: u32,
        src_stage_mask: crate::data::PipelineStageFlags,
        dst_stage_mask: crate::data::PipelineStageFlags,
        src_access_mask: crate::data::AccessFlags,
        dst_access_mask: crate::data::AccessFlags,
        dependency_flags: crate::data::DependencyFlags,
        view_offset: i32,
    };
    struct RenderPassCreateInfo2KHR {
        s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_CREATE_INFO_2_KHR,
        p_next: *const c_void,
        flags: crate::data::RenderPassCreateFlags,
        attachment_count: u32,
        p_attachments: *const crate::data::AttachmentDescription2KHR,
        subpass_count: u32,
        p_subpasses: *const crate::data::SubpassDescription2KHR,
        dependency_count: u32,
        p_dependencies: *const crate::data::SubpassDependency2KHR,
        correlated_view_mask_count: u32,
        p_correlated_view_masks: *const u32,
    };
    struct SubpassBeginInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_BEGIN_INFO_KHR,
        p_next: *const c_void,
        contents: crate::data::SubpassContents,
    };
    struct SubpassEndInfoKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_END_INFO_KHR,
        p_next: *const c_void,
    };
    struct VertexInputBindingDivisorDescriptionEXT {
        binding: u32,
        divisor: u32,
    };
    struct PipelineVertexInputDivisorStateCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
        p_next: *const c_void,
        vertex_binding_divisor_count: u32,
        p_vertex_binding_divisors: *const crate::data::VertexInputBindingDivisorDescriptionEXT,
    };
    struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
        p_next: *mut c_void,
        max_vertex_attrib_divisor: u32,
    };
    struct PhysicalDevicePCIBusInfoPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
        p_next: *mut c_void,
        pci_domain: u32,
        pci_bus: u32,
        pci_device: u32,
        pci_function: u32,
    };
    struct AndroidHardwareBufferUsageANDROID {
        s_type: crate::data::StructureType = crate::data::StructureType::ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
        p_next: *mut c_void,
        android_hardware_buffer_usage: u64,
    };
    struct AndroidHardwareBufferPropertiesANDROID {
        s_type: crate::data::StructureType = crate::data::StructureType::ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
        p_next: *mut c_void,
        allocation_size: crate::data::DeviceSize,
        memory_type_bits: u32,
    };
    struct MemoryGetAndroidHardwareBufferInfoANDROID {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
        p_next: *const c_void,
        memory: crate::data::DeviceMemory,
    };
    struct AndroidHardwareBufferFormatPropertiesANDROID {
        s_type: crate::data::StructureType = crate::data::StructureType::ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
        p_next: *mut c_void,
        format: crate::data::Format,
        external_format: u64,
        format_features: crate::data::FormatFeatureFlags,
        sampler_ycbcr_conversion_components: crate::data::ComponentMapping,
        suggested_ycbcr_model: crate::data::SamplerYcbcrModelConversion,
        suggested_ycbcr_range: crate::data::SamplerYcbcrRange,
        suggested_x_chroma_offset: crate::data::ChromaLocation,
        suggested_y_chroma_offset: crate::data::ChromaLocation,
    };
    struct CommandBufferInheritanceConditionalRenderingInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
        p_next: *const c_void,
        conditional_rendering_enable: crate::data::Bool32,
    };
    struct ExternalFormatANDROID {
        s_type: crate::data::StructureType = crate::data::StructureType::EXTERNAL_FORMAT_ANDROID,
        p_next: *mut c_void,
        external_format: u64,
    };
    struct PhysicalDevice8BitStorageFeaturesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR,
        p_next: *mut c_void,
        storage_buffer_8_bit_access: crate::data::Bool32,
        uniform_and_storage_buffer_8_bit_access: crate::data::Bool32,
        storage_push_constant_8: crate::data::Bool32,
    };
    struct PhysicalDeviceConditionalRenderingFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
        p_next: *mut c_void,
        conditional_rendering: crate::data::Bool32,
        inherited_conditional_rendering: crate::data::Bool32,
    };
    struct PhysicalDeviceVulkanMemoryModelFeaturesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR,
        p_next: *mut c_void,
        vulkan_memory_model: crate::data::Bool32,
        vulkan_memory_model_device_scope: crate::data::Bool32,
        vulkan_memory_model_availability_visibility_chains: crate::data::Bool32,
    };
    struct PhysicalDeviceShaderAtomicInt64FeaturesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR,
        p_next: *mut c_void,
        shader_buffer_int_64_atomics: crate::data::Bool32,
        shader_shared_int_64_atomics: crate::data::Bool32,
    };
    struct PhysicalDeviceVertexAttributeDivisorFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT,
        p_next: *mut c_void,
        vertex_attribute_instance_rate_divisor: crate::data::Bool32,
        vertex_attribute_instance_rate_zero_divisor: crate::data::Bool32,
    };
    struct QueueFamilyCheckpointPropertiesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
        p_next: *mut c_void,
        checkpoint_execution_stage_mask: crate::data::PipelineStageFlags,
    };
    struct CheckpointDataNV {
        s_type: crate::data::StructureType = crate::data::StructureType::CHECKPOINT_DATA_NV,
        p_next: *mut c_void,
        stage: crate::data::PipelineStageFlagBits,
        p_checkpoint_marker: *mut c_void,
    };
    struct PhysicalDeviceDepthStencilResolvePropertiesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR,
        p_next: *mut c_void,
        supported_depth_resolve_modes: crate::data::ResolveModeFlagsKHR,
        supported_stencil_resolve_modes: crate::data::ResolveModeFlagsKHR,
        independent_resolve_none: crate::data::Bool32,
        independent_resolve: crate::data::Bool32,
    };
    struct SubpassDescriptionDepthStencilResolveKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR,
        p_next: *const c_void,
        depth_resolve_mode: crate::data::ResolveModeFlagBitsKHR,
        stencil_resolve_mode: crate::data::ResolveModeFlagBitsKHR,
        p_depth_stencil_resolve_attachment: *const crate::data::AttachmentReference2KHR,
    };
    struct ImageViewASTCDecodeModeEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
        p_next: *const c_void,
        decode_mode: crate::data::Format,
    };
    struct PhysicalDeviceASTCDecodeFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
        p_next: *mut c_void,
        decode_mode_shared_exponent: crate::data::Bool32,
    };
    struct PhysicalDeviceTransformFeedbackFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
        p_next: *mut c_void,
        transform_feedback: crate::data::Bool32,
        geometry_streams: crate::data::Bool32,
    };
    struct PhysicalDeviceTransformFeedbackPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
        p_next: *mut c_void,
        max_transform_feedback_streams: u32,
        max_transform_feedback_buffers: u32,
        max_transform_feedback_buffer_size: crate::data::DeviceSize,
        max_transform_feedback_stream_data_size: u32,
        max_transform_feedback_buffer_data_size: u32,
        max_transform_feedback_buffer_data_stride: u32,
        transform_feedback_queries: crate::data::Bool32,
        transform_feedback_streams_lines_triangles: crate::data::Bool32,
        transform_feedback_rasterization_stream_select: crate::data::Bool32,
        transform_feedback_draw: crate::data::Bool32,
    };
    struct PipelineRasterizationStateStreamCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
        p_next: *const c_void,
        flags: crate::data::PipelineRasterizationStateStreamCreateFlagsEXT,
        rasterization_stream: u32,
    };
    struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
        p_next: *mut c_void,
        representative_fragment_test: crate::data::Bool32,
    };
    struct PipelineRepresentativeFragmentTestStateCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
        p_next: *const c_void,
        representative_fragment_test_enable: crate::data::Bool32,
    };
    struct PhysicalDeviceExclusiveScissorFeaturesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
        p_next: *mut c_void,
        exclusive_scissor: crate::data::Bool32,
    };
    struct PipelineViewportExclusiveScissorStateCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
        p_next: *const c_void,
        exclusive_scissor_count: u32,
        p_exclusive_scissors: *const crate::data::Rect2D,
    };
    struct PhysicalDeviceCornerSampledImageFeaturesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
        p_next: *mut c_void,
        corner_sampled_image: crate::data::Bool32,
    };
    struct PhysicalDeviceComputeShaderDerivativesFeaturesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV,
        p_next: *mut c_void,
        compute_derivative_group_quads: crate::data::Bool32,
        compute_derivative_group_linear: crate::data::Bool32,
    };
    struct PhysicalDeviceFragmentShaderBarycentricFeaturesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV,
        p_next: *mut c_void,
        fragment_shader_barycentric: crate::data::Bool32,
    };
    struct PhysicalDeviceShaderImageFootprintFeaturesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
        p_next: *mut c_void,
        image_footprint: crate::data::Bool32,
    };
    struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
        p_next: *mut c_void,
        dedicated_allocation_image_aliasing: crate::data::Bool32,
    };
    struct ShadingRatePaletteNV {
        shading_rate_palette_entry_count: u32,
        p_shading_rate_palette_entries: *const crate::data::ShadingRatePaletteEntryNV,
    };
    struct PipelineViewportShadingRateImageStateCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
        p_next: *const c_void,
        shading_rate_image_enable: crate::data::Bool32,
        viewport_count: u32,
        p_shading_rate_palettes: *const crate::data::ShadingRatePaletteNV,
    };
    struct PhysicalDeviceShadingRateImageFeaturesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
        p_next: *mut c_void,
        shading_rate_image: crate::data::Bool32,
        shading_rate_coarse_sample_order: crate::data::Bool32,
    };
    struct PhysicalDeviceShadingRateImagePropertiesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
        p_next: *mut c_void,
        shading_rate_texel_size: crate::data::Extent2D,
        shading_rate_palette_size: u32,
        shading_rate_max_coarse_samples: u32,
    };
    struct CoarseSampleLocationNV {
        pixel_x: u32,
        pixel_y: u32,
        sample: u32,
    };
    struct CoarseSampleOrderCustomNV {
        shading_rate: crate::data::ShadingRatePaletteEntryNV,
        sample_count: u32,
        sample_location_count: u32,
        p_sample_locations: *const crate::data::CoarseSampleLocationNV,
    };
    struct PipelineViewportCoarseSampleOrderStateCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
        p_next: *const c_void,
        sample_order_type: crate::data::CoarseSampleOrderTypeNV,
        custom_sample_order_count: u32,
        p_custom_sample_orders: *const crate::data::CoarseSampleOrderCustomNV,
    };
    struct PhysicalDeviceMeshShaderFeaturesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
        p_next: *mut c_void,
        task_shader: crate::data::Bool32,
        mesh_shader: crate::data::Bool32,
    };
    struct PhysicalDeviceMeshShaderPropertiesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
        p_next: *mut c_void,
        max_draw_mesh_tasks_count: u32,
        max_task_work_group_invocations: u32,
        max_task_work_group_size: [u32; 3],
        max_task_total_memory_size: u32,
        max_task_output_count: u32,
        max_mesh_work_group_invocations: u32,
        max_mesh_work_group_size: [u32; 3],
        max_mesh_total_memory_size: u32,
        max_mesh_output_vertices: u32,
        max_mesh_output_primitives: u32,
        max_mesh_multiview_view_count: u32,
        mesh_output_per_vertex_granularity: u32,
        mesh_output_per_primitive_granularity: u32,
    };
    struct DrawMeshTasksIndirectCommandNV {
        task_count: u32,
        first_task: u32,
    };
    struct RayTracingShaderGroupCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV,
        p_next: *const c_void,
        ty: crate::data::RayTracingShaderGroupTypeNV,
        general_shader: u32,
        closest_hit_shader: u32,
        any_hit_shader: u32,
        intersection_shader: u32,
    };
    struct RayTracingPipelineCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::RAY_TRACING_PIPELINE_CREATE_INFO_NV,
        p_next: *const c_void,
        flags: crate::data::PipelineCreateFlags,
        stage_count: u32,
        p_stages: *const crate::data::PipelineShaderStageCreateInfo,
        group_count: u32,
        p_groups: *const crate::data::RayTracingShaderGroupCreateInfoNV,
        max_recursion_depth: u32,
        layout: crate::data::PipelineLayout,
        base_pipeline_handle: crate::data::Pipeline,
        base_pipeline_index: i32,
    };
    struct GeometryTrianglesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::GEOMETRY_TRIANGLES_NV,
        p_next: *const c_void,
        vertex_data: crate::data::Buffer,
        vertex_offset: crate::data::DeviceSize,
        vertex_count: u32,
        vertex_stride: crate::data::DeviceSize,
        vertex_format: crate::data::Format,
        index_data: crate::data::Buffer,
        index_offset: crate::data::DeviceSize,
        index_count: u32,
        index_type: crate::data::IndexType,
        transform_data: crate::data::Buffer,
        transform_offset: crate::data::DeviceSize,
    };
    struct GeometryAABBNV {
        s_type: crate::data::StructureType = crate::data::StructureType::GEOMETRY_AABB_NV,
        p_next: *const c_void,
        aabb_data: crate::data::Buffer,
        num_aab_bs: u32,
        stride: u32,
        offset: crate::data::DeviceSize,
    };
    struct GeometryDataNV {
        triangles: crate::data::GeometryTrianglesNV,
        aabbs: crate::data::GeometryAABBNV,
    };
    struct GeometryNV {
        s_type: crate::data::StructureType = crate::data::StructureType::GEOMETRY_NV,
        p_next: *const c_void,
        geometry_type: crate::data::GeometryTypeNV,
        geometry: crate::data::GeometryDataNV,
        flags: crate::data::GeometryFlagsNV,
    };
    struct AccelerationStructureInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_INFO_NV,
        p_next: *const c_void,
        ty: crate::data::AccelerationStructureTypeNV,
        flags: crate::data::BuildAccelerationStructureFlagsNV,
        instance_count: u32,
        geometry_count: u32,
        p_geometries: *const crate::data::GeometryNV,
    };
    struct AccelerationStructureCreateInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_CREATE_INFO_NV,
        p_next: *const c_void,
        compacted_size: crate::data::DeviceSize,
        info: crate::data::AccelerationStructureInfoNV,
    };
    struct BindAccelerationStructureMemoryInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV,
        p_next: *const c_void,
        acceleration_structure: crate::data::AccelerationStructureNV,
        memory: crate::data::DeviceMemory,
        memory_offset: crate::data::DeviceSize,
        device_index_count: u32,
        p_device_indices: *const u32,
    };
    struct WriteDescriptorSetAccelerationStructureNV {
        s_type: crate::data::StructureType = crate::data::StructureType::WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
        p_next: *const c_void,
        acceleration_structure_count: u32,
        p_acceleration_structures: *const crate::data::AccelerationStructureNV,
    };
    struct AccelerationStructureMemoryRequirementsInfoNV {
        s_type: crate::data::StructureType = crate::data::StructureType::ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
        p_next: *const c_void,
        ty: crate::data::AccelerationStructureMemoryRequirementsTypeNV,
        acceleration_structure: crate::data::AccelerationStructureNV,
    };
    struct PhysicalDeviceRayTracingPropertiesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
        p_next: *mut c_void,
        shader_group_handle_size: u32,
        max_recursion_depth: u32,
        max_shader_group_stride: u32,
        shader_group_base_alignment: u32,
        max_geometry_count: u64,
        max_instance_count: u64,
        max_triangle_count: u64,
        max_descriptor_set_acceleration_structures: u32,
    };
    struct DrmFormatModifierPropertiesListEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
        p_next: *mut c_void,
        drm_format_modifier_count: u32,
        p_drm_format_modifier_properties: *mut crate::data::DrmFormatModifierPropertiesEXT,
    };
    struct DrmFormatModifierPropertiesEXT {
        drm_format_modifier: u64,
        drm_format_modifier_plane_count: u32,
        drm_format_modifier_tiling_features: crate::data::FormatFeatureFlags,
    };
    struct PhysicalDeviceImageDrmFormatModifierInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
        p_next: *const c_void,
        drm_format_modifier: u64,
        sharing_mode: crate::data::SharingMode,
        queue_family_index_count: u32,
        p_queue_family_indices: *const u32,
    };
    struct ImageDrmFormatModifierListCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
        p_next: *const c_void,
        drm_format_modifier_count: u32,
        p_drm_format_modifiers: *const u64,
    };
    struct ImageDrmFormatModifierExplicitCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
        p_next: *const c_void,
        drm_format_modifier: u64,
        drm_format_modifier_plane_count: u32,
        p_plane_layouts: *const crate::data::SubresourceLayout,
    };
    struct ImageDrmFormatModifierPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
        p_next: *mut c_void,
        drm_format_modifier: u64,
    };
    struct ImageStencilUsageCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_STENCIL_USAGE_CREATE_INFO_EXT,
        p_next: *const c_void,
        stencil_usage: crate::data::ImageUsageFlags,
    };
    struct DeviceMemoryOverallocationCreateInfoAMD {
        s_type: crate::data::StructureType = crate::data::StructureType::DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
        p_next: *const c_void,
        overallocation_behavior: crate::data::MemoryOverallocationBehaviorAMD,
    };
    struct PhysicalDeviceFragmentDensityMapFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
        p_next: *mut c_void,
        fragment_density_map: crate::data::Bool32,
        fragment_density_map_dynamic: crate::data::Bool32,
        fragment_density_map_non_subsampled_images: crate::data::Bool32,
    };
    struct PhysicalDeviceFragmentDensityMapPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
        p_next: *mut c_void,
        min_fragment_density_texel_size: crate::data::Extent2D,
        max_fragment_density_texel_size: crate::data::Extent2D,
        fragment_density_invocations: crate::data::Bool32,
    };
    struct RenderPassFragmentDensityMapCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
        p_next: *const c_void,
        fragment_density_map_attachment: crate::data::AttachmentReference,
    };
    struct PhysicalDeviceScalarBlockLayoutFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT,
        p_next: *mut c_void,
        scalar_block_layout: crate::data::Bool32,
    };
    struct SurfaceProtectedCapabilitiesKHR {
        s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_PROTECTED_CAPABILITIES_KHR,
        p_next: *const c_void,
        supports_protected: crate::data::Bool32,
    };
    struct PhysicalDeviceDepthClipEnableFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
        p_next: *mut c_void,
        depth_clip_enable: crate::data::Bool32,
    };
    struct PipelineRasterizationDepthClipStateCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
        p_next: *const c_void,
        flags: crate::data::PipelineRasterizationDepthClipStateCreateFlagsEXT,
        depth_clip_enable: crate::data::Bool32,
    };
    struct PhysicalDeviceMemoryBudgetPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
        p_next: *mut c_void,
        heap_budget: [crate::data::DeviceSize; 16],
        heap_usage: [crate::data::DeviceSize; 16],
    };
    struct PhysicalDeviceMemoryPriorityFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
        p_next: *mut c_void,
        memory_priority: crate::data::Bool32,
    };
    struct MemoryPriorityAllocateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
        p_next: *const c_void,
        priority: c_float,
    };
    struct PhysicalDeviceBufferAddressFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT,
        p_next: *mut c_void,
        buffer_device_address: crate::data::Bool32,
        buffer_device_address_capture_replay: crate::data::Bool32,
        buffer_device_address_multi_device: crate::data::Bool32,
    };
    struct BufferDeviceAddressInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_DEVICE_ADDRESS_INFO_EXT,
        p_next: *const c_void,
        buffer: crate::data::Buffer,
    };
    struct BufferDeviceAddressCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
        p_next: *const c_void,
        device_address: crate::data::DeviceAddress,
    };
    struct PhysicalDeviceImageViewImageFormatInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
        p_next: *mut c_void,
        image_view_type: crate::data::ImageViewType,
    };
    struct FilterCubicImageViewImageFormatPropertiesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
        p_next: *mut c_void,
        filter_cubic: crate::data::Bool32,
        filter_cubic_minmax: crate::data::Bool32,
    };
    struct PhysicalDeviceCooperativeMatrixFeaturesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
        p_next: *mut c_void,
        cooperative_matrix: crate::data::Bool32,
        cooperative_matrix_robust_buffer_access: crate::data::Bool32,
    };
    struct PhysicalDeviceCooperativeMatrixPropertiesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
        p_next: *mut c_void,
        cooperative_matrix_supported_stages: crate::data::ShaderStageFlags,
    };
    struct CooperativeMatrixPropertiesNV {
        s_type: crate::data::StructureType = crate::data::StructureType::COOPERATIVE_MATRIX_PROPERTIES_NV,
        p_next: *mut c_void,
        m_size: u32,
        n_size: u32,
        k_size: u32,
        a_type: crate::data::ComponentTypeNV,
        b_type: crate::data::ComponentTypeNV,
        c_type: crate::data::ComponentTypeNV,
        d_type: crate::data::ComponentTypeNV,
        scope: crate::data::ScopeNV,
    };
    struct PhysicalDeviceYcbcrImageArraysFeaturesEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
        p_next: *mut c_void,
        ycbcr_image_arrays: crate::data::Bool32,
    };
    struct ImageViewHandleInfoNVX {
        s_type: crate::data::StructureType = crate::data::StructureType::IMAGE_VIEW_HANDLE_INFO_NVX,
        p_next: *const c_void,
        image_view: crate::data::ImageView,
        descriptor_type: crate::data::DescriptorType,
        sampler: crate::data::Sampler,
    };
    struct PipelineCreationFeedbackEXT {
        flags: crate::data::PipelineCreationFeedbackFlagsEXT,
        duration: u64,
    };
    struct PipelineCreationFeedbackCreateInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT,
        p_next: *const c_void,
        p_pipeline_creation_feedback: *mut crate::data::PipelineCreationFeedbackEXT,
        pipeline_stage_creation_feedback_count: u32,
        p_pipeline_stage_creation_feedbacks: *mut crate::data::PipelineCreationFeedbackEXT,
    };
    struct SurfaceFullScreenExclusiveInfoEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
        p_next: *mut c_void,
        full_screen_exclusive: crate::data::FullScreenExclusiveEXT,
    };
    struct SurfaceCapabilitiesFullScreenExclusiveEXT {
        s_type: crate::data::StructureType = crate::data::StructureType::SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
        p_next: *mut c_void,
        full_screen_exclusive_supported: crate::data::Bool32,
    };
}

impl_commands! {
    CreateInstance(
        p_create_info: *const crate::data::InstanceCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_instance: *mut crate::data::Instance,
    ) -> crate::data::Result;
    DestroyInstance(
        instance: crate::data::Instance,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    EnumeratePhysicalDevices(
        instance: crate::data::Instance,
        p_physical_device_count: *mut u32,
        p_physical_devices: *mut crate::data::PhysicalDevice,
    ) -> crate::data::Result;
    GetDeviceProcAddr(
        device: crate::data::Device,
        p_name: *const c_char,
    ) -> crate::pfn::VoidFunction;
    GetInstanceProcAddr(
        instance: crate::data::Instance,
        p_name: *const c_char,
    ) -> crate::pfn::VoidFunction;
    GetPhysicalDeviceProperties(
        physical_device: crate::data::PhysicalDevice,
        p_properties: *mut crate::data::PhysicalDeviceProperties,
    );
    GetPhysicalDeviceQueueFamilyProperties(
        physical_device: crate::data::PhysicalDevice,
        p_queue_family_property_count: *mut u32,
        p_queue_family_properties: *mut crate::data::QueueFamilyProperties,
    );
    GetPhysicalDeviceMemoryProperties(
        physical_device: crate::data::PhysicalDevice,
        p_memory_properties: *mut crate::data::PhysicalDeviceMemoryProperties,
    );
    GetPhysicalDeviceFeatures(
        physical_device: crate::data::PhysicalDevice,
        p_features: *mut crate::data::PhysicalDeviceFeatures,
    );
    GetPhysicalDeviceFormatProperties(
        physical_device: crate::data::PhysicalDevice,
        format: crate::data::Format,
        p_format_properties: *mut crate::data::FormatProperties,
    );
    GetPhysicalDeviceImageFormatProperties(
        physical_device: crate::data::PhysicalDevice,
        format: crate::data::Format,
        ty: crate::data::ImageType,
        tiling: crate::data::ImageTiling,
        usage: crate::data::ImageUsageFlags,
        flags: crate::data::ImageCreateFlags,
        p_image_format_properties: *mut crate::data::ImageFormatProperties,
    ) -> crate::data::Result;
    CreateDevice(
        physical_device: crate::data::PhysicalDevice,
        p_create_info: *const crate::data::DeviceCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_device: *mut crate::data::Device,
    ) -> crate::data::Result;
    DestroyDevice(
        device: crate::data::Device,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    EnumerateInstanceVersion(
        p_api_version: *mut u32,
    ) -> crate::data::Result;
    EnumerateInstanceLayerProperties(
        p_property_count: *mut u32,
        p_properties: *mut crate::data::LayerProperties,
    ) -> crate::data::Result;
    EnumerateInstanceExtensionProperties(
        p_layer_name: *const c_char,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::ExtensionProperties,
    ) -> crate::data::Result;
    EnumerateDeviceLayerProperties(
        physical_device: crate::data::PhysicalDevice,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::LayerProperties,
    ) -> crate::data::Result;
    EnumerateDeviceExtensionProperties(
        physical_device: crate::data::PhysicalDevice,
        p_layer_name: *const c_char,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::ExtensionProperties,
    ) -> crate::data::Result;
    GetDeviceQueue(
        device: crate::data::Device,
        queue_family_index: u32,
        queue_index: u32,
        p_queue: *mut crate::data::Queue,
    );
    QueueSubmit(
        queue: crate::data::Queue,
        submit_count: u32,
        p_submits: *const crate::data::SubmitInfo,
        fence: crate::data::Fence,
    ) -> crate::data::Result;
    QueueWaitIdle(
        queue: crate::data::Queue,
    ) -> crate::data::Result;
    DeviceWaitIdle(
        device: crate::data::Device,
    ) -> crate::data::Result;
    AllocateMemory(
        device: crate::data::Device,
        p_allocate_info: *const crate::data::MemoryAllocateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_memory: *mut crate::data::DeviceMemory,
    ) -> crate::data::Result;
    FreeMemory(
        device: crate::data::Device,
        memory: crate::data::DeviceMemory,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    MapMemory(
        device: crate::data::Device,
        memory: crate::data::DeviceMemory,
        offset: crate::data::DeviceSize,
        size: crate::data::DeviceSize,
        flags: crate::data::MemoryMapFlags,
        pp_data: *mut *mut c_void,
    ) -> crate::data::Result;
    UnmapMemory(
        device: crate::data::Device,
        memory: crate::data::DeviceMemory,
    );
    FlushMappedMemoryRanges(
        device: crate::data::Device,
        memory_range_count: u32,
        p_memory_ranges: *const crate::data::MappedMemoryRange,
    ) -> crate::data::Result;
    InvalidateMappedMemoryRanges(
        device: crate::data::Device,
        memory_range_count: u32,
        p_memory_ranges: *const crate::data::MappedMemoryRange,
    ) -> crate::data::Result;
    GetDeviceMemoryCommitment(
        device: crate::data::Device,
        memory: crate::data::DeviceMemory,
        p_committed_memory_in_bytes: *mut crate::data::DeviceSize,
    );
    GetBufferMemoryRequirements(
        device: crate::data::Device,
        buffer: crate::data::Buffer,
        p_memory_requirements: *mut crate::data::MemoryRequirements,
    );
    BindBufferMemory(
        device: crate::data::Device,
        buffer: crate::data::Buffer,
        memory: crate::data::DeviceMemory,
        memory_offset: crate::data::DeviceSize,
    ) -> crate::data::Result;
    GetImageMemoryRequirements(
        device: crate::data::Device,
        image: crate::data::Image,
        p_memory_requirements: *mut crate::data::MemoryRequirements,
    );
    BindImageMemory(
        device: crate::data::Device,
        image: crate::data::Image,
        memory: crate::data::DeviceMemory,
        memory_offset: crate::data::DeviceSize,
    ) -> crate::data::Result;
    GetImageSparseMemoryRequirements(
        device: crate::data::Device,
        image: crate::data::Image,
        p_sparse_memory_requirement_count: *mut u32,
        p_sparse_memory_requirements: *mut crate::data::SparseImageMemoryRequirements,
    );
    GetPhysicalDeviceSparseImageFormatProperties(
        physical_device: crate::data::PhysicalDevice,
        format: crate::data::Format,
        ty: crate::data::ImageType,
        samples: crate::data::SampleCountFlagBits,
        usage: crate::data::ImageUsageFlags,
        tiling: crate::data::ImageTiling,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::SparseImageFormatProperties,
    );
    QueueBindSparse(
        queue: crate::data::Queue,
        bind_info_count: u32,
        p_bind_info: *const crate::data::BindSparseInfo,
        fence: crate::data::Fence,
    ) -> crate::data::Result;
    CreateFence(
        device: crate::data::Device,
        p_create_info: *const crate::data::FenceCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_fence: *mut crate::data::Fence,
    ) -> crate::data::Result;
    DestroyFence(
        device: crate::data::Device,
        fence: crate::data::Fence,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    ResetFences(
        device: crate::data::Device,
        fence_count: u32,
        p_fences: *const crate::data::Fence,
    ) -> crate::data::Result;
    GetFenceStatus(
        device: crate::data::Device,
        fence: crate::data::Fence,
    ) -> crate::data::Result;
    WaitForFences(
        device: crate::data::Device,
        fence_count: u32,
        p_fences: *const crate::data::Fence,
        wait_all: crate::data::Bool32,
        timeout: u64,
    ) -> crate::data::Result;
    CreateSemaphore(
        device: crate::data::Device,
        p_create_info: *const crate::data::SemaphoreCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_semaphore: *mut crate::data::Semaphore,
    ) -> crate::data::Result;
    DestroySemaphore(
        device: crate::data::Device,
        semaphore: crate::data::Semaphore,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateEvent(
        device: crate::data::Device,
        p_create_info: *const crate::data::EventCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_event: *mut crate::data::Event,
    ) -> crate::data::Result;
    DestroyEvent(
        device: crate::data::Device,
        event: crate::data::Event,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetEventStatus(
        device: crate::data::Device,
        event: crate::data::Event,
    ) -> crate::data::Result;
    SetEvent(
        device: crate::data::Device,
        event: crate::data::Event,
    ) -> crate::data::Result;
    ResetEvent(
        device: crate::data::Device,
        event: crate::data::Event,
    ) -> crate::data::Result;
    CreateQueryPool(
        device: crate::data::Device,
        p_create_info: *const crate::data::QueryPoolCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_query_pool: *mut crate::data::QueryPool,
    ) -> crate::data::Result;
    DestroyQueryPool(
        device: crate::data::Device,
        query_pool: crate::data::QueryPool,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetQueryPoolResults(
        device: crate::data::Device,
        query_pool: crate::data::QueryPool,
        first_query: u32,
        query_count: u32,
        data_size: usize,
        p_data: *mut c_void,
        stride: crate::data::DeviceSize,
        flags: crate::data::QueryResultFlags,
    ) -> crate::data::Result;
    ResetQueryPoolEXT(
        device: crate::data::Device,
        query_pool: crate::data::QueryPool,
        first_query: u32,
        query_count: u32,
    );
    CreateBuffer(
        device: crate::data::Device,
        p_create_info: *const crate::data::BufferCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_buffer: *mut crate::data::Buffer,
    ) -> crate::data::Result;
    DestroyBuffer(
        device: crate::data::Device,
        buffer: crate::data::Buffer,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateBufferView(
        device: crate::data::Device,
        p_create_info: *const crate::data::BufferViewCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_view: *mut crate::data::BufferView,
    ) -> crate::data::Result;
    DestroyBufferView(
        device: crate::data::Device,
        buffer_view: crate::data::BufferView,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateImage(
        device: crate::data::Device,
        p_create_info: *const crate::data::ImageCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_image: *mut crate::data::Image,
    ) -> crate::data::Result;
    DestroyImage(
        device: crate::data::Device,
        image: crate::data::Image,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetImageSubresourceLayout(
        device: crate::data::Device,
        image: crate::data::Image,
        p_subresource: *const crate::data::ImageSubresource,
        p_layout: *mut crate::data::SubresourceLayout,
    );
    CreateImageView(
        device: crate::data::Device,
        p_create_info: *const crate::data::ImageViewCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_view: *mut crate::data::ImageView,
    ) -> crate::data::Result;
    DestroyImageView(
        device: crate::data::Device,
        image_view: crate::data::ImageView,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateShaderModule(
        device: crate::data::Device,
        p_create_info: *const crate::data::ShaderModuleCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_shader_module: *mut crate::data::ShaderModule,
    ) -> crate::data::Result;
    DestroyShaderModule(
        device: crate::data::Device,
        shader_module: crate::data::ShaderModule,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreatePipelineCache(
        device: crate::data::Device,
        p_create_info: *const crate::data::PipelineCacheCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_pipeline_cache: *mut crate::data::PipelineCache,
    ) -> crate::data::Result;
    DestroyPipelineCache(
        device: crate::data::Device,
        pipeline_cache: crate::data::PipelineCache,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetPipelineCacheData(
        device: crate::data::Device,
        pipeline_cache: crate::data::PipelineCache,
        p_data_size: *mut usize,
        p_data: *mut c_void,
    ) -> crate::data::Result;
    MergePipelineCaches(
        device: crate::data::Device,
        dst_cache: crate::data::PipelineCache,
        src_cache_count: u32,
        p_src_caches: *const crate::data::PipelineCache,
    ) -> crate::data::Result;
    CreateGraphicsPipelines(
        device: crate::data::Device,
        pipeline_cache: crate::data::PipelineCache,
        create_info_count: u32,
        p_create_infos: *const crate::data::GraphicsPipelineCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_pipelines: *mut crate::data::Pipeline,
    ) -> crate::data::Result;
    CreateComputePipelines(
        device: crate::data::Device,
        pipeline_cache: crate::data::PipelineCache,
        create_info_count: u32,
        p_create_infos: *const crate::data::ComputePipelineCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_pipelines: *mut crate::data::Pipeline,
    ) -> crate::data::Result;
    DestroyPipeline(
        device: crate::data::Device,
        pipeline: crate::data::Pipeline,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreatePipelineLayout(
        device: crate::data::Device,
        p_create_info: *const crate::data::PipelineLayoutCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_pipeline_layout: *mut crate::data::PipelineLayout,
    ) -> crate::data::Result;
    DestroyPipelineLayout(
        device: crate::data::Device,
        pipeline_layout: crate::data::PipelineLayout,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateSampler(
        device: crate::data::Device,
        p_create_info: *const crate::data::SamplerCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_sampler: *mut crate::data::Sampler,
    ) -> crate::data::Result;
    DestroySampler(
        device: crate::data::Device,
        sampler: crate::data::Sampler,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateDescriptorSetLayout(
        device: crate::data::Device,
        p_create_info: *const crate::data::DescriptorSetLayoutCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_set_layout: *mut crate::data::DescriptorSetLayout,
    ) -> crate::data::Result;
    DestroyDescriptorSetLayout(
        device: crate::data::Device,
        descriptor_set_layout: crate::data::DescriptorSetLayout,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateDescriptorPool(
        device: crate::data::Device,
        p_create_info: *const crate::data::DescriptorPoolCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_descriptor_pool: *mut crate::data::DescriptorPool,
    ) -> crate::data::Result;
    DestroyDescriptorPool(
        device: crate::data::Device,
        descriptor_pool: crate::data::DescriptorPool,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    ResetDescriptorPool(
        device: crate::data::Device,
        descriptor_pool: crate::data::DescriptorPool,
        flags: crate::data::DescriptorPoolResetFlags,
    ) -> crate::data::Result;
    AllocateDescriptorSets(
        device: crate::data::Device,
        p_allocate_info: *const crate::data::DescriptorSetAllocateInfo,
        p_descriptor_sets: *mut crate::data::DescriptorSet,
    ) -> crate::data::Result;
    FreeDescriptorSets(
        device: crate::data::Device,
        descriptor_pool: crate::data::DescriptorPool,
        descriptor_set_count: u32,
        p_descriptor_sets: *const crate::data::DescriptorSet,
    ) -> crate::data::Result;
    UpdateDescriptorSets(
        device: crate::data::Device,
        descriptor_write_count: u32,
        p_descriptor_writes: *const crate::data::WriteDescriptorSet,
        descriptor_copy_count: u32,
        p_descriptor_copies: *const crate::data::CopyDescriptorSet,
    );
    CreateFramebuffer(
        device: crate::data::Device,
        p_create_info: *const crate::data::FramebufferCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_framebuffer: *mut crate::data::Framebuffer,
    ) -> crate::data::Result;
    DestroyFramebuffer(
        device: crate::data::Device,
        framebuffer: crate::data::Framebuffer,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateRenderPass(
        device: crate::data::Device,
        p_create_info: *const crate::data::RenderPassCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_render_pass: *mut crate::data::RenderPass,
    ) -> crate::data::Result;
    DestroyRenderPass(
        device: crate::data::Device,
        render_pass: crate::data::RenderPass,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetRenderAreaGranularity(
        device: crate::data::Device,
        render_pass: crate::data::RenderPass,
        p_granularity: *mut crate::data::Extent2D,
    );
    CreateCommandPool(
        device: crate::data::Device,
        p_create_info: *const crate::data::CommandPoolCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_command_pool: *mut crate::data::CommandPool,
    ) -> crate::data::Result;
    DestroyCommandPool(
        device: crate::data::Device,
        command_pool: crate::data::CommandPool,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    ResetCommandPool(
        device: crate::data::Device,
        command_pool: crate::data::CommandPool,
        flags: crate::data::CommandPoolResetFlags,
    ) -> crate::data::Result;
    AllocateCommandBuffers(
        device: crate::data::Device,
        p_allocate_info: *const crate::data::CommandBufferAllocateInfo,
        p_command_buffers: *mut crate::data::CommandBuffer,
    ) -> crate::data::Result;
    FreeCommandBuffers(
        device: crate::data::Device,
        command_pool: crate::data::CommandPool,
        command_buffer_count: u32,
        p_command_buffers: *const crate::data::CommandBuffer,
    );
    BeginCommandBuffer(
        command_buffer: crate::data::CommandBuffer,
        p_begin_info: *const crate::data::CommandBufferBeginInfo,
    ) -> crate::data::Result;
    EndCommandBuffer(
        command_buffer: crate::data::CommandBuffer,
    ) -> crate::data::Result;
    ResetCommandBuffer(
        command_buffer: crate::data::CommandBuffer,
        flags: crate::data::CommandBufferResetFlags,
    ) -> crate::data::Result;
    CmdBindPipeline(
        command_buffer: crate::data::CommandBuffer,
        pipeline_bind_point: crate::data::PipelineBindPoint,
        pipeline: crate::data::Pipeline,
    );
    CmdSetViewport(
        command_buffer: crate::data::CommandBuffer,
        first_viewport: u32,
        viewport_count: u32,
        p_viewports: *const crate::data::Viewport,
    );
    CmdSetScissor(
        command_buffer: crate::data::CommandBuffer,
        first_scissor: u32,
        scissor_count: u32,
        p_scissors: *const crate::data::Rect2D,
    );
    CmdSetLineWidth(
        command_buffer: crate::data::CommandBuffer,
        line_width: c_float,
    );
    CmdSetDepthBias(
        command_buffer: crate::data::CommandBuffer,
        depth_bias_constant_factor: c_float,
        depth_bias_clamp: c_float,
        depth_bias_slope_factor: c_float,
    );
    CmdSetBlendConstants(
        command_buffer: crate::data::CommandBuffer,
        blend_constants: [c_float; 4],
    );
    CmdSetDepthBounds(
        command_buffer: crate::data::CommandBuffer,
        min_depth_bounds: c_float,
        max_depth_bounds: c_float,
    );
    CmdSetStencilCompareMask(
        command_buffer: crate::data::CommandBuffer,
        face_mask: crate::data::StencilFaceFlags,
        compare_mask: u32,
    );
    CmdSetStencilWriteMask(
        command_buffer: crate::data::CommandBuffer,
        face_mask: crate::data::StencilFaceFlags,
        write_mask: u32,
    );
    CmdSetStencilReference(
        command_buffer: crate::data::CommandBuffer,
        face_mask: crate::data::StencilFaceFlags,
        reference: u32,
    );
    CmdBindDescriptorSets(
        command_buffer: crate::data::CommandBuffer,
        pipeline_bind_point: crate::data::PipelineBindPoint,
        layout: crate::data::PipelineLayout,
        first_set: u32,
        descriptor_set_count: u32,
        p_descriptor_sets: *const crate::data::DescriptorSet,
        dynamic_offset_count: u32,
        p_dynamic_offsets: *const u32,
    );
    CmdBindIndexBuffer(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        index_type: crate::data::IndexType,
    );
    CmdBindVertexBuffers(
        command_buffer: crate::data::CommandBuffer,
        first_binding: u32,
        binding_count: u32,
        p_buffers: *const crate::data::Buffer,
        p_offsets: *const crate::data::DeviceSize,
    );
    CmdDraw(
        command_buffer: crate::data::CommandBuffer,
        vertex_count: u32,
        instance_count: u32,
        first_vertex: u32,
        first_instance: u32,
    );
    CmdDrawIndexed(
        command_buffer: crate::data::CommandBuffer,
        index_count: u32,
        instance_count: u32,
        first_index: u32,
        vertex_offset: i32,
        first_instance: u32,
    );
    CmdDrawIndirect(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        draw_count: u32,
        stride: u32,
    );
    CmdDrawIndexedIndirect(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        draw_count: u32,
        stride: u32,
    );
    CmdDispatch(
        command_buffer: crate::data::CommandBuffer,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    );
    CmdDispatchIndirect(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
    );
    CmdCopyBuffer(
        command_buffer: crate::data::CommandBuffer,
        src_buffer: crate::data::Buffer,
        dst_buffer: crate::data::Buffer,
        region_count: u32,
        p_regions: *const crate::data::BufferCopy,
    );
    CmdCopyImage(
        command_buffer: crate::data::CommandBuffer,
        src_image: crate::data::Image,
        src_image_layout: crate::data::ImageLayout,
        dst_image: crate::data::Image,
        dst_image_layout: crate::data::ImageLayout,
        region_count: u32,
        p_regions: *const crate::data::ImageCopy,
    );
    CmdBlitImage(
        command_buffer: crate::data::CommandBuffer,
        src_image: crate::data::Image,
        src_image_layout: crate::data::ImageLayout,
        dst_image: crate::data::Image,
        dst_image_layout: crate::data::ImageLayout,
        region_count: u32,
        p_regions: *const crate::data::ImageBlit,
        filter: crate::data::Filter,
    );
    CmdCopyBufferToImage(
        command_buffer: crate::data::CommandBuffer,
        src_buffer: crate::data::Buffer,
        dst_image: crate::data::Image,
        dst_image_layout: crate::data::ImageLayout,
        region_count: u32,
        p_regions: *const crate::data::BufferImageCopy,
    );
    CmdCopyImageToBuffer(
        command_buffer: crate::data::CommandBuffer,
        src_image: crate::data::Image,
        src_image_layout: crate::data::ImageLayout,
        dst_buffer: crate::data::Buffer,
        region_count: u32,
        p_regions: *const crate::data::BufferImageCopy,
    );
    CmdUpdateBuffer(
        command_buffer: crate::data::CommandBuffer,
        dst_buffer: crate::data::Buffer,
        dst_offset: crate::data::DeviceSize,
        data_size: crate::data::DeviceSize,
        p_data: *const c_void,
    );
    CmdFillBuffer(
        command_buffer: crate::data::CommandBuffer,
        dst_buffer: crate::data::Buffer,
        dst_offset: crate::data::DeviceSize,
        size: crate::data::DeviceSize,
        data: u32,
    );
    CmdClearColorImage(
        command_buffer: crate::data::CommandBuffer,
        image: crate::data::Image,
        image_layout: crate::data::ImageLayout,
        p_color: *const crate::data::ClearColorValue,
        range_count: u32,
        p_ranges: *const crate::data::ImageSubresourceRange,
    );
    CmdClearDepthStencilImage(
        command_buffer: crate::data::CommandBuffer,
        image: crate::data::Image,
        image_layout: crate::data::ImageLayout,
        p_depth_stencil: *const crate::data::ClearDepthStencilValue,
        range_count: u32,
        p_ranges: *const crate::data::ImageSubresourceRange,
    );
    CmdClearAttachments(
        command_buffer: crate::data::CommandBuffer,
        attachment_count: u32,
        p_attachments: *const crate::data::ClearAttachment,
        rect_count: u32,
        p_rects: *const crate::data::ClearRect,
    );
    CmdResolveImage(
        command_buffer: crate::data::CommandBuffer,
        src_image: crate::data::Image,
        src_image_layout: crate::data::ImageLayout,
        dst_image: crate::data::Image,
        dst_image_layout: crate::data::ImageLayout,
        region_count: u32,
        p_regions: *const crate::data::ImageResolve,
    );
    CmdSetEvent(
        command_buffer: crate::data::CommandBuffer,
        event: crate::data::Event,
        stage_mask: crate::data::PipelineStageFlags,
    );
    CmdResetEvent(
        command_buffer: crate::data::CommandBuffer,
        event: crate::data::Event,
        stage_mask: crate::data::PipelineStageFlags,
    );
    CmdWaitEvents(
        command_buffer: crate::data::CommandBuffer,
        event_count: u32,
        p_events: *const crate::data::Event,
        src_stage_mask: crate::data::PipelineStageFlags,
        dst_stage_mask: crate::data::PipelineStageFlags,
        memory_barrier_count: u32,
        p_memory_barriers: *const crate::data::MemoryBarrier,
        buffer_memory_barrier_count: u32,
        p_buffer_memory_barriers: *const crate::data::BufferMemoryBarrier,
        image_memory_barrier_count: u32,
        p_image_memory_barriers: *const crate::data::ImageMemoryBarrier,
    );
    CmdPipelineBarrier(
        command_buffer: crate::data::CommandBuffer,
        src_stage_mask: crate::data::PipelineStageFlags,
        dst_stage_mask: crate::data::PipelineStageFlags,
        dependency_flags: crate::data::DependencyFlags,
        memory_barrier_count: u32,
        p_memory_barriers: *const crate::data::MemoryBarrier,
        buffer_memory_barrier_count: u32,
        p_buffer_memory_barriers: *const crate::data::BufferMemoryBarrier,
        image_memory_barrier_count: u32,
        p_image_memory_barriers: *const crate::data::ImageMemoryBarrier,
    );
    CmdBeginQuery(
        command_buffer: crate::data::CommandBuffer,
        query_pool: crate::data::QueryPool,
        query: u32,
        flags: crate::data::QueryControlFlags,
    );
    CmdEndQuery(
        command_buffer: crate::data::CommandBuffer,
        query_pool: crate::data::QueryPool,
        query: u32,
    );
    CmdBeginConditionalRenderingEXT(
        command_buffer: crate::data::CommandBuffer,
        p_conditional_rendering_begin: *const crate::data::ConditionalRenderingBeginInfoEXT,
    );
    CmdEndConditionalRenderingEXT(
        command_buffer: crate::data::CommandBuffer,
    );
    CmdResetQueryPool(
        command_buffer: crate::data::CommandBuffer,
        query_pool: crate::data::QueryPool,
        first_query: u32,
        query_count: u32,
    );
    CmdWriteTimestamp(
        command_buffer: crate::data::CommandBuffer,
        pipeline_stage: crate::data::PipelineStageFlagBits,
        query_pool: crate::data::QueryPool,
        query: u32,
    );
    CmdCopyQueryPoolResults(
        command_buffer: crate::data::CommandBuffer,
        query_pool: crate::data::QueryPool,
        first_query: u32,
        query_count: u32,
        dst_buffer: crate::data::Buffer,
        dst_offset: crate::data::DeviceSize,
        stride: crate::data::DeviceSize,
        flags: crate::data::QueryResultFlags,
    );
    CmdPushConstants(
        command_buffer: crate::data::CommandBuffer,
        layout: crate::data::PipelineLayout,
        stage_flags: crate::data::ShaderStageFlags,
        offset: u32,
        size: u32,
        p_values: *const c_void,
    );
    CmdBeginRenderPass(
        command_buffer: crate::data::CommandBuffer,
        p_render_pass_begin: *const crate::data::RenderPassBeginInfo,
        contents: crate::data::SubpassContents,
    );
    CmdNextSubpass(
        command_buffer: crate::data::CommandBuffer,
        contents: crate::data::SubpassContents,
    );
    CmdEndRenderPass(
        command_buffer: crate::data::CommandBuffer,
    );
    CmdExecuteCommands(
        command_buffer: crate::data::CommandBuffer,
        command_buffer_count: u32,
        p_command_buffers: *const crate::data::CommandBuffer,
    );
    GetPhysicalDeviceDisplayPropertiesKHR(
        physical_device: crate::data::PhysicalDevice,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::DisplayPropertiesKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceDisplayPlanePropertiesKHR(
        physical_device: crate::data::PhysicalDevice,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::DisplayPlanePropertiesKHR,
    ) -> crate::data::Result;
    GetDisplayPlaneSupportedDisplaysKHR(
        physical_device: crate::data::PhysicalDevice,
        plane_index: u32,
        p_display_count: *mut u32,
        p_displays: *mut crate::data::DisplayKHR,
    ) -> crate::data::Result;
    GetDisplayModePropertiesKHR(
        physical_device: crate::data::PhysicalDevice,
        display: crate::data::DisplayKHR,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::DisplayModePropertiesKHR,
    ) -> crate::data::Result;
    CreateDisplayModeKHR(
        physical_device: crate::data::PhysicalDevice,
        display: crate::data::DisplayKHR,
        p_create_info: *const crate::data::DisplayModeCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_mode: *mut crate::data::DisplayModeKHR,
    ) -> crate::data::Result;
    GetDisplayPlaneCapabilitiesKHR(
        physical_device: crate::data::PhysicalDevice,
        mode: crate::data::DisplayModeKHR,
        plane_index: u32,
        p_capabilities: *mut crate::data::DisplayPlaneCapabilitiesKHR,
    ) -> crate::data::Result;
    CreateDisplayPlaneSurfaceKHR(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::DisplaySurfaceCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    CreateSharedSwapchainsKHR(
        device: crate::data::Device,
        swapchain_count: u32,
        p_create_infos: *const crate::data::SwapchainCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_swapchains: *mut crate::data::SwapchainKHR,
    ) -> crate::data::Result;
    DestroySurfaceKHR(
        instance: crate::data::Instance,
        surface: crate::data::SurfaceKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetPhysicalDeviceSurfaceSupportKHR(
        physical_device: crate::data::PhysicalDevice,
        queue_family_index: u32,
        surface: crate::data::SurfaceKHR,
        p_supported: *mut crate::data::Bool32,
    ) -> crate::data::Result;
    GetPhysicalDeviceSurfaceCapabilitiesKHR(
        physical_device: crate::data::PhysicalDevice,
        surface: crate::data::SurfaceKHR,
        p_surface_capabilities: *mut crate::data::SurfaceCapabilitiesKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceSurfaceFormatsKHR(
        physical_device: crate::data::PhysicalDevice,
        surface: crate::data::SurfaceKHR,
        p_surface_format_count: *mut u32,
        p_surface_formats: *mut crate::data::SurfaceFormatKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceSurfacePresentModesKHR(
        physical_device: crate::data::PhysicalDevice,
        surface: crate::data::SurfaceKHR,
        p_present_mode_count: *mut u32,
        p_present_modes: *mut crate::data::PresentModeKHR,
    ) -> crate::data::Result;
    CreateSwapchainKHR(
        device: crate::data::Device,
        p_create_info: *const crate::data::SwapchainCreateInfoKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_swapchain: *mut crate::data::SwapchainKHR,
    ) -> crate::data::Result;
    DestroySwapchainKHR(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetSwapchainImagesKHR(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        p_swapchain_image_count: *mut u32,
        p_swapchain_images: *mut crate::data::Image,
    ) -> crate::data::Result;
    AcquireNextImageKHR(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        timeout: u64,
        semaphore: crate::data::Semaphore,
        fence: crate::data::Fence,
        p_image_index: *mut u32,
    ) -> crate::data::Result;
    QueuePresentKHR(
        queue: crate::data::Queue,
        p_present_info: *const crate::data::PresentInfoKHR,
    ) -> crate::data::Result;
    CreateViSurfaceNN(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::ViSurfaceCreateInfoNN,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceWin32PresentationSupportKHR(
        physical_device: crate::data::PhysicalDevice,
        queue_family_index: u32,
    ) -> crate::data::Bool32;
    CreateDebugReportCallbackEXT(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::DebugReportCallbackCreateInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_callback: *mut crate::data::DebugReportCallbackEXT,
    ) -> crate::data::Result;
    DestroyDebugReportCallbackEXT(
        instance: crate::data::Instance,
        callback: crate::data::DebugReportCallbackEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    DebugReportMessageEXT(
        instance: crate::data::Instance,
        flags: crate::data::DebugReportFlagsEXT,
        object_type: crate::data::DebugReportObjectTypeEXT,
        object: u64,
        location: usize,
        message_code: i32,
        p_layer_prefix: *const c_char,
        p_message: *const c_char,
    );
    DebugMarkerSetObjectNameEXT(
        device: crate::data::Device,
        p_name_info: *const crate::data::DebugMarkerObjectNameInfoEXT,
    ) -> crate::data::Result;
    DebugMarkerSetObjectTagEXT(
        device: crate::data::Device,
        p_tag_info: *const crate::data::DebugMarkerObjectTagInfoEXT,
    ) -> crate::data::Result;
    CmdDebugMarkerBeginEXT(
        command_buffer: crate::data::CommandBuffer,
        p_marker_info: *const crate::data::DebugMarkerMarkerInfoEXT,
    );
    CmdDebugMarkerEndEXT(
        command_buffer: crate::data::CommandBuffer,
    );
    CmdDebugMarkerInsertEXT(
        command_buffer: crate::data::CommandBuffer,
        p_marker_info: *const crate::data::DebugMarkerMarkerInfoEXT,
    );
    GetPhysicalDeviceExternalImageFormatPropertiesNV(
        physical_device: crate::data::PhysicalDevice,
        format: crate::data::Format,
        ty: crate::data::ImageType,
        tiling: crate::data::ImageTiling,
        usage: crate::data::ImageUsageFlags,
        flags: crate::data::ImageCreateFlags,
        external_handle_type: crate::data::ExternalMemoryHandleTypeFlagsNV,
        p_external_image_format_properties: *mut crate::data::ExternalImageFormatPropertiesNV,
    ) -> crate::data::Result;
    CmdDrawIndirectCountAMD(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        count_buffer: crate::data::Buffer,
        count_buffer_offset: crate::data::DeviceSize,
        max_draw_count: u32,
        stride: u32,
    );
    CmdDrawIndexedIndirectCountAMD(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        count_buffer: crate::data::Buffer,
        count_buffer_offset: crate::data::DeviceSize,
        max_draw_count: u32,
        stride: u32,
    );
    CmdProcessCommandsNVX(
        command_buffer: crate::data::CommandBuffer,
        p_process_commands_info: *const crate::data::CmdProcessCommandsInfoNVX,
    );
    CmdReserveSpaceForCommandsNVX(
        command_buffer: crate::data::CommandBuffer,
        p_reserve_space_info: *const crate::data::CmdReserveSpaceForCommandsInfoNVX,
    );
    CreateIndirectCommandsLayoutNVX(
        device: crate::data::Device,
        p_create_info: *const crate::data::IndirectCommandsLayoutCreateInfoNVX,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_indirect_commands_layout: *mut crate::data::IndirectCommandsLayoutNVX,
    ) -> crate::data::Result;
    DestroyIndirectCommandsLayoutNVX(
        device: crate::data::Device,
        indirect_commands_layout: crate::data::IndirectCommandsLayoutNVX,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    CreateObjectTableNVX(
        device: crate::data::Device,
        p_create_info: *const crate::data::ObjectTableCreateInfoNVX,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_object_table: *mut crate::data::ObjectTableNVX,
    ) -> crate::data::Result;
    DestroyObjectTableNVX(
        device: crate::data::Device,
        object_table: crate::data::ObjectTableNVX,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    RegisterObjectsNVX(
        device: crate::data::Device,
        object_table: crate::data::ObjectTableNVX,
        object_count: u32,
        pp_object_table_entries: *const *const crate::data::ObjectTableEntryNVX,
        p_object_indices: *const u32,
    ) -> crate::data::Result;
    UnregisterObjectsNVX(
        device: crate::data::Device,
        object_table: crate::data::ObjectTableNVX,
        object_count: u32,
        p_object_entry_types: *const crate::data::ObjectEntryTypeNVX,
        p_object_indices: *const u32,
    ) -> crate::data::Result;
    GetPhysicalDeviceGeneratedCommandsPropertiesNVX(
        physical_device: crate::data::PhysicalDevice,
        p_features: *mut crate::data::DeviceGeneratedCommandsFeaturesNVX,
        p_limits: *mut crate::data::DeviceGeneratedCommandsLimitsNVX,
    );
    GetPhysicalDeviceFeatures2(
        physical_device: crate::data::PhysicalDevice,
        p_features: *mut crate::data::PhysicalDeviceFeatures2,
    );
    GetPhysicalDeviceProperties2(
        physical_device: crate::data::PhysicalDevice,
        p_properties: *mut crate::data::PhysicalDeviceProperties2,
    );
    GetPhysicalDeviceFormatProperties2(
        physical_device: crate::data::PhysicalDevice,
        format: crate::data::Format,
        p_format_properties: *mut crate::data::FormatProperties2,
    );
    GetPhysicalDeviceImageFormatProperties2(
        physical_device: crate::data::PhysicalDevice,
        p_image_format_info: *const crate::data::PhysicalDeviceImageFormatInfo2,
        p_image_format_properties: *mut crate::data::ImageFormatProperties2,
    ) -> crate::data::Result;
    GetPhysicalDeviceQueueFamilyProperties2(
        physical_device: crate::data::PhysicalDevice,
        p_queue_family_property_count: *mut u32,
        p_queue_family_properties: *mut crate::data::QueueFamilyProperties2,
    );
    GetPhysicalDeviceMemoryProperties2(
        physical_device: crate::data::PhysicalDevice,
        p_memory_properties: *mut crate::data::PhysicalDeviceMemoryProperties2,
    );
    GetPhysicalDeviceSparseImageFormatProperties2(
        physical_device: crate::data::PhysicalDevice,
        p_format_info: *const crate::data::PhysicalDeviceSparseImageFormatInfo2,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::SparseImageFormatProperties2,
    );
    CmdPushDescriptorSetKHR(
        command_buffer: crate::data::CommandBuffer,
        pipeline_bind_point: crate::data::PipelineBindPoint,
        layout: crate::data::PipelineLayout,
        set: u32,
        descriptor_write_count: u32,
        p_descriptor_writes: *const crate::data::WriteDescriptorSet,
    );
    TrimCommandPool(
        device: crate::data::Device,
        command_pool: crate::data::CommandPool,
        flags: crate::data::CommandPoolTrimFlags,
    );
    GetPhysicalDeviceExternalBufferProperties(
        physical_device: crate::data::PhysicalDevice,
        p_external_buffer_info: *const crate::data::PhysicalDeviceExternalBufferInfo,
        p_external_buffer_properties: *mut crate::data::ExternalBufferProperties,
    );
    GetMemoryFdKHR(
        device: crate::data::Device,
        p_get_fd_info: *const crate::data::MemoryGetFdInfoKHR,
        p_fd: *mut c_int,
    ) -> crate::data::Result;
    GetMemoryFdPropertiesKHR(
        device: crate::data::Device,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        fd: c_int,
        p_memory_fd_properties: *mut crate::data::MemoryFdPropertiesKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceExternalSemaphoreProperties(
        physical_device: crate::data::PhysicalDevice,
        p_external_semaphore_info: *const crate::data::PhysicalDeviceExternalSemaphoreInfo,
        p_external_semaphore_properties: *mut crate::data::ExternalSemaphoreProperties,
    );
    GetSemaphoreFdKHR(
        device: crate::data::Device,
        p_get_fd_info: *const crate::data::SemaphoreGetFdInfoKHR,
        p_fd: *mut c_int,
    ) -> crate::data::Result;
    ImportSemaphoreFdKHR(
        device: crate::data::Device,
        p_import_semaphore_fd_info: *const crate::data::ImportSemaphoreFdInfoKHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceExternalFenceProperties(
        physical_device: crate::data::PhysicalDevice,
        p_external_fence_info: *const crate::data::PhysicalDeviceExternalFenceInfo,
        p_external_fence_properties: *mut crate::data::ExternalFenceProperties,
    );
    GetFenceFdKHR(
        device: crate::data::Device,
        p_get_fd_info: *const crate::data::FenceGetFdInfoKHR,
        p_fd: *mut c_int,
    ) -> crate::data::Result;
    ImportFenceFdKHR(
        device: crate::data::Device,
        p_import_fence_fd_info: *const crate::data::ImportFenceFdInfoKHR,
    ) -> crate::data::Result;
    ReleaseDisplayEXT(
        physical_device: crate::data::PhysicalDevice,
        display: crate::data::DisplayKHR,
    ) -> crate::data::Result;
    DisplayPowerControlEXT(
        device: crate::data::Device,
        display: crate::data::DisplayKHR,
        p_display_power_info: *const crate::data::DisplayPowerInfoEXT,
    ) -> crate::data::Result;
    RegisterDeviceEventEXT(
        device: crate::data::Device,
        p_device_event_info: *const crate::data::DeviceEventInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_fence: *mut crate::data::Fence,
    ) -> crate::data::Result;
    RegisterDisplayEventEXT(
        device: crate::data::Device,
        display: crate::data::DisplayKHR,
        p_display_event_info: *const crate::data::DisplayEventInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_fence: *mut crate::data::Fence,
    ) -> crate::data::Result;
    GetSwapchainCounterEXT(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        counter: crate::data::SurfaceCounterFlagBitsEXT,
        p_counter_value: *mut u64,
    ) -> crate::data::Result;
    GetPhysicalDeviceSurfaceCapabilities2EXT(
        physical_device: crate::data::PhysicalDevice,
        surface: crate::data::SurfaceKHR,
        p_surface_capabilities: *mut crate::data::SurfaceCapabilities2EXT,
    ) -> crate::data::Result;
    EnumeratePhysicalDeviceGroups(
        instance: crate::data::Instance,
        p_physical_device_group_count: *mut u32,
        p_physical_device_group_properties: *mut crate::data::PhysicalDeviceGroupProperties,
    ) -> crate::data::Result;
    GetDeviceGroupPeerMemoryFeatures(
        device: crate::data::Device,
        heap_index: u32,
        local_device_index: u32,
        remote_device_index: u32,
        p_peer_memory_features: *mut crate::data::PeerMemoryFeatureFlags,
    );
    BindBufferMemory2(
        device: crate::data::Device,
        bind_info_count: u32,
        p_bind_infos: *const crate::data::BindBufferMemoryInfo,
    ) -> crate::data::Result;
    BindImageMemory2(
        device: crate::data::Device,
        bind_info_count: u32,
        p_bind_infos: *const crate::data::BindImageMemoryInfo,
    ) -> crate::data::Result;
    CmdSetDeviceMask(
        command_buffer: crate::data::CommandBuffer,
        device_mask: u32,
    );
    GetDeviceGroupPresentCapabilitiesKHR(
        device: crate::data::Device,
        p_device_group_present_capabilities: *mut crate::data::DeviceGroupPresentCapabilitiesKHR,
    ) -> crate::data::Result;
    GetDeviceGroupSurfacePresentModesKHR(
        device: crate::data::Device,
        surface: crate::data::SurfaceKHR,
        p_modes: *mut crate::data::DeviceGroupPresentModeFlagsKHR,
    ) -> crate::data::Result;
    AcquireNextImage2KHR(
        device: crate::data::Device,
        p_acquire_info: *const crate::data::AcquireNextImageInfoKHR,
        p_image_index: *mut u32,
    ) -> crate::data::Result;
    CmdDispatchBase(
        command_buffer: crate::data::CommandBuffer,
        base_group_x: u32,
        base_group_y: u32,
        base_group_z: u32,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    );
    GetPhysicalDevicePresentRectanglesKHR(
        physical_device: crate::data::PhysicalDevice,
        surface: crate::data::SurfaceKHR,
        p_rect_count: *mut u32,
        p_rects: *mut crate::data::Rect2D,
    ) -> crate::data::Result;
    CreateDescriptorUpdateTemplate(
        device: crate::data::Device,
        p_create_info: *const crate::data::DescriptorUpdateTemplateCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_descriptor_update_template: *mut crate::data::DescriptorUpdateTemplate,
    ) -> crate::data::Result;
    DestroyDescriptorUpdateTemplate(
        device: crate::data::Device,
        descriptor_update_template: crate::data::DescriptorUpdateTemplate,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    UpdateDescriptorSetWithTemplate(
        device: crate::data::Device,
        descriptor_set: crate::data::DescriptorSet,
        descriptor_update_template: crate::data::DescriptorUpdateTemplate,
        p_data: *const c_void,
    );
    CmdPushDescriptorSetWithTemplateKHR(
        command_buffer: crate::data::CommandBuffer,
        descriptor_update_template: crate::data::DescriptorUpdateTemplate,
        layout: crate::data::PipelineLayout,
        set: u32,
        p_data: *const c_void,
    );
    SetHdrMetadataEXT(
        device: crate::data::Device,
        swapchain_count: u32,
        p_swapchains: *const crate::data::SwapchainKHR,
        p_metadata: *const crate::data::HdrMetadataEXT,
    );
    GetSwapchainStatusKHR(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
    ) -> crate::data::Result;
    GetRefreshCycleDurationGOOGLE(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        p_display_timing_properties: *mut crate::data::RefreshCycleDurationGOOGLE,
    ) -> crate::data::Result;
    GetPastPresentationTimingGOOGLE(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
        p_presentation_timing_count: *mut u32,
        p_presentation_timings: *mut crate::data::PastPresentationTimingGOOGLE,
    ) -> crate::data::Result;
    CreateIOSSurfaceMVK(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::IOSSurfaceCreateInfoMVK,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    CreateMacOSSurfaceMVK(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::MacOSSurfaceCreateInfoMVK,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_surface: *mut crate::data::SurfaceKHR,
    ) -> crate::data::Result;
    CmdSetViewportWScalingNV(
        command_buffer: crate::data::CommandBuffer,
        first_viewport: u32,
        viewport_count: u32,
        p_viewport_w_scalings: *const crate::data::ViewportWScalingNV,
    );
    CmdSetDiscardRectangleEXT(
        command_buffer: crate::data::CommandBuffer,
        first_discard_rectangle: u32,
        discard_rectangle_count: u32,
        p_discard_rectangles: *const crate::data::Rect2D,
    );
    CmdSetSampleLocationsEXT(
        command_buffer: crate::data::CommandBuffer,
        p_sample_locations_info: *const crate::data::SampleLocationsInfoEXT,
    );
    GetPhysicalDeviceMultisamplePropertiesEXT(
        physical_device: crate::data::PhysicalDevice,
        samples: crate::data::SampleCountFlagBits,
        p_multisample_properties: *mut crate::data::MultisamplePropertiesEXT,
    );
    GetPhysicalDeviceSurfaceCapabilities2KHR(
        physical_device: crate::data::PhysicalDevice,
        p_surface_info: *const crate::data::PhysicalDeviceSurfaceInfo2KHR,
        p_surface_capabilities: *mut crate::data::SurfaceCapabilities2KHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceSurfaceFormats2KHR(
        physical_device: crate::data::PhysicalDevice,
        p_surface_info: *const crate::data::PhysicalDeviceSurfaceInfo2KHR,
        p_surface_format_count: *mut u32,
        p_surface_formats: *mut crate::data::SurfaceFormat2KHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceDisplayProperties2KHR(
        physical_device: crate::data::PhysicalDevice,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::DisplayProperties2KHR,
    ) -> crate::data::Result;
    GetPhysicalDeviceDisplayPlaneProperties2KHR(
        physical_device: crate::data::PhysicalDevice,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::DisplayPlaneProperties2KHR,
    ) -> crate::data::Result;
    GetDisplayModeProperties2KHR(
        physical_device: crate::data::PhysicalDevice,
        display: crate::data::DisplayKHR,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::DisplayModeProperties2KHR,
    ) -> crate::data::Result;
    GetDisplayPlaneCapabilities2KHR(
        physical_device: crate::data::PhysicalDevice,
        p_display_plane_info: *const crate::data::DisplayPlaneInfo2KHR,
        p_capabilities: *mut crate::data::DisplayPlaneCapabilities2KHR,
    ) -> crate::data::Result;
    GetBufferMemoryRequirements2(
        device: crate::data::Device,
        p_info: *const crate::data::BufferMemoryRequirementsInfo2,
        p_memory_requirements: *mut crate::data::MemoryRequirements2,
    );
    GetImageMemoryRequirements2(
        device: crate::data::Device,
        p_info: *const crate::data::ImageMemoryRequirementsInfo2,
        p_memory_requirements: *mut crate::data::MemoryRequirements2,
    );
    GetImageSparseMemoryRequirements2(
        device: crate::data::Device,
        p_info: *const crate::data::ImageSparseMemoryRequirementsInfo2,
        p_sparse_memory_requirement_count: *mut u32,
        p_sparse_memory_requirements: *mut crate::data::SparseImageMemoryRequirements2,
    );
    CreateSamplerYcbcrConversion(
        device: crate::data::Device,
        p_create_info: *const crate::data::SamplerYcbcrConversionCreateInfo,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_ycbcr_conversion: *mut crate::data::SamplerYcbcrConversion,
    ) -> crate::data::Result;
    DestroySamplerYcbcrConversion(
        device: crate::data::Device,
        ycbcr_conversion: crate::data::SamplerYcbcrConversion,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetDeviceQueue2(
        device: crate::data::Device,
        p_queue_info: *const crate::data::DeviceQueueInfo2,
        p_queue: *mut crate::data::Queue,
    );
    CreateValidationCacheEXT(
        device: crate::data::Device,
        p_create_info: *const crate::data::ValidationCacheCreateInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_validation_cache: *mut crate::data::ValidationCacheEXT,
    ) -> crate::data::Result;
    DestroyValidationCacheEXT(
        device: crate::data::Device,
        validation_cache: crate::data::ValidationCacheEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetValidationCacheDataEXT(
        device: crate::data::Device,
        validation_cache: crate::data::ValidationCacheEXT,
        p_data_size: *mut usize,
        p_data: *mut c_void,
    ) -> crate::data::Result;
    MergeValidationCachesEXT(
        device: crate::data::Device,
        dst_cache: crate::data::ValidationCacheEXT,
        src_cache_count: u32,
        p_src_caches: *const crate::data::ValidationCacheEXT,
    ) -> crate::data::Result;
    GetDescriptorSetLayoutSupport(
        device: crate::data::Device,
        p_create_info: *const crate::data::DescriptorSetLayoutCreateInfo,
        p_support: *mut crate::data::DescriptorSetLayoutSupport,
    );
    GetSwapchainGrallocUsageANDROID(
        device: crate::data::Device,
        format: crate::data::Format,
        image_usage: crate::data::ImageUsageFlags,
        gralloc_usage: *mut c_int,
    ) -> crate::data::Result;
    AcquireImageANDROID(
        device: crate::data::Device,
        image: crate::data::Image,
        native_fence_fd: c_int,
        semaphore: crate::data::Semaphore,
        fence: crate::data::Fence,
    ) -> crate::data::Result;
    QueueSignalReleaseImageANDROID(
        queue: crate::data::Queue,
        wait_semaphore_count: u32,
        p_wait_semaphores: *const crate::data::Semaphore,
        image: crate::data::Image,
        p_native_fence_fd: *mut c_int,
    ) -> crate::data::Result;
    GetShaderInfoAMD(
        device: crate::data::Device,
        pipeline: crate::data::Pipeline,
        shader_stage: crate::data::ShaderStageFlagBits,
        info_type: crate::data::ShaderInfoTypeAMD,
        p_info_size: *mut usize,
        p_info: *mut c_void,
    ) -> crate::data::Result;
    SetLocalDimmingAMD(
        swap_chain: crate::data::SwapchainKHR,
        local_dimming_enable: crate::data::Bool32,
    );
    GetPhysicalDeviceCalibrateableTimeDomainsEXT(
        physical_device: crate::data::PhysicalDevice,
        p_time_domain_count: *mut u32,
        p_time_domains: *mut crate::data::TimeDomainEXT,
    ) -> crate::data::Result;
    GetCalibratedTimestampsEXT(
        device: crate::data::Device,
        timestamp_count: u32,
        p_timestamp_infos: *const crate::data::CalibratedTimestampInfoEXT,
        p_timestamps: *mut u64,
        p_max_deviation: *mut u64,
    ) -> crate::data::Result;
    SetDebugUtilsObjectNameEXT(
        device: crate::data::Device,
        p_name_info: *const crate::data::DebugUtilsObjectNameInfoEXT,
    ) -> crate::data::Result;
    SetDebugUtilsObjectTagEXT(
        device: crate::data::Device,
        p_tag_info: *const crate::data::DebugUtilsObjectTagInfoEXT,
    ) -> crate::data::Result;
    QueueBeginDebugUtilsLabelEXT(
        queue: crate::data::Queue,
        p_label_info: *const crate::data::DebugUtilsLabelEXT,
    );
    QueueEndDebugUtilsLabelEXT(
        queue: crate::data::Queue,
    );
    QueueInsertDebugUtilsLabelEXT(
        queue: crate::data::Queue,
        p_label_info: *const crate::data::DebugUtilsLabelEXT,
    );
    CmdBeginDebugUtilsLabelEXT(
        command_buffer: crate::data::CommandBuffer,
        p_label_info: *const crate::data::DebugUtilsLabelEXT,
    );
    CmdEndDebugUtilsLabelEXT(
        command_buffer: crate::data::CommandBuffer,
    );
    CmdInsertDebugUtilsLabelEXT(
        command_buffer: crate::data::CommandBuffer,
        p_label_info: *const crate::data::DebugUtilsLabelEXT,
    );
    CreateDebugUtilsMessengerEXT(
        instance: crate::data::Instance,
        p_create_info: *const crate::data::DebugUtilsMessengerCreateInfoEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_messenger: *mut crate::data::DebugUtilsMessengerEXT,
    ) -> crate::data::Result;
    DestroyDebugUtilsMessengerEXT(
        instance: crate::data::Instance,
        messenger: crate::data::DebugUtilsMessengerEXT,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    SubmitDebugUtilsMessageEXT(
        instance: crate::data::Instance,
        message_severity: crate::data::DebugUtilsMessageSeverityFlagBitsEXT,
        message_types: crate::data::DebugUtilsMessageTypeFlagsEXT,
        p_callback_data: *const crate::data::DebugUtilsMessengerCallbackDataEXT,
    );
    GetMemoryHostPointerPropertiesEXT(
        device: crate::data::Device,
        handle_type: crate::data::ExternalMemoryHandleTypeFlagBits,
        p_host_pointer: *const c_void,
        p_memory_host_pointer_properties: *mut crate::data::MemoryHostPointerPropertiesEXT,
    ) -> crate::data::Result;
    CmdWriteBufferMarkerAMD(
        command_buffer: crate::data::CommandBuffer,
        pipeline_stage: crate::data::PipelineStageFlagBits,
        dst_buffer: crate::data::Buffer,
        dst_offset: crate::data::DeviceSize,
        marker: u32,
    );
    CreateRenderPass2KHR(
        device: crate::data::Device,
        p_create_info: *const crate::data::RenderPassCreateInfo2KHR,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_render_pass: *mut crate::data::RenderPass,
    ) -> crate::data::Result;
    CmdBeginRenderPass2KHR(
        command_buffer: crate::data::CommandBuffer,
        p_render_pass_begin: *const crate::data::RenderPassBeginInfo,
        p_subpass_begin_info: *const crate::data::SubpassBeginInfoKHR,
    );
    CmdNextSubpass2KHR(
        command_buffer: crate::data::CommandBuffer,
        p_subpass_begin_info: *const crate::data::SubpassBeginInfoKHR,
        p_subpass_end_info: *const crate::data::SubpassEndInfoKHR,
    );
    CmdEndRenderPass2KHR(
        command_buffer: crate::data::CommandBuffer,
        p_subpass_end_info: *const crate::data::SubpassEndInfoKHR,
    );
    CmdDrawIndirectCountKHR(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        count_buffer: crate::data::Buffer,
        count_buffer_offset: crate::data::DeviceSize,
        max_draw_count: u32,
        stride: u32,
    );
    CmdDrawIndexedIndirectCountKHR(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        count_buffer: crate::data::Buffer,
        count_buffer_offset: crate::data::DeviceSize,
        max_draw_count: u32,
        stride: u32,
    );
    CmdSetCheckpointNV(
        command_buffer: crate::data::CommandBuffer,
        p_checkpoint_marker: *const c_void,
    );
    GetQueueCheckpointDataNV(
        queue: crate::data::Queue,
        p_checkpoint_data_count: *mut u32,
        p_checkpoint_data: *mut crate::data::CheckpointDataNV,
    );
    CmdBindTransformFeedbackBuffersEXT(
        command_buffer: crate::data::CommandBuffer,
        first_binding: u32,
        binding_count: u32,
        p_buffers: *const crate::data::Buffer,
        p_offsets: *const crate::data::DeviceSize,
        p_sizes: *const crate::data::DeviceSize,
    );
    CmdBeginTransformFeedbackEXT(
        command_buffer: crate::data::CommandBuffer,
        first_counter_buffer: u32,
        counter_buffer_count: u32,
        p_counter_buffers: *const crate::data::Buffer,
        p_counter_buffer_offsets: *const crate::data::DeviceSize,
    );
    CmdEndTransformFeedbackEXT(
        command_buffer: crate::data::CommandBuffer,
        first_counter_buffer: u32,
        counter_buffer_count: u32,
        p_counter_buffers: *const crate::data::Buffer,
        p_counter_buffer_offsets: *const crate::data::DeviceSize,
    );
    CmdBeginQueryIndexedEXT(
        command_buffer: crate::data::CommandBuffer,
        query_pool: crate::data::QueryPool,
        query: u32,
        flags: crate::data::QueryControlFlags,
        index: u32,
    );
    CmdEndQueryIndexedEXT(
        command_buffer: crate::data::CommandBuffer,
        query_pool: crate::data::QueryPool,
        query: u32,
        index: u32,
    );
    CmdDrawIndirectByteCountEXT(
        command_buffer: crate::data::CommandBuffer,
        instance_count: u32,
        first_instance: u32,
        counter_buffer: crate::data::Buffer,
        counter_buffer_offset: crate::data::DeviceSize,
        counter_offset: u32,
        vertex_stride: u32,
    );
    CmdSetExclusiveScissorNV(
        command_buffer: crate::data::CommandBuffer,
        first_exclusive_scissor: u32,
        exclusive_scissor_count: u32,
        p_exclusive_scissors: *const crate::data::Rect2D,
    );
    CmdBindShadingRateImageNV(
        command_buffer: crate::data::CommandBuffer,
        image_view: crate::data::ImageView,
        image_layout: crate::data::ImageLayout,
    );
    CmdSetViewportShadingRatePaletteNV(
        command_buffer: crate::data::CommandBuffer,
        first_viewport: u32,
        viewport_count: u32,
        p_shading_rate_palettes: *const crate::data::ShadingRatePaletteNV,
    );
    CmdSetCoarseSampleOrderNV(
        command_buffer: crate::data::CommandBuffer,
        sample_order_type: crate::data::CoarseSampleOrderTypeNV,
        custom_sample_order_count: u32,
        p_custom_sample_orders: *const crate::data::CoarseSampleOrderCustomNV,
    );
    CmdDrawMeshTasksNV(
        command_buffer: crate::data::CommandBuffer,
        task_count: u32,
        first_task: u32,
    );
    CmdDrawMeshTasksIndirectNV(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        draw_count: u32,
        stride: u32,
    );
    CmdDrawMeshTasksIndirectCountNV(
        command_buffer: crate::data::CommandBuffer,
        buffer: crate::data::Buffer,
        offset: crate::data::DeviceSize,
        count_buffer: crate::data::Buffer,
        count_buffer_offset: crate::data::DeviceSize,
        max_draw_count: u32,
        stride: u32,
    );
    CompileDeferredNV(
        device: crate::data::Device,
        pipeline: crate::data::Pipeline,
        shader: u32,
    ) -> crate::data::Result;
    CreateAccelerationStructureNV(
        device: crate::data::Device,
        p_create_info: *const crate::data::AccelerationStructureCreateInfoNV,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_acceleration_structure: *mut crate::data::AccelerationStructureNV,
    ) -> crate::data::Result;
    DestroyAccelerationStructureNV(
        device: crate::data::Device,
        acceleration_structure: crate::data::AccelerationStructureNV,
        p_allocator: *const crate::data::AllocationCallbacks,
    );
    GetAccelerationStructureMemoryRequirementsNV(
        device: crate::data::Device,
        p_info: *const crate::data::AccelerationStructureMemoryRequirementsInfoNV,
        p_memory_requirements: *mut crate::data::MemoryRequirements2KHR,
    );
    BindAccelerationStructureMemoryNV(
        device: crate::data::Device,
        bind_info_count: u32,
        p_bind_infos: *const crate::data::BindAccelerationStructureMemoryInfoNV,
    ) -> crate::data::Result;
    CmdCopyAccelerationStructureNV(
        command_buffer: crate::data::CommandBuffer,
        dst: crate::data::AccelerationStructureNV,
        src: crate::data::AccelerationStructureNV,
        mode: crate::data::CopyAccelerationStructureModeNV,
    );
    CmdWriteAccelerationStructuresPropertiesNV(
        command_buffer: crate::data::CommandBuffer,
        acceleration_structure_count: u32,
        p_acceleration_structures: *const crate::data::AccelerationStructureNV,
        query_type: crate::data::QueryType,
        query_pool: crate::data::QueryPool,
        first_query: u32,
    );
    CmdBuildAccelerationStructureNV(
        command_buffer: crate::data::CommandBuffer,
        p_info: *const crate::data::AccelerationStructureInfoNV,
        instance_data: crate::data::Buffer,
        instance_offset: crate::data::DeviceSize,
        update: crate::data::Bool32,
        dst: crate::data::AccelerationStructureNV,
        src: crate::data::AccelerationStructureNV,
        scratch: crate::data::Buffer,
        scratch_offset: crate::data::DeviceSize,
    );
    CmdTraceRaysNV(
        command_buffer: crate::data::CommandBuffer,
        raygen_shader_binding_table_buffer: crate::data::Buffer,
        raygen_shader_binding_offset: crate::data::DeviceSize,
        miss_shader_binding_table_buffer: crate::data::Buffer,
        miss_shader_binding_offset: crate::data::DeviceSize,
        miss_shader_binding_stride: crate::data::DeviceSize,
        hit_shader_binding_table_buffer: crate::data::Buffer,
        hit_shader_binding_offset: crate::data::DeviceSize,
        hit_shader_binding_stride: crate::data::DeviceSize,
        callable_shader_binding_table_buffer: crate::data::Buffer,
        callable_shader_binding_offset: crate::data::DeviceSize,
        callable_shader_binding_stride: crate::data::DeviceSize,
        width: u32,
        height: u32,
        depth: u32,
    );
    GetRayTracingShaderGroupHandlesNV(
        device: crate::data::Device,
        pipeline: crate::data::Pipeline,
        first_group: u32,
        group_count: u32,
        data_size: usize,
        p_data: *mut c_void,
    ) -> crate::data::Result;
    GetAccelerationStructureHandleNV(
        device: crate::data::Device,
        acceleration_structure: crate::data::AccelerationStructureNV,
        data_size: usize,
        p_data: *mut c_void,
    ) -> crate::data::Result;
    CreateRayTracingPipelinesNV(
        device: crate::data::Device,
        pipeline_cache: crate::data::PipelineCache,
        create_info_count: u32,
        p_create_infos: *const crate::data::RayTracingPipelineCreateInfoNV,
        p_allocator: *const crate::data::AllocationCallbacks,
        p_pipelines: *mut crate::data::Pipeline,
    ) -> crate::data::Result;
    GetImageDrmFormatModifierPropertiesEXT(
        device: crate::data::Device,
        image: crate::data::Image,
        p_properties: *mut crate::data::ImageDrmFormatModifierPropertiesEXT,
    ) -> crate::data::Result;
    GetBufferDeviceAddressEXT(
        device: crate::data::Device,
        p_info: *const crate::data::BufferDeviceAddressInfoEXT,
    ) -> crate::data::DeviceAddress;
    GetPhysicalDeviceCooperativeMatrixPropertiesNV(
        physical_device: crate::data::PhysicalDevice,
        p_property_count: *mut u32,
        p_properties: *mut crate::data::CooperativeMatrixPropertiesNV,
    ) -> crate::data::Result;
    GetImageViewHandleNVX(
        device: crate::data::Device,
        p_info: *const crate::data::ImageViewHandleInfoNVX,
    ) -> u32;
    GetPhysicalDeviceSurfacePresentModes2EXT(
        physical_device: crate::data::PhysicalDevice,
        p_surface_info: *const crate::data::PhysicalDeviceSurfaceInfo2KHR,
        p_present_mode_count: *mut u32,
        p_present_modes: *mut crate::data::PresentModeKHR,
    ) -> crate::data::Result;
    GetDeviceGroupSurfacePresentModes2EXT(
        device: crate::data::Device,
        p_surface_info: *const crate::data::PhysicalDeviceSurfaceInfo2KHR,
        p_modes: *mut crate::data::DeviceGroupPresentModeFlagsKHR,
    ) -> crate::data::Result;
    AcquireFullScreenExclusiveModeEXT(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
    ) -> crate::data::Result;
    ReleaseFullScreenExclusiveModeEXT(
        device: crate::data::Device,
        swapchain: crate::data::SwapchainKHR,
    ) -> crate::data::Result;
}

impl_extensions! {
    KHR_SURFACE_EXTENSION_NAME = VK_KHR_surface;
    KHR_SWAPCHAIN_EXTENSION_NAME = VK_KHR_swapchain;
    KHR_DISPLAY_EXTENSION_NAME = VK_KHR_display;
    KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = VK_KHR_display_swapchain;
    KHR_XLIB_SURFACE_EXTENSION_NAME = VK_KHR_xlib_surface;
    KHR_XCB_SURFACE_EXTENSION_NAME = VK_KHR_xcb_surface;
    KHR_WAYLAND_SURFACE_EXTENSION_NAME = VK_KHR_wayland_surface;
    KHR_ANDROID_SURFACE_EXTENSION_NAME = VK_KHR_android_surface;
    KHR_WIN32_SURFACE_EXTENSION_NAME = VK_KHR_win32_surface;
    EXT_DEBUG_REPORT_EXTENSION_NAME = VK_EXT_debug_report;
    NV_GLSL_SHADER_EXTENSION_NAME = VK_NV_glsl_shader;
    EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME = VK_EXT_depth_range_unrestricted;
    KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME = VK_KHR_sampler_mirror_clamp_to_edge;
    IMG_FILTER_CUBIC_EXTENSION_NAME = VK_IMG_filter_cubic;
    AMD_RASTERIZATION_ORDER_EXTENSION_NAME = VK_AMD_rasterization_order;
    AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME = VK_AMD_shader_trinary_minmax;
    AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME = VK_AMD_shader_explicit_vertex_parameter;
    EXT_DEBUG_MARKER_EXTENSION_NAME = VK_EXT_debug_marker;
    AMD_GCN_SHADER_EXTENSION_NAME = VK_AMD_gcn_shader;
    NV_DEDICATED_ALLOCATION_EXTENSION_NAME = VK_NV_dedicated_allocation;
    EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME = VK_EXT_transform_feedback;
    NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME = VK_NVX_image_view_handle;
    AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME = VK_AMD_draw_indirect_count;
    AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME = VK_AMD_negative_viewport_height;
    AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME = VK_AMD_gpu_shader_half_float;
    AMD_SHADER_BALLOT_EXTENSION_NAME = VK_AMD_shader_ballot;
    AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME = VK_AMD_texture_gather_bias_lod;
    AMD_SHADER_INFO_EXTENSION_NAME = VK_AMD_shader_info;
    AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME = VK_AMD_shader_image_load_store_lod;
    GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME = VK_GGP_stream_descriptor_surface;
    NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME = VK_NV_corner_sampled_image;
    KHR_MULTIVIEW_EXTENSION_NAME = VK_KHR_multiview;
    IMG_FORMAT_PVRTC_EXTENSION_NAME = VK_IMG_format_pvrtc;
    NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = VK_NV_external_memory_capabilities;
    NV_EXTERNAL_MEMORY_EXTENSION_NAME = VK_NV_external_memory;
    NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME = VK_NV_external_memory_win32;
    NV_WIN32_KEYED_MUTEX_EXTENSION_NAME = VK_NV_win32_keyed_mutex;
    KHR_GET_PHYSICAL_DEVICE_PROPERTIES2_EXTENSION_NAME = VK_KHR_get_physical_device_properties2;
    KHR_DEVICE_GROUP_EXTENSION_NAME = VK_KHR_device_group;
    EXT_VALIDATION_FLAGS_EXTENSION_NAME = VK_EXT_validation_flags;
    NN_VI_SURFACE_EXTENSION_NAME = VK_NN_vi_surface;
    KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME = VK_KHR_shader_draw_parameters;
    EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME = VK_EXT_shader_subgroup_ballot;
    EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME = VK_EXT_shader_subgroup_vote;
    EXT_ASTC_DECODE_MODE_EXTENSION_NAME = VK_EXT_astc_decode_mode;
    KHR_MAINTENANCE1_EXTENSION_NAME = VK_KHR_maintenance1;
    KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME = VK_KHR_device_group_creation;
    KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = VK_KHR_external_memory_capabilities;
    KHR_EXTERNAL_MEMORY_EXTENSION_NAME = VK_KHR_external_memory;
    KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME = VK_KHR_external_memory_win32;
    KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME = VK_KHR_external_memory_fd;
    KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME = VK_KHR_win32_keyed_mutex;
    KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME = VK_KHR_external_semaphore_capabilities;
    KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME = VK_KHR_external_semaphore;
    KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME = VK_KHR_external_semaphore_win32;
    KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME = VK_KHR_external_semaphore_fd;
    KHR_PUSH_DESCRIPTOR_EXTENSION_NAME = VK_KHR_push_descriptor;
    EXT_CONDITIONAL_RENDERING_EXTENSION_NAME = VK_EXT_conditional_rendering;
    KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME = VK_KHR_shader_float16_int8;
    KHR_16BIT_STORAGE_EXTENSION_NAME = VK_KHR_16bit_storage;
    KHR_INCREMENTAL_PRESENT_EXTENSION_NAME = VK_KHR_incremental_present;
    KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME = VK_KHR_descriptor_update_template;
    NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = VK_NVX_device_generated_commands;
    NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME = VK_NV_clip_space_w_scaling;
    EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME = VK_EXT_direct_mode_display;
    EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME = VK_EXT_acquire_xlib_display;
    EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME = VK_EXT_display_surface_counter;
    EXT_DISPLAY_CONTROL_EXTENSION_NAME = VK_EXT_display_control;
    GOOGLE_DISPLAY_TIMING_EXTENSION_NAME = VK_GOOGLE_display_timing;
    NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME = VK_NV_sample_mask_override_coverage;
    NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME = VK_NV_geometry_shader_passthrough;
    NV_VIEWPORT_ARRAY2_EXTENSION_NAME = VK_NV_viewport_array2;
    NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME = VK_NVX_multiview_per_view_attributes;
    NV_VIEWPORT_SWIZZLE_EXTENSION_NAME = VK_NV_viewport_swizzle;
    EXT_DISCARD_RECTANGLES_EXTENSION_NAME = VK_EXT_discard_rectangles;
    EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME = VK_EXT_conservative_rasterization;
    EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME = VK_EXT_depth_clip_enable;
    EXT_SWAPCHAIN_COLORSPACE_EXTENSION_NAME = VK_EXT_swapchain_colorspace;
    EXT_HDR_METADATA_EXTENSION_NAME = VK_EXT_hdr_metadata;
    KHR_CREATE_RENDERPASS2_EXTENSION_NAME = VK_KHR_create_renderpass2;
    KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME = VK_KHR_shared_presentable_image;
    KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME = VK_KHR_external_fence_capabilities;
    KHR_EXTERNAL_FENCE_EXTENSION_NAME = VK_KHR_external_fence;
    KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME = VK_KHR_external_fence_win32;
    KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME = VK_KHR_external_fence_fd;
    KHR_MAINTENANCE2_EXTENSION_NAME = VK_KHR_maintenance2;
    KHR_GET_SURFACE_CAPABILITIES2_EXTENSION_NAME = VK_KHR_get_surface_capabilities2;
    KHR_VARIABLE_POINTERS_EXTENSION_NAME = VK_KHR_variable_pointers;
    KHR_GET_DISPLAY_PROPERTIES2_EXTENSION_NAME = VK_KHR_get_display_properties2;
    MVK_IOS_SURFACE_EXTENSION_NAME = VK_MVK_ios_surface;
    MVK_MACOS_SURFACE_EXTENSION_NAME = VK_MVK_macos_surface;
    EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME = VK_EXT_external_memory_dma_buf;
    EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME = VK_EXT_queue_family_foreign;
    KHR_DEDICATED_ALLOCATION_EXTENSION_NAME = VK_KHR_dedicated_allocation;
    EXT_DEBUG_UTILS_EXTENSION_NAME = VK_EXT_debug_utils;
    ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME = VK_ANDROID_external_memory_android_hardware_buffer;
    EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME = VK_EXT_sampler_filter_minmax;
    KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME = VK_KHR_storage_buffer_storage_class;
    AMD_GPU_SHADER_INT16_EXTENSION_NAME = VK_AMD_gpu_shader_int16;
    AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME = VK_AMD_mixed_attachment_samples;
    AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME = VK_AMD_shader_fragment_mask;
    EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME = VK_EXT_inline_uniform_block;
    EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME = VK_EXT_shader_stencil_export;
    EXT_SAMPLE_LOCATIONS_EXTENSION_NAME = VK_EXT_sample_locations;
    KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME = VK_KHR_relaxed_block_layout;
    KHR_GET_MEMORY_REQUIREMENTS2_EXTENSION_NAME = VK_KHR_get_memory_requirements2;
    KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME = VK_KHR_image_format_list;
    EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME = VK_EXT_blend_operation_advanced;
    NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME = VK_NV_fragment_coverage_to_color;
    NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME = VK_NV_framebuffer_mixed_samples;
    NV_FILL_RECTANGLE_EXTENSION_NAME = VK_NV_fill_rectangle;
    EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME = VK_EXT_post_depth_coverage;
    KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME = VK_KHR_sampler_ycbcr_conversion;
    KHR_BIND_MEMORY2_EXTENSION_NAME = VK_KHR_bind_memory2;
    EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME = VK_EXT_image_drm_format_modifier;
    EXT_VALIDATION_CACHE_EXTENSION_NAME = VK_EXT_validation_cache;
    EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME = VK_EXT_descriptor_indexing;
    EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME = VK_EXT_shader_viewport_index_layer;
    NV_SHADING_RATE_IMAGE_EXTENSION_NAME = VK_NV_shading_rate_image;
    NV_RAY_TRACING_EXTENSION_NAME = VK_NV_ray_tracing;
    NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME = VK_NV_representative_fragment_test;
    KHR_MAINTENANCE3_EXTENSION_NAME = VK_KHR_maintenance3;
    KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME = VK_KHR_draw_indirect_count;
    EXT_FILTER_CUBIC_EXTENSION_NAME = VK_EXT_filter_cubic;
    EXT_GLOBAL_PRIORITY_EXTENSION_NAME = VK_EXT_global_priority;
    KHR_8BIT_STORAGE_EXTENSION_NAME = VK_KHR_8bit_storage;
    EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME = VK_EXT_external_memory_host;
    AMD_BUFFER_MARKER_EXTENSION_NAME = VK_AMD_buffer_marker;
    KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME = VK_KHR_shader_atomic_int64;
    EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME = VK_EXT_calibrated_timestamps;
    AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME = VK_AMD_shader_core_properties;
    AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME = VK_AMD_memory_overallocation_behavior;
    EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = VK_EXT_vertex_attribute_divisor;
    GGP_FRAME_TOKEN_EXTENSION_NAME = VK_GGP_frame_token;
    EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME = VK_EXT_pipeline_creation_feedback;
    KHR_DRIVER_PROPERTIES_EXTENSION_NAME = VK_KHR_driver_properties;
    KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME = VK_KHR_shader_float_controls;
    NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME = VK_NV_shader_subgroup_partitioned;
    KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME = VK_KHR_depth_stencil_resolve;
    KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME = VK_KHR_swapchain_mutable_format;
    NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME = VK_NV_compute_shader_derivatives;
    NV_MESH_SHADER_EXTENSION_NAME = VK_NV_mesh_shader;
    NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME = VK_NV_fragment_shader_barycentric;
    NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME = VK_NV_shader_image_footprint;
    NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME = VK_NV_scissor_exclusive;
    NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME = VK_NV_device_diagnostic_checkpoints;
    KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME = VK_KHR_vulkan_memory_model;
    EXT_PCI_BUS_INFO_EXTENSION_NAME = VK_EXT_pci_bus_info;
    AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME = VK_AMD_display_native_hdr;
    FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME = VK_FUCHSIA_imagepipe_surface;
    EXT_METAL_SURFACE_EXTENSION_NAME = VK_EXT_metal_surface;
    EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME = VK_EXT_fragment_density_map;
    EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME = VK_EXT_scalar_block_layout;
    GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME = VK_GOOGLE_hlsl_functionality1;
    GOOGLE_DECORATE_STRING_EXTENSION_NAME = VK_GOOGLE_decorate_string;
    EXT_MEMORY_BUDGET_EXTENSION_NAME = VK_EXT_memory_budget;
    EXT_MEMORY_PRIORITY_EXTENSION_NAME = VK_EXT_memory_priority;
    KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME = VK_KHR_surface_protected_capabilities;
    NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME = VK_NV_dedicated_allocation_image_aliasing;
    EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME = VK_EXT_buffer_device_address;
    EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME = VK_EXT_separate_stencil_usage;
    EXT_VALIDATION_FEATURES_EXTENSION_NAME = VK_EXT_validation_features;
    NV_COOPERATIVE_MATRIX_EXTENSION_NAME = VK_NV_cooperative_matrix;
    EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME = VK_EXT_ycbcr_image_arrays;
    EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME = VK_EXT_full_screen_exclusive;
    EXT_HOST_QUERY_RESET_EXTENSION_NAME = VK_EXT_host_query_reset;
}