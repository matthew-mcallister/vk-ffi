#!/usr/bin/env python3
"""This script generates Vulkan bindings for Rust.

It depends on the Vulkan XML registry and a separate parser for it. Due
to the Python dependency, and to save compile time, bindings are
generated ahead in advance and distributed directly rather than being
regenerated each time.
"""
import argparse
import itertools
import os
import re
import xml.etree.ElementTree as etree

from vkreg import Registry


def strip_prefix(prefix, string):
    assert string[:len(prefix)] == prefix
    return string[len(prefix):]


TITLE_WORDS_REGEX = re.compile(
    r'(?<=[a-z])(?=[A-Z0-9])|' +
    r'(?<=[A-Z])(?=[0-9])|' +
    r'(?<=[A-Z])(?=[A-Z][a-z])|' +
    r'(?<=[0-9])(?=[A-Z][a-z])|' +
    r'(?<=[0-9])(?=[A-Z]{2,}$)'
)

def camel_to_snake(ident):
    return TITLE_WORDS_REGEX.sub('_', ident).lower()


BUILTIN_MAP = {
    'void': 'c_void',
    'char': 'c_char',
    'int': 'c_int',
    'float': 'c_float',
    'uint8_t': 'u8',
    'uint16_t': 'u16',
    'uint32_t': 'u32',
    'uint64_t': 'u64',
    'int32_t': 'i32',
    'size_t': 'usize',
}

def render_type_expr_base(name):
    if name.namespace == 'PFN_vk':
        return 'crate::pfn::' + name.base
    elif name.namespace == 'Vk':
        return 'crate::data::' + name.base
    else:
        return BUILTIN_MAP.get(name.base, name.base)


def render_quals(quals):
    quals = list(reversed(quals))
    res = []
    idx = 0
    while idx < len(quals):
        idx += 1
        if quals[idx - 1] != '*':
            continue
        if idx < len(quals) and quals[idx] == 'const':
            idx += 1
            res.append('*const')
        else:
            res.append('*mut')
    return res


def render_type_expr(expr):
    parts = render_quals(expr.qualifiers)
    parts.append(render_type_expr_base(expr.base))
    if expr.len is not None:
        parts = ['['] + parts + [';', str(expr.len), ']']
    return parts


def render_var(name):
    name = name.base
    if name == 'type':
        return '_type'
    return camel_to_snake(name)


def render_decl(decl):
    return [render_var(decl.name), ':'] + render_type_expr(decl.ty)


def render_signature(func):
    parts = ['(']
    for arg in func.args:
        if arg.name:
            parts += render_decl(arg)
            parts.append(',')
        else:
            assert arg.ty.base.base == 'void'
            assert len(func.args) == 1
    parts.append(')')
    ty = render_type_expr(func.ret)
    if ty != ['c_void']:
        parts.append('->')
        parts += ty
    return parts


def render_func(func):
    return [func.name.base] + render_signature(func)


def render_aggregate(agg, stype=None):
    parts = [agg.name.base]
    if stype:
        parts += [':', stype]
    parts.append('{')
    for member in agg.members:
        parts += render_decl(member)
        parts.append(',')
    parts.append('}')
    return parts


class BindingsVisitor:
    def __init__(self):
        self.bitmasks = []
        self.enums = []
        self.aliases = []
        self.disp_handles = []
        self.nondisp_handles = []
        self.func_pointers = []
        self.structs = []
        self.chain_structs = []
        self.unions = []
        self.commands = []
        self.extensions = []

        # If a type depends on an external header, remember it here
        self.excised = set()


    def visit(self, reg):
        for extern in reg.externs:
            self.excised.add(extern.name)
        for enum in reg.enums:
            self.visit_enum(enum)
        for ty in reg.types:
            self.visit_type(ty)
        for command in reg.commands:
            self.visit_command(command)
        for extension in reg.extensions:
            self.visit_extension(extension)


    def visit_extension(self, extension):
        name = strip_prefix('VK_', extension.name).upper() + '_EXTENSION_NAME'
        self.extensions.append([name, '=', extension.name])


    def visit_enum(self, enum):
        assert enum.ty in ('bitmask', 'enum')

        parts = [enum.name.base, '{']
        for member in enum.members:
            name = member.name.base
            if name[0] in '0123456789':
                name = f'_{name}'
            parts += [name, '=', str(member.value), ',']
        parts.append('}')

        if enum.ty == 'bitmask':
            self.bitmasks.append(parts)
        else:
            self.enums.append(parts)


    def visit_command(self, command):
        if any(arg.ty.base.base in self.excised for arg in command.args):
            # Depends on an external header
            return
        self.commands.append(render_func(command))


    def visit_type(self, ty):
        category = ty.category()
        if category == 'type_alias':
            self.visit_alias(ty)
        elif category == 'handle':
            self.visit_handle(ty)
        elif category == 'func_pointer':
            self.func_pointers.append(render_func(ty))
        elif category == 'aggregate':
            self.visit_aggregate(ty)
        else:
            raise ValueError(f'unexpected category: {category}')


    def visit_alias(self, alias):
        parts = [alias.name.base, '=', render_type_expr_base(alias.target)]
        self.aliases.append(parts)


    def visit_handle(self, handle):
        if handle.dispatchable:
            self.disp_handles.append(handle.name.base)
        else:
            self.nondisp_handles.append(handle.name.base)


    def visit_aggregate(self, agg):
        assert agg.ty in ('struct', 'union')

        if any(mem.ty.base.base in self.excised for mem in agg.members):
            # Depends on an external header
            self.excised.add(agg.name.base)
            return

        if agg.ty == 'struct':
            for mem in agg.members:
                if mem.values:
                    stype = strip_prefix('VK_STRUCTURE_TYPE_', mem.values[0])
                    self.chain_structs.append(render_aggregate(agg, stype))
                    break
            else:
                self.structs.append(render_aggregate(agg))
        else:
            self.unions.append(render_aggregate(agg))


def render_bindings(reg):
    visitor = BindingsVisitor()
    visitor.visit(reg)

    res = []

    for macro, entries in (
        ('bitmasks', visitor.bitmasks),
        ('enums', visitor.enums),
        ('aliases', visitor.aliases),
        ('dispatchable_handles', visitor.disp_handles),
        ('nondispatchable_handles', visitor.nondisp_handles),
        ('func_pointers', visitor.func_pointers),
        ('structs', visitor.structs),
        ('chain_structs', visitor.chain_structs),
        ('unions', visitor.unions),
        ('commands', visitor.commands),
        ('extensions', visitor.extensions),
    ):
        res += [f'\n\nimpl_{macro}!', '{']
        for entry in entries:
            if isinstance(entry, str):
                res.append(entry)
            else:
                res += entry
            res.append(';')
        res.append('}')

    return res


def write_code(f, strs):
    INDENT = '    '
    indent_lvl = 0
    for i, s in enumerate(strs):
        if s in ('(', '{', '['):
            indent_lvl += 1
            f.write(s)
            f.write('\n')
            f.write(INDENT * indent_lvl)
        elif s in (')', '}', ']'):
            indent_lvl -= 1
            f.write('\n')
            f.write(INDENT * indent_lvl)
            f.write(s)
        elif s in (',', ';'):
            f.write(s)
            f.write('\n')
            f.write(INDENT * indent_lvl)
        else:
            f.write(s)
        f.write(' ')


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-i', '--input', help='Path to vk.xml.')
    parser.add_argument('-o', '--output',
        help='Output directory for generated sources')
    args = parser.parse_args()

    root = etree.parse(args.input).getroot()

    registry = Registry()
    registry.parse_registry(root)

    bindings = render_bindings(registry)
    bindings_file = os.path.join(args.output, 'bindings.rs')
    with open(bindings_file, 'w') as f:
        write_code(f, bindings)


if __name__ == '__main__':
    main()
