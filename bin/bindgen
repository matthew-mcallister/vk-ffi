#!/usr/bin/env python3
"""This script generates Vulkan bindings for Rust.

It depends on the Vulkan XML registry and a separate parser for it. Due
to the Python dependency, and to save compile time, bindings are
generated ahead in advance and distributed directly rather than being
regenerated each time.
"""
import argparse
import dataclasses
import itertools
import os
import re
import xml.etree.ElementTree as etree

from vkreg import Registry


def strip_prefix(prefix, string):
    assert string[:len(prefix)] == prefix
    return string[len(prefix):]


TITLE_WORDS_REGEX = re.compile(
    r'(?<=[a-z])(?=[A-Z0-9])|' +
    r'(?<=[A-Z])(?=[0-9])|' +
    r'(?<=[A-Z])(?=[A-Z][a-z])|' +
    r'(?<=[0-9])(?=[A-Z][a-z])|' +
    r'(?<=[0-9])(?=[A-Z]{2,}$)'
)

def camel_to_snake(ident):
    return TITLE_WORDS_REGEX.sub('_', ident).lower()


BUILTIN_MAP = {
    'void': 'c_void',
    'char': 'c_char',
    'int': 'c_int',
    'float': 'c_float',
    'uint8_t': 'u8',
    'uint16_t': 'u16',
    'uint32_t': 'u32',
    'uint64_t': 'u64',
    'int32_t': 'i32',
    'size_t': 'usize',
}

class Renderer:
    def __init__(self, **kwargs):
        self.namespace_data = kwargs.get('namespace_data', True)
        self.namespace_pfn = kwargs.get('namespace_pfn', True)


    def render_data(self, ident):
        if self.namespace_data:
            return f'crate::data::{ident}'
        else:
            return ident


    def render_pfn(self, ident):
        if self.namespace_pfn:
            return f'crate::pfn::{ident}'
        else:
            return ident


    def render_type_expr_base(self, name):
        if name.namespace == 'PFN_vk':
            return self.render_pfn(name.base)
        elif name.namespace == 'Vk':
            return self.render_data(name.base)
        else:
            return BUILTIN_MAP.get(name.base, name.base)


    def render_quals(self, quals):
        quals = list(reversed(quals))
        res = []
        idx = 0
        while idx < len(quals):
            idx += 1
            if quals[idx - 1] != '*':
                continue
            if idx < len(quals) and quals[idx] == 'const':
                idx += 1
                res.append('*const')
            else:
                res.append('*mut')
        return res


    def render_type_expr(self, expr):
        parts = self.render_quals(expr.qualifiers)
        parts.append(self.render_type_expr_base(expr.base))
        if expr.len is not None:
            parts = ['['] + parts + [';', str(expr.len), ']']
        return parts


    def render_var(self, name):
        if name == 'type':
            return '_type'
        return camel_to_snake(name)


    def render_decl(self, decl):
        ty = self.render_type_expr(decl.ty)
        return [self.render_var(decl.name), ':'] + ty


    def render_signature(self, func):
        parts = ['(']
        for arg in func.args:
            if arg.name:
                parts += self.render_decl(arg)
                parts.append(',')
            else:
                assert arg.ty.base.base == 'void'
                assert len(func.args) == 1
        parts.append(')')
        ty = self.render_type_expr(func.ret)
        if ty != ['c_void']:
            parts.append('->')
            parts += ty
        return parts


    def render_func(self, func):
        return [func.name.base] + self.render_signature(func)


    def render_aggregate(self, agg):
        parts = [agg.name.base]
        for mem in agg.members:
            if mem.name == 'sType' and mem.values:
                s_type = strip_prefix('VK_STRUCTURE_TYPE_', mem.values[0])
                parts += [':', s_type]
        parts.append('{')
        for member in agg.members:
            parts += self.render_decl(member)
            parts.append(',')
        parts.append('}')
        return parts


class BindingsVisitor:
    def __init__(self):
        self.bitmasks = []
        self.enums = []
        self.aliases = []
        self.disp_handles = []
        self.nondisp_handles = []
        self.func_pointers = []
        self.structs = []
        self.unions = []
        self.commands = []
        self.extensions = []

        self.renderer = Renderer()
        # If a type depends on an external header, remember it here
        self.excised = set()


    def command_is_excised(self, command):
        return any(arg.ty.base.base in self.excised for arg in command.args)


    def visit(self, reg):
        for extern in reg.externs:
            self.excised.add(extern.name)
        for enum in reg.enums:
            self.visit_enum(enum)
        for ty in reg.types:
            self.visit_type(ty)
        for command in reg.commands:
            self.visit_command(command)
        for extension in reg.extensions:
            self.visit_extension(extension)


    def visit_extension(self, extension):
        name = strip_prefix('VK_', extension.name).upper() + '_EXTENSION_NAME'
        self.extensions.append([name, '=', extension.name])


    def visit_enum(self, enum):
        assert enum.ty in ('bitmask', 'enum')

        parts = [enum.name.base, '{']
        for member in enum.members:
            name = member.name.base
            if name[0] in '0123456789':
                name = f'_{name}'
            parts += [name, '=', str(member.value), ',']
        parts.append('}')

        if enum.ty == 'bitmask':
            self.bitmasks.append(parts)
        else:
            self.enums.append(parts)


    def visit_command(self, command):
        if self.command_is_excised(command):
            # Depends on an external header
            return
        self.commands.append(self.renderer.render_func(command))


    def visit_type(self, ty):
        category = ty.category()
        if category == 'type_alias':
            self.visit_alias(ty)
        elif category == 'handle':
            self.visit_handle(ty)
        elif category == 'func_pointer':
            self.func_pointers.append(self.renderer.render_func(ty))
        elif category == 'aggregate':
            self.visit_aggregate(ty)
        else:
            raise ValueError(f'unexpected category: {category}')


    def visit_alias(self, alias):
        ty = self.renderer.render_type_expr_base(alias.target)
        self.aliases.append([alias.name.base, '=', ty])


    def visit_handle(self, handle):
        if handle.dispatchable:
            self.disp_handles.append(handle.name.base)
        else:
            self.nondisp_handles.append(handle.name.base)


    def visit_aggregate(self, agg):
        assert agg.ty in ('struct', 'union')

        if any(mem.ty.base.base in self.excised for mem in agg.members):
            # Depends on an external header
            self.excised.add(agg.name.base)
            return

        if agg.ty == 'struct':
            for mem in agg.members:
                self.structs.append(self.renderer.render_aggregate(agg))
                break
            else:
                self.structs.append(self.renderer.render_aggregate(agg))
        else:
            self.unions.append(self.renderer.render_aggregate(agg))


def render_bindings(visitor):
    res = []
    for macro, entries in (
        ('bitmasks', visitor.bitmasks),
        ('enums', visitor.enums),
        ('aliases', visitor.aliases),
        ('dispatchable_handles', visitor.disp_handles),
        ('nondispatchable_handles', visitor.nondisp_handles),
        ('func_pointers', visitor.func_pointers),
        ('structs', visitor.structs),
        ('unions', visitor.unions),
        ('commands', visitor.commands),
        ('extensions', visitor.extensions),
    ):
        res += [f'\n\nimpl_{macro}!', '{']
        for entry in entries:
            if isinstance(entry, str):
                res.append(entry)
            else:
                res += entry
            res.append(';')
        res.append('}')
    return res


class Api:
    def __init__(self, registry, bindings, level):
        self.level = level

        handle_level = {
            ty.name.base: ty.level
            for ty in registry.types
            if ty.category() == 'handle'
        }

        self.commands = []
        for command in registry.commands:
            if bindings.command_is_excised(command):
                continue
            obj = command.args[0].ty.base.base
            obj_level = handle_level.get(obj)
            if obj_level != self.level:
                continue
            self.commands.append({
                'obj': obj,
                'command': command,
            })

        self.renderer = Renderer(namespace_data=False)

    @property
    def name(self):
        return f'{self.level}Table'

    @property
    def get_proc_addr(self):
        return f'Get{self.level}ProcAddr'

    @property
    def handle(self):
        return self.level.lower()

    def render(self):
        parts = [
            'impl_table!',
            '{',
            'name:', self.name, ',',
            'get_proc_addr:', self.get_proc_addr, ',',
            'handle:',
            '{',
            'name:', self.handle, ',',
            'type:', self.level, ',',
            '}', ',',
            'members:',
            '[',
        ]
        for entry in self.commands:
            command, obj = entry['command'], entry['obj']
            takes_handle = obj == self.level
            method_name = camel_to_snake(command.name.base)

            args = command.args[1:] if takes_handle else command.args
            func = dataclasses.replace(command, args=args)
            sig = self.renderer.render_signature(func)

            parts += [
                '{',
                'name:', f'pfn_{method_name}', ',',
                'method_name:', method_name, ',',
                'ptr:', command.name.base, ',',
            ]
            parts += ['signature:'] + sig + [',']
            parts += [
                'takes_handle:', str(takes_handle).lower(), ',',
                '}', ',',
            ]
        parts += [']', ',', '}', '\n\n']
        return parts


def render_loader(registry, bindings):
    apis = (Api(registry, bindings, level) for level in ('Instance', 'Device'))
    return sum((api.render() for api in apis), [])


def write_code(f, strs):
    INDENT = '    '
    indent_lvl = 0
    for i, s in enumerate(strs):
        if s in ('(', '{', '['):
            indent_lvl += 1
            f.write(s)
            f.write('\n')
            f.write(INDENT * indent_lvl)
        elif s in (')', '}', ']'):
            indent_lvl -= 1
            f.write('\n')
            f.write(INDENT * indent_lvl)
            f.write(s)
        elif s in (',', ';'):
            f.write(s)
            f.write('\n')
            f.write(INDENT * indent_lvl)
        else:
            f.write(s)
        f.write(' ')


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-i', '--input', help='Path to vk.xml.')
    parser.add_argument('-o', '--output',
        help='Output directory for generated sources')
    args = parser.parse_args()

    root = etree.parse(args.input).getroot()

    registry = Registry()
    registry.parse_registry(root)

    bindings = BindingsVisitor()
    bindings.visit(registry)
    rendered = render_bindings(bindings)
    bindings_file = os.path.join(args.output, 'bindings.rs')
    with open(bindings_file, 'w') as f:
        write_code(f, rendered)

    loader = render_loader(registry, bindings)
    loader_file = os.path.join(args.output, 'loader.rs')
    with open(loader_file, 'w') as f:
        write_code(f, loader)


if __name__ == '__main__':
    main()
